<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-20180422" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/23/20180422/">weekly of 20180422</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/23/20180422/" class="article-date">
  <time datetime="2018-04-23T03:03:45.000Z" itemprop="datePublished">2018-04-23</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/football_stadium.jpg" alt="中超现场"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://news.ycombinator.com/item?id=16862925" target="_blank" rel="external">Facebook Container for Firefox</a> : Firefox发布了一个支持自动隔离facebook的扩展, 其实现在的feed机制也一直在窃取各种个人信息，mark后续研究下，在国内互联网，这类的数据是如何传播传递的，同时又如何可以避免~</p>
</li>
<li><p><a href="http://www.graalvm.org/" target="_blank" rel="external">GraalVM</a> : “GraalVM is a universal virtual machine for running applications written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Kotlin, and LLVM-based languages such as C and C++”, Oracle出品的，意在构建一个统一的VM，看其文档，应该包括对整个编译链的支持(比如支持定制化构建自己的语言)，先mark关注</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16888605" target="_blank" rel="external">FFmpeg 4.0 released</a> : 最新版的FFmpeg好像有不少新的功能</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16889181" target="_blank" rel="external">Mermaid: Markdown-like generation of diagrams and flowcharts from text</a> : 有点类似于<code>Dot</code>语言的规则模式，不过其在生成图片的配色方面更好看一些，不过整体图片的布局还是需要进一步的优化,其也被gitlab所<a href="https://docs.gitlab.com/ee/user/markdown.html#mermaid" target="_blank" rel="external">支持</a></p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://blog.benjojo.co.uk/post/scan-ping-the-internet-hilbert-curve" target="_blank" rel="external">Mapping the whole internet with Hilbert curves</a> : 作者通过对全部IPV4的扫描, 并以可视化的方式(Hilbert曲线)展示全球IP的活跃情况</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/mYuEt2jFRcO1rbWEe9qL-g" target="_blank" rel="external">谷歌前员工因建言YouTube被炒鱿鱼，开源揭秘其算法</a> : 推荐算法越来越多影响着我们的生活, 但是其对人的影响却很难量化去描述, 本文讲述了Google前员工对于透明推荐算法运动的推进。个人认为，让用户可以透明的了解自己的推荐策略和算法，或者可以让用户自己去定制这方面的算法，Maybe也是一个不错的产品选择。</p>
</li>
<li><p><a href="https://eng.uber.com/rethinking-gps/" target="_blank" rel="external">Rethinking GPS: Engineering Next-Gen Location at Uber</a> : </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://medium.com/@anildash/the-missing-building-blocks-of-the-web-3fa490ae5cbc" target="_blank" rel="external">The Missing Building Blocks of the Web</a> :  现在互联网的一切好像都是理所当然的，比如中心化的服务交付，基于js/css等技术组合的web页面, 作者的这个系列从不忘初心开始, 讨论早期互联网技术的设计偏好，以及研究其在发展历程中间的演变，最后分析以后互联网技术发展的方向，同时可以关注的文章还有<a href="https://www.oreilly.com/ideas/its-time-to-rebuild-the-web" target="_blank" rel="external">It’s time to rebuild the web</a>和<a href="http://anildash.com/2012/12/13/the_web_we_lost/" target="_blank" rel="external">The Web We Lost</a></p>
</li>
<li><p><a href="https://betanalpha.github.io/assets/case_studies/probability_theory.html" target="_blank" rel="external">Probability Theory (For Scientists and Engineers)</a> : mark</p>
</li>
<li><p><a href="https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d" target="_blank" rel="external">Unwinding Uber’s Most Efficient Service</a> : mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247489926&amp;idx=1&amp;sn=e26ee3315236e646a5e6e78bcebfe705" target="_blank" rel="external">机器学习宗师迈克尔·乔丹：AI革命尚未发生</a> : 作者认为，技术变更的本质是『在保证安全的前提下，为人们带来新的资源和能力』，所以我们系统更系统宏观的考虑现实世界的问题，AI(或者文中所说的IA)，会是我们构建更理想目标世界(<code>II</code>(Intelligent Infrastruction))的一个强有力的工具手段，但是不会是全部，而且也很难奢望通过AI等就能自动学习构建更理想的社会。另一方面，从II的视角去考虑问题，可能会更快的触达本质。以自动驾驶为例，我们现在的从IA(AI)的角度，核心的注意力在于让汽车去拥有人的判断力；但是从II的角度，去构建一个更高效的交通体系，其会自动化控制所有汽车，通过大规模的物联网，机器学习算法去做调度控制，可能是一个更好的选择(这段纯属自己臆想)。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/35925589" target="_blank" rel="external">InnoDB 存储引擎原理解析</a> : 关于Innodb的介绍，不过是纯PPT版本，有些内容只看图片并不直观</p>
</li>
<li><p><a href="https://weibo.com/1560906700/GcZescpzI" target="_blank" rel="external">关于Pornhub的一些产品细节和道德节操</a> : 挺有意思的一个说明, Maybe只有压力没那么大的一些产品，对于用户体验和产品细节才会如此用心</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-about_pac" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/21/about_pac/">PAC文件</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/21/about_pac/" class="article-date">
  <time datetime="2018-04-21T11:18:29.000Z" itemprop="datePublished">2018-04-21</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Proxy_auto-config" target="_blank" rel="external">PAC文件</a>(Proxy Auto-Config)可以约定浏览器如何去访问一个特定的网站。其应该是最为常见的代理技术之一，以其方便，简洁，灵活性被大部分主流系统(无论是安卓还是IOS)和浏览器所支持。正好最近处理了一个PAC的问题，所以这里具体介绍PAC相关的技术，包括PAC的文件编写和PAC的代理技术。</p>
<h2 id="PAC文件编写"><a href="#PAC文件编写" class="headerlink" title="PAC文件编写"></a>PAC文件编写</h2><p>如上，PAC是一个用来约定浏览器如何访问网站的配置描述。其组织方式如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//code demo from: https://en.wikipedia.org/wiki/Proxy_auto-config</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">	<span class="comment">// our local URLs from the domains below example.com don't need a proxy:</span></div><div class="line">	<span class="keyword">if</span> (shExpMatch(host, <span class="string">"*.example.com"</span>))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"DIRECT"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// URLs within this network are accessed through</span></div><div class="line">	<span class="comment">// port 8080 on fastproxy.example.com:</span></div><div class="line">	<span class="keyword">if</span> (isInNet(host, <span class="string">"10.0.0.0"</span>, <span class="string">"255.255.248.0"</span>))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"PROXY fastproxy.example.com:8080"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// All other requests go through port 8080 of proxy.example.com.</span></div><div class="line">	<span class="comment">// should that fail to respond, go directly to the WWW:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">"PROXY proxy.example.com:8080; DIRECT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其核心是暴露一个<code>FindProxyForURL</code>的接口，每次有请求时候触发这个函数的回调，用于判断具体走哪种方式。 具体编写应用时，有如下几点可以注意: </p>
<ul>
<li><p>url/host信息 : 如果请求是<code>https</code>协议，则回调的url里面并不会包含完整路径信息, 也就是说如果原始的url是<code>https://xyz.com/abc</code>回调给<code>FindProxyForURL</code>的参数也只是<code>https://xyz.com</code>, 这就意味着对于https协议，我们做不了url粒度的代理控制。具体可以参考<a href="https://github.com/FelisCatus/SwitchyOmega/issues/845" target="_blank" rel="external">Full URLs for HTTPS are no longer provided to PAC scripts</a></p>
</li>
<li><p>调试问题: PAC的调试和普通js的调试有点不一样，其是浏览器自动触发请求的，所以方法也有些区别。在Chrome环境下，可以去<code>chrome://net-internals/#proxy</code>用于重新加载代理脚本, 同时在<code>chrome://net-internals/#events</code>去追踪日志，详细可以参考<a href="http://artica-proxy.com/how-to-debug-proxy-pac-with-google-chrome/" target="_blank" rel="external">How to debug proxy.pac with Google Chrome</a></p>
</li>
<li><p>代理问题 : 无论是怎么样的代理策略，最终我们函数需要返回的是一个代理服务器, 现在主流的浏览器主要支持如下三种访问方式:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIRECT</td>
<td>直接访问</td>
</tr>
<tr>
<td>PROXY name:port</td>
<td>通过走特定地址的http代理访问</td>
</tr>
<tr>
<td>SOCKS name:port</td>
<td>通过走特定地址的socks代理访问</td>
</tr>
</tbody>
</table>
<p>具体实现的时候也可以通过不同协议的组合或者冗余，来提供更高质量的代理服务。</p>
<p>这里我们重点关注<code>PROXY name:port</code>的方式，其提供的是一个HTTP代理访问的能力支持, 我们现在主流有http/https两个访问协议，其又具体如何去实现代理的呢？</p>
<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>如上，我们希望通过一个http/https服务来提供对<code>http/https</code>访问的代理。如果是仅仅代理<code>HTTP</code>访问, 其实算比较简单。由于是纯文本，也无需任何鉴权之类的逻辑(TLS)，只有正常转发请求即可，普通的Nginx就能实现该功能，可以参考<a href="http://shevacjs.com/2015/04/25/nginx_https_proxy/">nginx与https:正向代理支持</a>(原文有些地方有错误之处)。但是如何基于http/https的服务做<code>https</code>的代理呢? 因为对服务器的验证等不可能是代理服务器自己实现的，故而需要代理服务器，根本上面支持<code>TLS</code>或者更底层的服务代理。</p>
<p>这里需要用到<a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="external">HTTP tunnel</a>技术, 其主要包括两个步骤:</p>
<ol>
<li>协商阶段: 这个时候Client发送一个<code>CONNECT</code>指令，连接代理服务器，同时告诉代理服务器具体要访问的地址, 具体如下: </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">## Client发送CONNECT指令</div><div class="line">CONNECT example.host.com:22 HTTP/1.1</div><div class="line">Proxy-Authorization: Basic encoded-credentials</div><div class="line"></div><div class="line">## 服务器返回OK，这这次协商完成，允许代理</div><div class="line">HTTP/1.1 200 OK</div></pre></td></tr></table></figure>
<p>如上其实是一个正常标准的HTTP交互流程</p>
<ol>
<li>代理阶段 : 一旦协商OK，代理服务器这个时候有点类似于要转变成<code>TCP代理</code>，只做透明的client和server之间的数据转发</li>
</ol>
<p>可以通过一个<code>wireshark</code>的请求包，来进一步了解给过程: </p>
<p><img src="/images/http_tunnel_demo.png" alt="HTTP tunnel"></p>
<h2 id="HTTP代理实现"><a href="#HTTP代理实现" class="headerlink" title="HTTP代理实现"></a>HTTP代理实现</h2><p>从HTTP代理的协议我们可以知道，如果一个服务器要实现HTTP tunnel代理既要支持HTTP的CONNECT指令，也得支持<code>TLS</code>或者<code>TCP</code>的代理。这个要求对于之前的nginx是很难实现的，所以大部分的解决方案都是基于<code>squid</code>，当然我们知道通过<a href="https://github.com/chobits/ngx_http_proxy_connect_module" target="_blank" rel="external">ngx_http_proxy_connect_module</a>也能实现，但是需要打上patch包，维护成本相对较高。</p>
<p>那有没有可能用更便捷的方式，让Nginx实现HTTP tunnel代理呢？答案是肯定的！</p>
<p>我们知道Nginx已经通过<code>ngx_stream_core_module</code>, <code>ngx_stream_proxy_module</code>等模块这次了TCP/UDP的代理，加上<a href="https://github.com/openresty/stream-lua-nginx-module" target="_blank" rel="external">openresty/stream-lua-nginx-module</a>的支持，我们可以很方便的去实现上面的代理协议。整体思路如下:</p>
<ol>
<li>应用nginx的stream能力，做TCP的透明代理</li>
<li>对于初次建立链接的请求，做一些包体的分析，如果是CONNECT方式，则以HTTP方式返回数据，构建协商协议</li>
<li>协商之后，则以TCP代理方式提供服务即可</li>
</ol>
<p>整体代码配置如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="section">stream</span> &#123;</div><div class="line">	<span class="attribute">log_format</span> basic <span class="string">'<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>] '</span></div><div class="line">					 <span class="string">'<span class="variable">$protocol</span> <span class="variable">$status</span> <span class="variable">$bytes_sent</span> <span class="variable">$bytes_received</span> '</span></div><div class="line">					 <span class="string">'<span class="variable">$session_time</span>'</span>;</div><div class="line"></div><div class="line">    <span class="comment">## 需要声明一个变量，注意该指令在stream-lua-nginx-module-0.0.4版本以上才有</span></div><div class="line">    <span class="attribute">lua_add_variable</span> <span class="variable">$py_upstream</span>;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">7070</span>;</div><div class="line"></div><div class="line">		<span class="attribute">access_log</span> logs/stream.log basic;</div><div class="line"></div><div class="line">        <span class="comment">## 指定dns解析代理服务器</span></div><div class="line">        <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</div><div class="line"></div><div class="line">        <span class="comment">## preread_by_lua是在每次连接建立(TCP)或者数据包(UDP)过来被触发调用</span></div><div class="line">        <span class="comment">## 代码无太多容错性，仅用于描述功能</span></div><div class="line">        <span class="section">preread_by_lua_block</span> &#123;</div><div class="line">            <span class="attribute">local</span> sock = assert(ngx.req.socket(<span class="literal">true</span>))</div><div class="line">            <span class="comment">## 获取数据</span></div><div class="line">            local data = sock:receive()</div><div class="line">            local len = string.len(data)</div><div class="line">            local connect = string.sub(data,<span class="number">1</span>, <span class="number">7</span>)</div><div class="line"></div><div class="line">            <span class="comment">## ngx.log(ngx.ERR, "data is: ", data)</span></div><div class="line">            <span class="comment">## 判断前缀是不是"CONNECT"</span></div><div class="line">            if connect ~= <span class="string">"CONNECT"</span> then</div><div class="line">                ngx.log(ngx.ERR, <span class="string">"prefix scheme is connect, is: "</span>, connect)</div><div class="line">                ngx.exit()</div><div class="line">            end</div><div class="line"></div><div class="line">            <span class="comment">## 获取要发送的域名端口信息</span></div><div class="line">            local end_start,end_pos = string.find(data,<span class="string">" "</span>, <span class="number">9</span>)</div><div class="line">            local hostname = string.sub(data,<span class="number">9</span>, end_start - <span class="number">1</span>)</div><div class="line">            ngx.log(ngx.ERR, <span class="string">"hostname is: "</span>, hostname)</div><div class="line"></div><div class="line">            <span class="comment">## 回填到py_upstream变量，以便proxy_pass调用</span></div><div class="line">            ngx.var.py_upstream = hostname</div><div class="line"></div><div class="line">            <span class="comment">## 以正常HTTP方式返回，完成协商</span></div><div class="line">            ngx.say(<span class="string">"HTTP/1.1 200 OK\r\n"</span>)</div><div class="line">            ngx.flush()</div><div class="line">            ngx.eof()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">## 正向代理</span></div><div class="line">        proxy_pass <span class="variable">$py_upstream</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，就能完成一个<code>http tunnel</code>协议的功能。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="http://jdebp.eu./FGA/web-browser-auto-proxy-configuration.html" target="_blank" rel="external">Automatic proxy HTTP server configuration in web browsers</a> : 对PAC协议，实现，规则有详细的描述</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="external">HTTP tunnel</a> : 具体介绍<code>HTTP tunnel</code>的机制, 也就是http proxy代理https请求的常规方法</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT" target="_blank" rel="external">MDN HTTP: CONNECT</a> : HTTP CONNECT方法</p>
</li>
<li><p><a href="https://github.com/chobits/ngx_http_proxy_connect_module" target="_blank" rel="external">A forward proxy module for CONNECT request handling</a> : 一个Nginx patch/扩展, 可以支持HTTP tunnel的<code>CONNECT</code>请求， 支持<code>Forward Proxy</code></p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx-proxy/">nginx, proxy</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180415" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/18/20180415/">weekly of 20180415</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/18/20180415/" class="article-date">
  <time datetime="2018-04-18T04:26:45.000Z" itemprop="datePublished">2018-04-18</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/yanqing.jpg" alt="延庆一景"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://ultralig.ht/" target="_blank" rel="external">Lightweight, Pure-GPU HTML Renderer</a> : 一个纯GPU执行的HTML渲染器，对于游戏类的业务场景会有比较好的支持</p>
</li>
<li><p><a href="http://0x80.pl/notesen/2018-04-11-simd-is-sorted.html" target="_blank" rel="external">Is sorted using SIMD instructions</a> : 判断一个数组是否有序的最简单算法，就是遍历数组，依次比较; 但是如果处理器本身支持<code>SIMD</code>之类，会有怎么样的优化算法呢?文章具体说明了如何将上面操作<code>vectorization</code>，以提升判断的速度，结果表明在<code>AVX2</code>的指令集下面性能有<code>100%</code>以上的提升, 对SIMD指令感兴趣的话，可以参看<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" target="_blank" rel="external">Intrinsics Guide</a>这个指令手册</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://blog.cloudflare.com/neon-is-the-new-black/" target="_blank" rel="external">NEON is the new black: fast JPEG optimization on ARM server</a> : CloudFlare的技术博客，介绍其对<code>libjpg</code>在ARM平台的优化，主要是讲将在Intel下面优化的SIMD指令在ARM系统上面重写, 总结值得思考: “It is evident that the Qualcomm Centriq is a powerful processor, that definitely provides a good bang for a buck. However, years of Intel leadership in the server and desktop space mean that a lot of software is better optimized for Intel processors.”</p>
</li>
<li><p><a href="https://snr.stanford.edu/salsify/" target="_blank" rel="external">Salsify</a> : Salsify是斯坦福大学的一个项目，其核心思路是通过对视频编码速率和网络速率的协同控制，来提升<code>real time video</code>的性能和体验，直接感觉意义一般，但是其性能数据体现”reduced delay (at the 95th percentile) by 4.6×, while also improving SSIM by about 60% (2.1 dB)”，先mark，后续有空关注</p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周关注GPU编程</p>
</blockquote>
<ul>
<li><p><a href="http://courses.cms.caltech.edu/cs179/" target="_blank" rel="external">课程: GPU Programming CS179</a> : 比较综合的介绍GPU的概念基础，以及和CUDA的实践, 可以关注<a href="https://news.ycombinator.com/item?id=11902172" target="_blank" rel="external">Hacer News</a>上面对其评价</p>
</li>
<li><p><a href="https://cn.udacity.com/course/intro-to-parallel-programming--cs344" target="_blank" rel="external">课程: 并行编程入门 by Nvidia</a> : 中文版的课程</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://weibo.com/1705822647/GbThVDxKJ?type=comment" target="_blank" rel="external">关于百度区块链应用的思考</a> : 用区块链进行图片和内容版权保护的问题，作者的存疑和我个人的思考分析一致，mark下关注网友的讨论</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16827817" target="_blank" rel="external">Quantum mechanics used for better random numbers</a> : 量子计算机可以产生真正的随机数，但是评论上面认为，其实现在的不少硬件，比如说<code>Johnson–Nyquist</code>已经具备这类能力了</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16817234" target="_blank" rel="external">Quantum Algorithm Implementations for Beginners</a> : </p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180408" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/20180408/">weekly of 20180408</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/17/20180408/" class="article-date">
  <time datetime="2018-04-17T14:21:45.000Z" itemprop="datePublished">2018-04-17</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://blog.cryptographyengineering.com/2018/04/07/hash-based-signatures-an-illustrated-primer/" target="_blank" rel="external">Hash-based Signatures: An illustrated Primer</a> : 文章和作者的blog多深度推荐</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487203&amp;idx=1&amp;sn=a1510a4d29a7bdb9cc60d58c13161db9" target="_blank" rel="external">当数据库遇见FPGA：X-DB异构计算如何实现百万级TPS？</a> : 阿里数据库方向的又一个创新，核心问题是, 在基于LSM存储引擎构建的数据库，需要耗费大量的计算量在做<code>SSTable</code>的merge, 这类的<code>compaction</code>计算量大且计算模式相对一致，基于此，其构建了一个传统CPU架构+<code>FPGA</code>的协同计算模式, 对于写密集型的业务场景有着较大效率提升。</p>
</li>
<li><p><a href="https://blog.codingnow.com/2018/04/lua_54_nil_in_table.html" target="_blank" rel="external">Lua 5.4 的改进及 Lua 的版本演进</a> : 先Mark，没有深看，但是非常佩服云风对技术的持续投入和研究~</p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周关注simd</p>
</blockquote>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="external">Wikipedia: SIMD</a> : 对SIMD的概念性介绍, 其是一类并行技术的概称”单指令流多数据流”。在具体应用方面，CPU多以<code>SSE(Intel)</code>或者<code>3D Now!(AMD)</code>等提供支持，而GPU则是本身就拥有类似的能力。</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=8533350" target="_blank" rel="external">Introducing SIMD.js</a> : Mozilla发布的<code>SIMD</code>支持的Js Library, 主要是基于CPU的<code>SSE</code>或者<code>NEON</code>提供<code>SIMD</code>能力，希望在<code>games, video and audio manipulation, scientific simulations</code>提升其相关能力。</p>
</li>
<li><p><a href="http://sci.tuomastonteri.fi/programming/sse" target="_blank" rel="external">A practical guide to SSE SIMD with C++</a> : 关于SSE SIMD的实践教程，感觉有点冗长，另外也可以参看<a href="http://www.cs.uu.nl/docs/vakken/magr/2017-2018/files/SIMD%20Tutorial.pdf" target="_blank" rel="external">Practical SIMD Programming(pdf)</a></p>
</li>
</ul>
<blockquote>
<p>关于<a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network" target="_blank" rel="external">TOR</a>)的一些文章</p>
</blockquote>
<ul>
<li><p><a href="https://jordan-wright.com/blog/2015/02/28/how-tor-works-part-one/" target="_blank" rel="external">How Tor Works(Part1/2/3)</a> : 从较为宏观的角度介绍Tor的执行机制和核心设计理念，是理解TOR的比较好的入门文档, 另外作者本身的blog主要关注安全因素相关，有不少文章值得细看</p>
</li>
<li><p><a href="https://www.digitaltrends.com/computing/a-beginners-guide-to-tor-how-to-navigate-through-the-underground-internet/" target="_blank" rel="external">A beginner’s guide to Tor: How to navigate through the underground Internet</a> : 也是一个入门的文章</p>
</li>
<li><p><a href="http://www.cs.umd.edu/class/fall2017/cmsc818O/papers/understanding-tor.pdf" target="_blank" rel="external">Shining Light in Dark Places: Understanding the Tor Network(pdf)</a> : </p>
</li>
<li><p><a href="https://www.freehaven.net/anonbib/cache/draft-tor-design-2004.pdf" target="_blank" rel="external">Tor: The Second-Generation Onion Router(pdf)</a> : 类似于Tor的白皮书，系统性介绍如何设计相关系统，可以深入了解</p>
</li>
<li><p><a href="https://www.torproject.org/docs/onion-services.html.en" target="_blank" rel="external">Tor: Onion Service Protocol</a> : 我们知道Tor不仅能提供匿名访问，也通用支持匿名提供<code>online service</code>; 其核心机制是依赖<a href="https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt" target="_blank" rel="external">rendezvous specification</a>，也就是依赖”约会协商”出一个中转<code>Relay</code>, 再基于此节点双方进行通信</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://redbeardlab.tech/rediSQL/" target="_blank" rel="external">RedisSQL</a> : RediSQL is a Redis module that embeds a fully functional SQLite database. 也就是说，基于<code>SQLit</code>做存储引擎，通过<code>Redis Module</code>做接口扩展，对于<code>partition</code>和<code>replication</code>的问题，应该不大好解决，但文章也没有特多涉及，需要细究。</p>
</li>
<li><p><a href="https://weibo.com/2126427211/GavUQjfLa?type=comment#_rnd1523244261713" target="_blank" rel="external">Deep learning的发展历程</a> : 比较系统，概括性的介绍了，深度学习的发展历程</p>
</li>
<li><p><a href="https://weibo.com/1907380525/Gbg8LzxEI?type=comment#_rnd1523274106579" target="_blank" rel="external">What are the ten most cited sources on Wikipedia? Let’s ask the data</a> : 关于Wikipeida资料引用的有趣分析, 文末付<a href="https://medium.com/freely-sharing-the-sum-of-all-knowledge/what-are-the-ten-most-cited-sources-on-wikipedia-lets-ask-the-data-34071478785a" target="_blank" rel="external">英文链接</a></p>
</li>
<li><p><a href="https://github.com/hongfanqie/discussion/issues/1" target="_blank" rel="external">技术文章翻译规范</a> : mark</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16806976" target="_blank" rel="external">AV1 beats x264 and libvpx-vp9 in practical use case</a> : “Our testing shows AV1 surpasses its stated goal of 30% better compression than VP9, and achieves gains of 50.3%, 46.2% and 34.0%, compared to x264 main profile, x264 high profile and libvpx-vp9, respectively.However, AV1 saw increases in encoding computational complexity compared with x264 main, x264 high and libvpx-vp9 for ABR mode. Encoding run time was 9226.4x, 8139.2x and 667.1x greater, respectively…”</p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/teamblog/docs-extension" target="_blank" rel="external">Announcing the Docs Markdown Extension for Visual Studio Code</a> : 基于<a href="https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html?tabs=tabid-2%2Ctabid-b" target="_blank" rel="external">DFX</a>语法的VS CODE扩展，个人感觉其语法赋予了不少新奇的能力，可以关注</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180401" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/20180401/">weekly of 20180401</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/04/06/20180401/" class="article-date">
  <time datetime="2018-04-06T13:15:45.000Z" itemprop="datePublished">2018-04-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://github.com/Microsoft/vscode-tips-and-tricks" target="_blank" rel="external">VS Code Tips and Tricks</a> : 关于VS的tips，简单看了一些，感觉干货还是很多的。之前个人习惯所有的编辑任务都是依赖于命令行的<code>vim</code></p>
</li>
<li><p><a href="https://www.charlesproxy.com/documentation/ios/" target="_blank" rel="external">Charles for iOS</a> : Charles支持在IOS系统的请求包分析和捕获,体验还是很不错的。</p>
</li>
<li><p><a href="https://bdupras.github.io/filter-tutorial/" target="_blank" rel="external">Probabilistic Filters By Example</a> : 本文简要介绍了<a href="https://brilliant.org/wiki/cuckoo-filter/#cuckoo-vs-bloom-filters" target="_blank" rel="external">Cuckoo Filter</a> 和<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="external">Blomm Filter</a>各自的特点以及区别, 并具体给出了不用应用场景下面如何选择两者的建议。(PS: 发现网上并没有很多的Cuckoo Filter的入门介绍文章，后续可以补充一个)</p>
</li>
<li><p><a href="https://blog.cloudflare.com/dns-resolver-1-1-1-1/" target="_blank" rel="external">Announcing 1.1.1.1: the fastest, privacy-first consumer DNS service</a> : Cloudflare在4月1号发布了号称速度最快的DNS服务器<code>1.1.1.1</code>, 可以参看<a href="https://blog.cloudflare.com/dns-resolver-1-1-1-1/" target="_blank" rel="external">Introducing DNS Resolver, 1.1.1.1 (not a joke)</a>对其技术细节进行深入了解，包括对DNS查询的隐私保护，速度优化方面的策略，对DNS服务有兴趣的可以深入了解下, 正好也可以关注文章<a href="http://blog.jobbole.com/113809/" target="_blank" rel="external">DNS 解析器性能比较：CloudFlare vs Google vs Quad9</a>, 里面具体对比了几个大型DNS服务商的响应时间，cloudflare的确遥遥领先</p>
</li>
<li><p><a href="https://medium.com/@NetflixTechBlog/netflix-flamescope-a57ca19d47bb" target="_blank" rel="external">Netflix FlameScope</a> : Netflix开放了另外一个关于<code>flame graph</code>的工具，其主要特点是通过热力图的形式，以<code>100ms</code>为粒度，记录不同时刻的时间情况，并支持基于此粒度进行钻取。同时还可以关注二进制数据的可视化方法，<a href="https://github.com/cortesi/scurve" target="_blank" rel="external">lib库</a>和<a href="https://binvis.io/#/" target="_blank" rel="external">demo</a></p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://medium.com/@NetflixTechBlog/performance-under-load-3e6fa9a60581" target="_blank" rel="external">Performance Under Load</a> : Netflix关于如何做过载保护的文章，其实这个topic，个人感觉也研究了一段时间，包括排队论等都做了一些分析。文章的核心思路是复用TCP拥塞控制的算法, 开始以较低流量去尝试，在流量逐渐增大的过程中，通过一些参数指标评估服务是否达到瓶颈，如果是，则流量回退(类似于拥塞窗口减少)($newLimit = currentLimit × gradient + queueSize$)。同时也直接开放了相关的<a href="https://github.com/Netflix/concurrency-limits" target="_blank" rel="external">lib库</a>, 支持Java/Grpc等，可以关注。</p>
</li>
<li><p><a href="https://blog.cloudflare.com/introducing-cloudflare-workers/" target="_blank" rel="external">Introducing Cloudflare Workers: Run JavaScript Service Workers at the Edge</a> :  CloudFlare的<code>Service Worker</code>概述，赋予了业务在Edge Node(类似于CDN)执行代码的能力，后端的同学可以通过这篇文章<a href="https://lzw.me/a/pwa-service-worker.html#1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Service%20Worker" target="_blank" rel="external">Service Worker 应用详解</a>了解浏览器service worker的大概机制；整体而言，个人感觉思路和创新都是有的，不过对于应用场景还需要深入和进一步的思考</p>
</li>
<li><p><a href="https://medium.com/netflix-techblog/using-machine-learning-to-improve-streaming-quality-at-netflix-9651263ef09f" target="_blank" rel="external">Using Machine Learning to Improve Streaming Quality at Netflix</a> : 通过ML的方法，来预估网络的质量和延迟情况，先mark</p>
</li>
</ul>
<h3 id="琐事小记"><a href="#琐事小记" class="headerlink" title="琐事小记"></a>琐事小记</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://cstaecker.fairfield.edu/~cstaecker/machines/longimeter.html" target="_blank" rel="external">Steinhaus Longimeter</a> : mark，一个测量曲线长度的办法，非常精巧，先mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/moyoJd1EnNziRPQgHbNXRw" target="_blank" rel="external">从抄书到开源之巅：章亦春的程序人生</a> : 非常敬佩的工程师, 每个成功故事的历程都有所不一样，但是持续努力奋斗是永恒的主题；</p>
</li>
<li><p><a href="https://www.dongqiudi.com/archive/596265.html" target="_blank" rel="external">西甲风云21：铁血军团，马德里竞技</a> : “催人泪下的卡尔德隆，这是我的家。它教会我怎样成长，怎样忍耐，怎样生活，怎样面对困境。不管贫富，我们永远是第一！Forza Atleti!”, 有点跑题的文章，不过写得很好，也mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247487637&amp;idx=1&amp;sn=d76a3e92036c0487c6f3e16b6afd3df8" target="_blank" rel="external">聊聊Chaos Engineering的历史、原则和最佳实践</a> : 我的理解<code>Chaos Engineering</code>应该属于SRE的一部分，其采用特殊的方法，去验证系统的容灾能力，评估系统的可用性。随着分布式系统的日趋复杂，这样的需求也会愈加强烈。</p>
</li>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404225376346895947" target="_blank" rel="external">既练轻功也练内功——面对风口的正确姿势</a> : 每个人都会面临各种选择和权衡，如何合适的机会和风口，让自己的职业生涯有进一步提升，是个需要深思的问题, 作者建议的三个原则，学会预测，需找开鱼刀，练轻功之前先修炼好内功, 可以采纳</p>
</li>
<li><p><a href="http://www.quickcode.co/engineer-blogs" target="_blank" rel="external">Engineering Blogs</a> : 一些公司的技术blog的list，感觉可以通过收藏夹或者其他的可以序列话的方式提供。</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-note_about_crypto101" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/note_about_crypto101/">Crypto101读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/28/note_about_crypto101/" class="article-date">
  <time datetime="2018-03-28T07:58:45.000Z" itemprop="datePublished">2018-03-28</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/cryptography.jpg" alt="cryptography"></p>
<blockquote>
<p>最近要把去年的读书笔记补齐~</p>
</blockquote>
<p>电子书<a href="https://www.crypto101.io/" target="_blank" rel="external">Crypto 101</a>是我个人感觉最好的关于密码学的入门笔记; 深入浅出的介绍了整个密码学体系的各类算法，此文为此书的读书笔记</p>
<h2 id="分层体系"><a href="#分层体系" class="headerlink" title="分层体系"></a>分层体系</h2><ul>
<li><p>第一层: 最底层是基础算法原语的实现, 比如: md5, AES, RSA, SHA256等</p>
</li>
<li><p>第二层: 选定参数后，划分为符合密码学标准分类的算法, 几个基本能力:</p>
<ul>
<li>块加密算法</li>
<li>流加密算法</li>
<li>密钥交换算法</li>
<li>公钥加密算法</li>
<li>MAC算法</li>
<li>签名算法</li>
</ul>
</li>
<li><p>第三层: 基于标准分类算法进一步组合而成的半成品，比如说对称传输组件例如<code>aes-128-cbc + hmac-sha256</code>, 认证密钥协商算法<code>rsassa-OAEP + ecdh-secp256r1</code></p>
</li>
<li><p>第四层: 用各种组件拼装而成的各种成品密码学协议/软件, 比如TLS协议等</p>
</li>
</ul>
<p>这里先介绍第一/二层的常见技术和方法，以后再深入分析第四层的业务应用。</p>
<h2 id="标准密码学概述"><a href="#标准密码学概述" class="headerlink" title="标准密码学概述"></a>标准密码学概述</h2><h3 id="Block-ciphers"><a href="#Block-ciphers" class="headerlink" title="Block ciphers"></a>Block ciphers</h3><ul>
<li>定义:</li>
</ul>
<p>A block cipher is an algorithm that allows us to encrypt blocks of a fixed length.  It provides an encryption function E that turns plaintext blocks P into ciphertext blocks C, using a secret key k:</p>
<p>$$ C = E(k, P) \ \ encrpytion $$<br>$$ P = D(k, C) \ \ decryption $$</p>
<p>一般情况下, 明文和密文的长度是一样的，这个是由密钥控制的；</p>
<p>常见放的对称加密算法有: <code>AES</code>(Advanced Encryption Standard) 和 相对比较老的 <code>DES</code>和<code>3DES</code></p>
<p>可以预见块加密算法有两个比较大的问题，具体包括:</p>
<p>1) 块加密算法只能加密固定长度的信息，这个并不能很好应用于现实世界，所以我们需要引入<code>Stream ciphers</code></p>
<p>2) 密钥非常重要，但我们仍会面临着如何在一个不安全的通道上面交互密钥；这个在<code>key exchange protocol</code>里面会介绍其解决方案</p>
<h3 id="Stream-Ciphers"><a href="#Stream-Ciphers" class="headerlink" title="Stream Ciphers"></a>Stream Ciphers</h3><p>还是先看定义，英文如下:</p>
<p>“A stream cipher is a symmetric-key encryption algorithm that encrypts a stream of bits. Ideally, that stream could be as long as we’d like;”</p>
<p>如何实现, 初步的想法就是基于<code>Block Ciphers</code>去实现，将超长的文本切分为固定长度的子串，再分别加密。如何将<code>block ciphers</code>变成<code>stream ciphers</code>是需要精细考量的。比如最简单的ECB模式(Electronic Code Book Mode),  其过程大概如下:</p>
<p><img src="/images/ECB_encryption.svg.png" alt="ECB加密过程"></p>
<p><img src="/images/ECB_decryption.svg.png" alt="ECB解密过程"></p>
<p>但是这个模块是的弱点非常明显, 比如攻击者可以方便地做流量重放，而且密文和原始明文的顺序也是一一对应，容易被攻击。</p>
<p>我们可以考虑其他的几个方式，包括:</p>
<ul>
<li>CBC :  “plaintext blocks are XORed with the previous ciphertext block before being encrypted by the block cipher.”, 同时对于第一个block，我们通过引入初始向量解决(initialization vector, <code>IV</code>) ，其中<code>IV</code>我们要求满足不可预测的要求，所以一般用CBC模式加密的时候还需要双方达成<code>IV</code>的一致这个步骤(后续详解)</li>
</ul>
<p>如下是CBC的加解密过程示意图:</p>
<p><img src="/images/CBC_encryption.svg.png" alt="CBC加密过程"><br><img src="/images/CBC_decryption.svg.png" alt="CBC加密过程"></p>
<p>CBC模式对于初始向量有较大依赖，一旦<code>IV</code>被攻击者预测等，整个加密的安全性也难以得到保障</p>
<p>一些数学形式化的说明如下，可以简单参考</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Formulas</th>
<th>Ciphertext</th>
</tr>
</thead>
<tbody>
<tr>
<td>ECB</td>
<td>$Y_i = F(Plaintext_i, Key)$</td>
<td>$Y_i$</td>
</tr>
<tr>
<td>CBC</td>
<td>$Y_i = Plaintext_i XOR \ Ciphertext_{i-1}$</td>
<td>$F(Y,key); Ciphertext_0 = IV$</td>
</tr>
<tr>
<td>PCBC</td>
<td>$Y_i = Plaintext_i XOR \ (Ciphertext_{i-1} XOR \ Plaintext_{i-1})$</td>
<td>$F(Y,key); Ciphertext_0 = IV$</td>
</tr>
</tbody>
</table>
<p>虽然通过<code>CBC</code>等模式，我们可以实现对字节流的加密，但是如何达成密钥的一致性依旧是个问题，所以我们可以看下<code>Key Exchange Protocol</code></p>
<p>(如上的内容和表格都来自于<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="external">Wikipedia:Block cipher mode of operation</a>)</p>
<h3 id="Key-exchange"><a href="#Key-exchange" class="headerlink" title="Key exchange"></a>Key exchange</h3><p>目标大概如下: “Key exchange protocols attempt to solve a problem that, at first glance, seems impossible. Alice and Bob, who’ve never met before, have to agree on a secret value.  the channel they use to communicate is insecure: we’re assuming that everything they send across the channel is being eavesdropped on.”</p>
<p>该协议又称<code>Diffie-Hellman</code>算法, 一般有两个实现方式，包括<code>discrete logarithms</code>和<code>elliptic curves</code>，前者相对来说比较好理解，下面详细说明:</p>
<p>离散对数问题基于如下的假设，对于等式:</p>
<p>$$ g^x \equiv y (mod \ p) $$</p>
<p>已知$g,p$, 给定$x$计算$y$很容易，反之则很难; 则我们可以推理如下: </p>
<p>对于消息交换者Alice, Bob 和 窃听者Eve, 他们在传输消息时候有($r_a$和$r_b$是A，B产生的随机数), 则他们初步可以发送如下两个消息:</p>
<p>$$ m_a \equiv g^{(r_a)}(mod\ p)$$ </p>
<p>$$ m_b \equiv g^{(r_b)}(mod\ p)$$ </p>
<p>依照约定，可以产生密钥$s$</p>
<p>$$ s = (g^{(r_a)})^{r_b} (mod\ p)$$</p>
<p>这两个消息，三个人都能看见；但是对Alice而言，他收到了$m_b$我们有:</p>
<p>$$ s = m_b^{r_a} (mod\ p)$$ </p>
<p>对Bob同理；</p>
<p>$$ s = m_a^{r_b} (mod\ p)$$</p>
<p>但是对于只有$m_a,m_b,g,p$的Eve来说是不能计算出$s$的, 即便$m_a, m_b$相乘:</p>
<p>$$ t = m_a * m_b (mod\ p) = g^{r_a + r_b} (mod\ p)$$</p>
<p>如下是从<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">Wikipedia: 迪菲-赫尔曼密钥交换</a>摘录的示意图: </p>
<p><img src="/images/Diffie-Hellman-demo.svg.png" alt="DH示意图"></p>
<p>这个算法很优雅，但是存在很大的问题，就是中间人攻击。 所以我们需要一些新的基础能力，比如说去验证Alice和Bob的真假, 去保障我们消息的完整性。这个后续再讨论如何去保障。</p>
<h3 id="Public-Key-encryption"><a href="#Public-Key-encryption" class="headerlink" title="Public-Key encryption"></a>Public-Key encryption</h3><p>定义: “People can encrypt information intended for you by using your public key.  the information is then impossible to decipher without your private key.”</p>
<p>这里咬文嚼字一翻，公钥加密算法并不等同与『公钥算法』，后者的应用场景会更多，包括:</p>
<ul>
<li>密钥交换</li>
<li>加密信息</li>
<li>数字签名</li>
</ul>
<p>常见的公钥算法包括: </p>
<ul>
<li>RSA encryption algorithm (PKCS#1)</li>
<li>Various elliptic curve techniques</li>
<li>Diffie–Hellman key exchange protocol</li>
<li>ElGamal</li>
</ul>
<p>现在主流的是RSA和基于椭圆曲线的加密算法。</p>
<p>公钥算法是一个非常大的进步，而且直接感觉，好像所有的密码学问题都可以通过公钥算法解决。但是从现实角度而言,但是仅仅依靠此还不能构建健壮的安全体系，具体的问题包括:</p>
<ul>
<li>作用范围 : 公钥加密算法只能加密一小块的数据</li>
<li>性能问题，这个可以通过混合加密体系解决(公钥+对称加密)</li>
<li>合法性验证问题: 虽然我们可以加密解密任何消息，但是我们并不知道此消息是否来自真的发送者</li>
</ul>
<p>对与最后一个问题，我们需要一个机制去验证消息的合法性(完整性和不可否认性)；常见的做法是在发送消息的时候，增加一些额外信息，这次信息只能是正确的发送者才能构造的；同加密算法一样，验证消息机制同样有对称和非对称体系。如果发送方和接收方用同一个key进行验证，我们一般称为<code>MAC</code>(message authentication codes)；如果用不同的key进行验证，我们则称为<code>signature</code>(数字签名)</p>
<p>在介绍着两者之前，我们先简单介绍他们的基础支持体系 – hash function</p>
<h3 id="Hash-functions"><a href="#Hash-functions" class="headerlink" title="Hash functions"></a>Hash functions</h3><p>Hash函数一般而言是对一段文本的摘要(<code>digest</code>), 用于加密验证的hash function一般有更高的要求, 不再赘述，常见的有如下几个算法: </p>
<ul>
<li>MD5 : 不建议了</li>
<li>SHA-1 : 不建议范畴了</li>
<li>SHA-2 : 现在通用的</li>
<li>SHA-3(Keccak) : 未来的标准</li>
</ul>
<p>可以区别和注意的是<code>SHA2</code>和<code>SHA3</code>,后者的设计理念和前者完全不一致，在硬件上面的性能也更为高效。可以参看<a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" rel="external">Wikipedia:SHA-3
</a> 对比不同hash function的特性，表格太大，就不直接摘录了。</p>
<h3 id="Message-authentication-code"><a href="#Message-authentication-code" class="headerlink" title="Message authentication code"></a>Message authentication code</h3><p>定义: A Message authentication code (MAC) is a small bit of information that can be used to check the authenticity and the integrity of a message.  else codes are often called ”tags”</p>
<p>也就是说在双方共享$K_m$的情况下，需要达成一种协议，包括接收方能够快速的验证$P$的完整性。本质而言，就是需要一个$F$, 支持如下的模式:</p>
<p>$$ t = F(P, K_m)$$</p>
<p>对于如何将MAC和加密消息组合，有三种不同的方式，包括:</p>
<ul>
<li>Authenticate and encrypt : 分别进行消息验证和加密，类似于 $C = E(K_C, P), t = MAC(K_m, P)$, 同时发送$C$和$t$, SSH采用该方式</li>
<li>Authenticate, then encrypt : 对消息进行验证，其次和明文组合一起后加密发送，如下方式 $t=MAC(K_m,P), C=E(K_C,P||t)$, 只要发送$C$ 就可以了, TLS采用的方式</li>
<li>Encrypt, then authenticate : 先加密, 对加密串算MAC，后一起发送，类似$C=E(K_C,P), t=MAC(K_M,C)$, IPSec采用的方式</li>
</ul>
<p>普遍认为第三种方式是最好的，因为在解密之前就可以验证消息的合法性；</p>
<p>对于<code>MAC</code>的具体实现方式，本质而言，就是需要一个$F$, 给定密钥</p>
<ul>
<li>简单的方式: $t=H(k||m)$, H可以选择一个hash function,  这类组合方式有较大的安全风险(不展开)</li>
<li>HMAC(Hash-based Message Authentication Code<br>) : 其是通过特殊计算的消息验证码，有着更好的安全保障。可以参看其<a href="https://tools.ietf.org/html/rfc2104" target="_blank" rel="external">RFC文档</a></li>
<li>One-times MAC</li>
</ul>
<p>从上面可以看到, 我们现在对于<code>加密</code>和<code>消息验证</code>是当做两个独立的操作，但是在现实生活中，我们很少会独立应用这两个场景，所以现在也提出了AEAD(Authenticated Encryption with Associated Data), 其能支持”验证加密”(authenticated encryption), 将AE的能力以直观的方式提供给业务方。</p>
<h3 id="Signature-algorithms"><a href="#Signature-algorithms" class="headerlink" title="Signature algorithms"></a>Signature algorithms</h3><p>简单定义如下: </p>
<p>A signature algorithm is the public-key equivalent of a message authentication code. It consists of three parts:</p>
<ol>
<li>a key generation algorithm, which can be shared with other public-key algorithms</li>
<li>a signature generation algorithm </li>
<li>a signature verification algorithm</li>
</ol>
<p>很自然而然的我们可以想到<code>RSA</code>可以用于数字签名</p>
<p>下面我们简单分析另外一个数字签名算法<code>DSA</code>, 其分为两个缓解，一个是参数选择，另外一个是生成公钥私钥; 具体如下:</p>
<blockquote>
<p>TODO, 补充</p>
</blockquote>
<h4 id="DSA-Parameter-generation"><a href="#DSA-Parameter-generation" class="headerlink" title="DSA Parameter generation"></a>DSA Parameter generation</h4><h4 id="Key-generation"><a href="#Key-generation" class="headerlink" title="Key generation"></a>Key generation</h4><p>如下是常见的签名算法(<a href="https://en.wikipedia.org/wiki/Digital_signature" target="_blank" rel="external">Wikipedia: Digital signature
</a>)</p>
<ul>
<li>RSA-based signature schemes, such as RSA-PSS</li>
<li>DSA and its elliptic curve variant ECDSA</li>
<li>Edwards-curve Digital Signature Algorithm and its Ed25519 variant.</li>
</ul>
<h2 id="通信过程概述"><a href="#通信过程概述" class="headerlink" title="通信过程概述"></a>通信过程概述</h2><p>通过如上的分析，我们可以认为拥有如下几个能力:</p>
<ul>
<li>对称加密能力 : 给定一个key，将内容进行加密的能力</li>
<li>消息散列 : 通过一个key，可以验证消息的完整性和认证</li>
<li>非对称加密能力: 可以通过公钥密钥进行加解密</li>
<li>数字签名 : 通过非对称密钥验证消息完整性和认证</li>
</ul>
<p>基于此，可以构建上层更复杂丰富的业务场景，比如说<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a>; 这个里面的细节比较多，我们在以后的文章详细介绍TLS的协议流程。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/">cryptography</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180318" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/27/20180318/">weekly of 20180318</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/27/20180318/" class="article-date">
  <time datetime="2018-03-27T02:57:45.000Z" itemprop="datePublished">2018-03-27</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://www.nginx.com/blog/nginx-1-13-10-grpc/" target="_blank" rel="external">Announcing gRPC Support in NGINX</a> : Nginx支持Grpc方式的服务代理，和服务转发, 下来写文章重点关注</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16609429" target="_blank" rel="external">RedisGraph: A High Performance In-Memory Graph Database as a Redis Module</a> : 作者基于Redis的扩展机制，写了一个基于<code>openCypher</code>接口，底层存储以<a href="Hexastore">Hexastore</a>为主的图数据库; 之前对于图数据库理解一般, 可以持续关注</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16651426" target="_blank" rel="external">TCP Tracepoints</a> : Linux 4.15版本即将支持<code>TCP tracepoint</code>, 也就是说，后续通过eBPF工具，我们可以非常方便的探测<code>tcp socket</code>的变化情况，对于我们分析网络拥塞，tcp协议细节等都有较大帮助</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16666057" target="_blank" rel="external">TLS 1.3 approved</a> : TLS 1.3的规范正式确定, 链接里面主要讨论了<code>0-RTT</code>情况下潜在的攻击和风险</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://webkit.org/blog/8146/protecting-against-hsts-abuse/" target="_blank" rel="external">Protecting Against HSTS Abuse</a> : 本文介绍了<code>HSTS</code>的另外一个缺点, 除了传统的设置<code>HSTS</code>不合理，可能导致源站不能访问之外。文章指出: 每为一个域名设置一个HSTS, 其实就相当于给这个域名种下永久cookie。基于次, 我们可以通过N个不同的域名(比如a/b/c/d/e)，并且以类似于0/1组合的方式设置HSTS, 这样的话，我们就可以唯一标识一个具体的用户。基于次，在用户信息收集，广告追踪等方面，都可以发挥一定效果。<code>webkit</code>同时也给出了他们的解决方案，比如控制相同域名请求等, 感觉治标不治本。其实进一步，可以分析和感觉，网络攻击的自由和灵活性。</p>
</li>
<li><p><a href="https://dendibakh.github.io/blog/2018/03/21/port-contention" target="_blank" rel="external">Understanding CPU port contention.</a> : mark，作者是做编译器设计的，blog里面有不少文章介绍<code>performance optimizations and analysis in C/C++</code></p>
</li>
</ul>
<h3 id="琐事小记"><a href="#琐事小记" class="headerlink" title="琐事小记"></a>琐事小记</h3><ul>
<li><a href="https://stackoverflow.com/questions/19413494/does-grep-work-differently-on-osx" target="_blank" rel="external">Does grep work differently on OSX</a> : 大家知道MacOS是基于FreeBSD的，所以其内置的<code>grep</code>命令，也是不支持<code>Perl regex</code>语法，一个解决方案是用<code>homebrew</code>去安装, 会生成<code>ggrep</code>的新的支持GNU Grep规则的命令</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://codebay.cn/post/8161.html" target="_blank" rel="external">推荐10款流行的密码破解工具</a> : 关注下, 后续找地方实践</p>
</li>
<li><p><a href="http://www.ifanr.com/553590" target="_blank" rel="external">霍金用的那套语音合成软件，现在你也可以尝鲜了</a> : </p>
</li>
<li><p><a href="http://photo.weibo.com/1963193953/wbphotos/large/mid/4219964099264239/pid/7503f661gy1fpk97cer8tj21ay2an1ky" target="_blank" rel="external">信息安全书单推荐</a> : 可以重点关注<code>安全技术</code>分类下面的那些书，虽然感觉看了一半，但是缺乏实践，所得一般</p>
</li>
<li><p><a href="https://aws.amazon.com/cn/public-datasets/" target="_blank" rel="external">AWS 公用数据集</a> : 有兴趣的可以关注下, 建议可以关注<code>Amazon Bin Image Dataset</code>, <code>GDELT on AWS</code>(Global Database of Events, Language and Tone)等</p>
</li>
<li><p><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="external">Coping with the TCP TIME-WAIT state on busy Linux servers</a> : 14年的一篇老文章，今天才看到，个人感觉是对Linux <code>TIME_WAIT</code>等问题和解决方案介绍的比较系统的文章。简而言之，<code>TIME_WAIT</code>状态, 一则可以避免网络中丢失包的错误ACK，同时也能解决<code>FIN-&gt;ACK</code>时ACK丢失的问题。但是正常情况下, <code>TIME_WAIT</code>状态要保留2MSL(差不多60s), 这个对于固定的四元组(src ip, src port ,dest ip, dest port)来说, port资源会不足，从而导致性能上面会有影响。而一旦使用<code>tcp_tw_recycle</code> flag，就会存在较大的副作用, 比较建议的是<code>tcp_tw_reuse</code>, 但是其要求开启tcp timestamp flag, 在NAT网络下兼容性较差。同时也推荐下作者的blog，有不少非常靠谱的文章。</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180311" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/20180311/">weekly of 20180311</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/23/20180311/" class="article-date">
  <time datetime="2018-03-23T03:03:45.000Z" itemprop="datePublished">2018-03-23</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="http://cs.boisestate.edu/~alark/cs354/lectures/ieee754.pdf" target="_blank" rel="external">IEEE 754 Floating Point Representation</a> : 本文非常精炼的介绍了<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE 754</a>浮点数的标准规范, 对于<code>IEEE 754</code>想有进一步了解，可以参考<a href="https://coolshell.cn/articles/11235.html" target="_blank" rel="external">一个浮点数跨平台产生的问题</a>, <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="external">浮点数的二进制表示</a>, 以及推荐的可视化工具<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" target="_blank" rel="external">Floating Point Converter</a>, <a href="https://en.wikipedia.org/wiki/File:IEEE754.png" target="_blank" rel="external">File:IEEE754 精度图说明</a>, 新出的<a href="https://bellard.org/libbf/" target="_blank" rel="external">LibBF Library</a></p>
</li>
<li><p><a href="https://liudanking.com/network/tls1-3-quic-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%81%9A%E5%88%B0-0-rtt-%E7%9A%84/" target="_blank" rel="external">TLS1.3/QUIC 是怎样做到 0-RTT 的</a> ： 对于常见的协议TLS1.2/TLS1.3/QUIC/HTTP 2等初始化数据交互的所需RTT，有详细的分析和介绍, 作者blog的文章和排版都很好看，也值得关注</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404214118084135438" target="_blank" rel="external">以太坊 Vitalik Buterin：“去中文化”的含义</a> : 三把衡量“去中心化”程度的尺子，三个独立的判断标准：架构层、政治层、逻辑层。其可以保证容错性、抗攻击性、抗勾结性。对”中心化”有深刻的理解和说明</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/LVmSFtU_UEDIRS8OLgM0DQ" target="_blank" rel="external">除了虚拟货币，区块链到底能用在哪些领域和场景下？</a> : 抛砖引玉，个觉得写的内容还是有点浅，对于区块链如何真正应用，和业务结合，形成业务场景说的不够清楚, 可以参考<a href="http://tech.sina.com.cn/i/2018-01-30/doc-ifyqyuhy7705954.shtml" target="_blank" rel="external">高盛区块链79页完整报告：从理论到实践</a></p>
</li>
<li><p><a href="https://www.qubole.com/blog/advantage-decoupling/" target="_blank" rel="external">The Cloud Advantage: Decoupling Storage and Compute</a> : 传统的基于Hadoop模型，将系统的能力核心拆分为计算和存储，但是现在的计算机架构将这两个耦合在一起, 文章认为在系统设计和架构方面，都需要进一步将「计算」和『存储』能力解耦，这样能提供更大的灵活性和系统性能</p>
</li>
<li><p><a href="https://code.facebook.com/posts/286893341840510/under-the-hood-suicide-prevention-tools-powered-by-ai/" target="_blank" rel="external">Under the hood: Suicide prevention tools powered by AI</a> : Facebook的又一个AI场景应用，通过对博文内容以及相关场景的识别，判读一个人是否有自杀倾向，并给予帮助。虽然是一个很小的点，但是特别有人文关怀信息, mark</p>
</li>
</ul>
<h3 id="琐事小记"><a href="#琐事小记" class="headerlink" title="琐事小记"></a>琐事小记</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://news.ycombinator.com/item?id=16535358" target="_blank" rel="external">Convert screenshots of equations to LaTeX</a> : 将数学公司转换成<code>LaTex</code>公式；属于个人觉得非常有用的一个功能，希望某天有空自己去实现一个简单版本的;</p>
</li>
<li><p><a href="http://netsmell.com/post/how-elon-musk-learns-faster-and-better-than-everyone-else.html" target="_blank" rel="external">马斯克：如何做到常人阅读量的60倍？</a> : </p>
</li>
</ul>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/2Rk7bhRb8cPhGHbYzdtt3w" target="_blank" rel="external">读懂这台Google量子计算机，你才明白它的意义远超“量子霸权”</a> : 本文对量子计算机有深入浅出的介绍，一个关键点说明就是”学界普遍认为当量子计算机的量子比特超过 50，量子优势就实现”</p>
</li>
<li><p><a href="https://weibo.com/1560906700/G6JupkTq7?type=comment" target="_blank" rel="external">论P2P的这几年发展</a> : 关于P2P网络这几年的发展，中心化的趋势而是越来越明显, </p>
</li>
<li><p><a href="https://github.com/alevchuk/vim-clutch" target="_blank" rel="external">vim-clutch: A hardware pedal for improved text editing in Vim</a> : VIM离合器类似于汽车的脚踏板, 一旦踩下，会出发vim进入插入模式, 继续踩下则是退出编辑, 感觉这样编码起来非常像一个缝纫机</p>
</li>
<li><p><a href="https://snips-nlu.readthedocs.io" target="_blank" rel="external">Snips: Python library to extract meaning from text</a> : Snips NLU (Natural Language Understanding) is a Python library that allows to parse sentences written in natural language and extracts structured information. </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/Hjl8pRlVKkahxsWwhUXAmA" target="_blank" rel="external">开源社区，终于找到了公平的商业模式</a> : 文章的一些前后逻辑并不完全赞同, 但是几个最后关于区块链的应用说的很清楚, 可以关注，包括<code>IPFS</code>的<code>FileCoin</code>, <code>Steemit</code>, <code>Aptoide</code></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247489065&amp;idx=1&amp;sn=cd6f7f0abd7c52faf33ddabf3429480e" target="_blank" rel="external">JeffDean又用深度学习搞事情：这次要颠覆整个计算机系统结构设计</a> : 通过引入ML的技术来提升内存分支预测的准确率，进一步提升整体计算机的性能，个人可能认识有点肤浅，但是整体觉得方案有点重</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_13_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/nginx_1_13_10/">nginx 1.13.10 版本说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/23/nginx_1_13_10/" class="article-date">
  <time datetime="2018-03-23T03:02:29.000Z" itemprop="datePublished">2018-03-23</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Feature-List"><a href="#Feature-List" class="headerlink" title="Feature List"></a>Feature List</h2><blockquote>
<p>对SSI模块增强，支持set指令，允许插入任何变量</p>
</blockquote>
<ul>
<li>Feature: the “set” parameter of the “include” SSI directive now allows writing arbitrary responses to a variable; the “subrequest_output_buffer_size” directive defines maximum responsesize.</li>
</ul>
<blockquote>
<p>通过 CLOCK_MONOTONIC方式获取时间, 避免时间回转</p>
</blockquote>
<ul>
<li>Feature: now nginx uses clock_gettime( CLOCK_MONOTONIC ) if available, to avoid timeouts being incorrectly triggered on system time changes.</li>
</ul>
<blockquote>
<p>支持日志输出时不做字符转义</p>
</blockquote>
<ul>
<li>Feature: the “escape=none” parameter of the “log_format” directive.</li>
</ul>
<blockquote>
<p>支持打印<code>ALPN</code>变量情况</p>
</blockquote>
<ul>
<li>Feature: the $ssl_preread_alpn_protocols variable in the ngx_stream_ssl_preread_module.</li>
</ul>
<blockquote>
<p>引入gRpc支持</p>
</blockquote>
<ul>
<li>Feature: the ngx_http_grpc_module.</li>
</ul>
<h2 id="快速说明"><a href="#快速说明" class="headerlink" title="快速说明"></a>快速说明</h2><ul>
<li>CLOCK_MONOTONIC方式获取时间 : 正常系统提供两个类型的时间<ul>
<li>time-of-day : 俗称墙上时间，但是墙上时间会通过类似于<code>NTP</code>的协议同步时钟，这个有可能导致时间回退，</li>
<li>CLOCK_MONOTONIC时间 : 理论上对和time-of-day一致，其主要特点是, 基本同步时钟后发现自己时间过快，也不会回退，而是按照一定的算法自己缓慢增加，慢慢保持一致, 也就是能保障这个时间总是<code>单调</code>(MONOTONIC)的</li>
<li>这个问题是分布式系统经常会碰到的，可以深入了解</li>
</ul>
</li>
</ul>
<ul>
<li>“escape=none”支持:<ul>
<li>简单来说, 之前nginx默认对输入的日志变量会进行转义，转义的字符主要是<code>Nginx</code>认为不可见的那部分, 这部分代码实现很精巧，如下:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> uintptr_t</span></div><div class="line"><span class="title">ngx_http_log_escape</span><span class="params">(u_char *dst, u_char *src, <span class="keyword">size_t</span> size)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_uint_t</span>      n;</div><div class="line">    <span class="keyword">static</span> u_char   hex[] = <span class="string">"0123456789ABCDEF"</span>;</div><div class="line"></div><div class="line">    <span class="comment">//建立`escape`的bitmask数组, 一个有 32 * 8 = 256个bit</span></div><div class="line">    <span class="comment">//如果对于bit被mask为1，表明需要转义</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">uint32_t</span>   escape[] = &#123;</div><div class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></div><div class="line"></div><div class="line">                    <span class="comment">/* ?&gt;=&lt; ;:98 7654 3210  /.-, +*)( '&amp;%$ #"!  */</span></div><div class="line">        <span class="number">0x00000004</span>, <span class="comment">/* 0000 0000 0000 0000  0000 0000 0000 0100 */</span></div><div class="line"></div><div class="line">                    <span class="comment">/* _^]\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */</span></div><div class="line">        <span class="number">0x10000000</span>, <span class="comment">/* 0001 0000 0000 0000  0000 0000 0000 0000 */</span></div><div class="line"></div><div class="line">                    <span class="comment">/*  ~&#125;| &#123;zyx wvut srqp  onml kjih gfed cba` */</span></div><div class="line">        <span class="number">0x80000000</span>, <span class="comment">/* 1000 0000 0000 0000  0000 0000 0000 0000 */</span></div><div class="line"></div><div class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></div><div class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></div><div class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></div><div class="line">        <span class="number">0xffffffff</span>, <span class="comment">/* 1111 1111 1111 1111  1111 1111 1111 1111 */</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (size) &#123;</div><div class="line">        <span class="comment">// 判断其mask位是否为1</span></div><div class="line">        <span class="comment">// *src &gt;&gt; 5 为去其高3位，用于获取数组的便宜量</span></div><div class="line">        <span class="comment">// 1U &lt;&lt; (*src &amp; 0x0f) 为获取具体在数据bit mask的位置</span></div><div class="line">        <span class="keyword">if</span> (escape[*src &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1U</span> &lt;&lt; (*src &amp; <span class="number">0x1f</span>))) &#123;</div><div class="line">            *dst++ = <span class="string">'\\'</span>;</div><div class="line">            *dst++ = <span class="string">'x'</span>;</div><div class="line">            *dst++ = hex[*src &gt;&gt; <span class="number">4</span>];</div><div class="line">            *dst++ = hex[*src &amp; <span class="number">0xf</span>];</div><div class="line">            src++;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            *dst++ = *src++;</div><div class="line">        &#125;</div><div class="line">        size--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>) dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ssl_preread_alpn_protocols变量 :<ul>
<li>这里面大家可以关注<code>ALPN</code>协议，他和<code>NPN</code>都是用于在TLS交互的时候进行协议的协商, 可以关注之前的文章<a href="https://imququ.com/post/enable-alpn-asap.html" target="_blank" rel="external">为什么我们应该尽快支持 ALPN？</a><br>，大概区别如下: <ul>
<li>NPN 是服务端发送所支持的 HTTP 协议列表，由客户端选择；而 ALPN 是客户端发送所支持的 HTTP 协议列表，由服务端选择；</li>
<li>NPN 的协商结果是在 Change Cipher Spec 之后加密发送给服务端；而 ALPN 的协商结果是通过 Server Hello 明文发给客户端；</li>
</ul>
</li>
<li>可以总结为ALPN是趋势，也是未来的标准，但是短期内各方厂商的支持情况并不理想</li>
</ul>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180304" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/20180304/">weekly of 20180304</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/06/20180304/" class="article-date">
  <time datetime="2018-03-06T04:28:45.000Z" itemprop="datePublished">2018-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://developers.googleblog.com/2018/02/announcing-flutter-beta-1.html" target="_blank" rel="external">Announcing Flutter beta 1: Build beautiful native apps</a> :  Flutter is Google’s new mobile UI framework that helps developers craft high-quality native interfaces for both iOS and Android, 其采用<code>Dart</code>语言, 有兴趣的可以去进一步了解</p>
</li>
<li><p><a href="https://github.com/pornin/CTTK" target="_blank" rel="external">CTTK: Constant-Time Toolkit</a> : A collection of constant-time implementations of primitive operations that may help in writing constant-time code, including non-cryptographic constant-time code</p>
</li>
<li><p><a href="https://blog.cloudflare.com/memcrashed-major-amplification-attacks-from-port-11211/" target="_blank" rel="external">Memcrashed - Major amplification attacks from UDP port 11211</a> : 基于Memcached的放大攻击, 是本周Github DDOS攻击的主要恶意流量</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://textslashplain.com/2018/02/14/understanding-the-limitations-of-https/" target="_blank" rel="external">Understanding the Limitations of HTTPS</a> : HTTPS协议不是银弹，本文系统化的介绍HTTPS协议的一些弊端，包括<code>Privacy Limitations</code>, <code>Real-world Implementation Limitations</code>等，可以加深对整个https协议和网络栈的理解</p>
</li>
<li><p><a href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/#h.dqlu6589o789" target="_blank" rel="external">A Practical Introduction to Container Terminology</a> : 关于容器化技术的概述性介绍，值得收藏</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank" rel="external">HTTP/2 服务器推送（Server Push）教程</a> : 一个入门的HTTP2推送介绍, 可以手动试验下</p>
</li>
<li><p><a href="http://www.techug.com/post/zero-knowledge-and-blockchains.html" target="_blank" rel="external">白话区块链加密货币中的零知识证明（Zero-Knowledge Proof）</a> : 零知识证明的介绍, 。零知识证明的本质就是在不揭晓我所知道或拥有的某样东西的前提下，向别人证明我有很大几率（这点很重要，零知识证明说到底是一个概率上的证明）确实知道或拥有这个东西。其已经应用在ZCASH等区块链场景下, 可以进一步了解的文章包括<a href="https://www.leiphone.com/news/201712/ACn6T08O3cyhu8DN.html" target="_blank" rel="external">详解零知识证明的四大基础技术，如何与以太坊发生反应</a>, <a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AF%81%E6%98%8E%E7%B3%BB%E7%BB%9F" target="_blank" rel="external">交互式证明系统</a></p>
</li>
</ul>
<h3 id="琐事小记"><a href="#琐事小记" class="headerlink" title="琐事小记"></a>琐事小记</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://azure.microsoft.com/en-us/services/cosmos-db/?v=17.45b" target="_blank" rel="external">Azure Cosmos DB</a> : A database for extremely low latency and massively scalable applications anywhere in the world, with native support for NoSQL; 微软新出的之前多种Nosql接口的全球数据库</p>
</li>
<li><p><a href="https://github.com/yujiosaka/headless-chrome-crawler" target="_blank" rel="external">headless-chrome-crawler</a> : Distributed crawler powered by Headless Chrome</p>
</li>
<li><p><a href="https://blog.riseml.com/benchmarking-googles-new-tpuv2-121c03b71384" target="_blank" rel="external">Benchmarking Google’s new TPUv2</a> : TPUs compare very well, both, performance-wise and economically, to the latest generations of GPUs.</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16473482" target="_blank" rel="external">101 NumPy Exercises for Data Analysis (Python)</a> : 可以针对性的提高你对<code>Numpy</code>这个库的掌握程度, 其他可以推荐的包括<a href="https://github.com/ajcr/100-pandas-puzzles" target="_blank" rel="external">pandas</a></p>
</li>
</ul>
<ul>
<li>mark下个人感觉不错的关于区块链的文章/资料(现在是信息过剩) :<ul>
<li><a href="https://36kr.com/p/5075268.html" target="_blank" rel="external">比特币从“不了解”到“被误解”——详解区块链技术</a> : 很好的一个入门介绍, 可以先阅读这篇文章</li>
<li><a href="http://ibloodline.com/articles/2018/01/22/mechanics.html" target="_blank" rel="external">Bloodline’s Blog</a> : 比较深入/细节的介绍比特币/区块链的相关技术实现</li>
<li><a href="https://www.jianshu.com/p/8ea9a9a21f1f" target="_blank" rel="external">谈谈自己对比特币脚本的理解</a> : 侧重介绍比特币的脚本机制和实现</li>
<li><a href="https://yeasy.gitbooks.io/blockchain_guide/content/" target="_blank" rel="external">区块链技术指南</a> : 内容不是很对自己胃口，但是对于一些基本概念有比较详细介绍</li>
<li><a href="http://www.aquagemini.com/bitcoin-difficulty-adjust/" target="_blank" rel="external">深入理解比特币系列（25）: 难度系数及调整周期</a> : 对于一些针对性的问题进行讨论</li>
<li><a href="https://www.coursera.org/learn/cryptocurrency" target="_blank" rel="external">课程: Bitcoin and Cryptocurrency Technologies</a></li>
<li><a href="https://github.com/chaozh/awesome-blockchain" target="_blank" rel="external">awesome-blockchain</a> : 收集所有区块链(BlockChain)技术开发相关资料，包括Fabric和Ethereum开发资料</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="https://www.miaopai.com/show/ZqUFOkk1NeWXcgL12vzhIrkX~uh72G4E77S8pw__.htm" target="_blank" rel="external">The clearest explanation of Paxos I’ve seen so far</a> : 先收藏mark, 周末review一遍</p>
</li>
<li><p><a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="external">Google: 机器学习速成课程</a> : Google 制作的节奏紧凑、内容实用的机器学习简介课程</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>