<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-20180826" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/09/20180826/">weekly of 20180826</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/09/09/20180826/" class="article-date">
  <time datetime="2018-09-09T10:58:45.000Z" itemprop="datePublished">2018-09-09</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://highperfdesign.com/post/async_io_intro/" target="_blank" rel="external">Introduction to Asynchronous I/O - High Performance computing</a> : 关于异步 IO 的介绍，这个是入门篇，后续希望有更深入的分析和介绍，先 mark</p>
</li>
<li><p><a href="https://lowleveldesign.org/2018/08/15/randomness-in-net/" target="_blank" rel="external">Randomness in .NET – lowleveldesign.org</a> : 分析<code>.NET</code>环境下面伪随机数的安全性，其实只要知道内部状态，就可以快速知道后续的序列了, 另外一篇可以重点学习的文章是<a href="http://lcamtuf.coredump.cx/oldtcp/tcpseq.html" target="_blank" rel="external">Strange Attractors and TCP/IP Sequence Number Analysis</a>, 讨论”inserting a malicious packet into a TCP connection”可行性</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://hacks.mozilla.org/2018/08/dweb-building-a-resilient-web-with-webtorrent/" target="_blank" rel="external">Dweb: Building a Resilient Web with WebTorrent – Mozilla Hacks – the Web developer blog</a> : 之前讨论过<code>webTorrent</code>的情况，最近通过了解磁力链接等，对于其内部实现和机制有了进一步的了解, Maybe 是下一代互联网的趋势, 可以参考其<a href="https://webtorrent.io/faq" target="_blank" rel="external">官网</a>举例的一些应用场景，包括对等文件传输, <a href="https://peercloud.io/" target="_blank" rel="external">PeerCloud</a>“Serverless websites via WebTorrent”</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404277899594202694" target="_blank" rel="external">卫夕 | 机器知道你会点广告：写给普通人的CTR预估科普</a> : 很好的的 CTR 入门介绍，值得了解</p>
</li>
<li><p><a href="https://github.com/TellinaTool/nl2bash" target="_blank" rel="external">TellinaTool/nl2bash: Generating bash command from natural language</a> :  </p>
</li>
<li><p><a href="http://www.styluslabs.com/" target="_blank" rel="external">Stylus Labs: Writer</a> : “writer is a word processor for handwriting”, 一个面向于手写场景的编辑器, 交互和功能支持方式很有针对性，可以参考下，不知道对中文输入场景的支持如何~</p>
</li>
<li><p><a href="https://nostarch.com/seriouscrypto" target="_blank" rel="external">Serious Cryptography | No Starch Press</a> : 一本介绍密码学相关的数据，看目录还不错，先 mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ok4oCRNQ9lrgtyTrk-d6gA" target="_blank" rel="external">MacTalk: 推荐几款 Mac 上的效率利器</a> : 推荐了几个<a href="http://macshuo.com/?p=625" target="_blank" rel="external">Alfred</a>, <a href="https://www.alfredapp.com" target="_blank" rel="external">Paste</a>, <code>Magnet</code>, <a href="https://mubu.com" target="_blank" rel="external">幕布</a>等工具, 个人感觉用起来一般~</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_15_3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/nginx_1_15_3/">nginx 1.15.3 版本说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/30/nginx_1_15_3/" class="article-date">
  <time datetime="2018-08-30T04:15:29.000Z" itemprop="datePublished">2018-08-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x00-Feature-List"><a href="#0x00-Feature-List" class="headerlink" title="0x00 Feature List"></a>0x00 Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: now TLSv1.3 can be used with BoringSSL.</p>
</li>
<li><p>Feature: the “ssl_early_data” directive, currently available with BoringSSL.</p>
</li>
<li><p>Feature: the “keepalive_timeout” and “keepalive_requests” directives in the “upstream” block.</p>
</li>
</ul>
<p>前两者关于<code>BoringSSL</code>和 TLS 相关的优化，后者是 keepalive 特性的优化，下面分别介绍。</p>
<h2 id="0x01-UPSTREAM-KEEPALIVE"><a href="#0x01-UPSTREAM-KEEPALIVE" class="headerlink" title="0x01 UPSTREAM KEEPALIVE"></a>0x01 UPSTREAM KEEPALIVE</h2><p>关于Nginx Upstream 长连接池的机制可以参看之前的<a href="http://shevacjs.com/2016/01/19/tcp_keepalive_proxy/">让nginx支持TCP长连接代理</a>这篇文章，这次主要现在如下两个指令, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:   keepalive_timeout timeout;</div><div class="line">* Default:  keepalive_timeout 60s;</div><div class="line">* Context:  upstream</div><div class="line">&gt; This directive appeared in version 1.15.3.</div><div class="line"></div><div class="line">Sets a timeout during which an idle keepalive connection to an upstream server will stay open</div></pre></td></tr></table></figure>
<p>以及如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:    keepalive_requests number;</div><div class="line">* Default:   keepalive_requests 100;</div><div class="line">* Context:    upstream</div><div class="line">&gt; This directive appeared in version 1.15.3.</div><div class="line"></div><div class="line">After the maximum number of requests is made, the connection is closed.</div></pre></td></tr></table></figure>
<p>可以看到其主要作用是，当一个请求空闲<code>一段时间</code>(keepalive_timeout)或者处理过<code>足够多</code>(keepalive_requests)的请求, 则会关闭连接，以便重启;</p>
<p>其核心理念是希望长链接的请求能够回收重启, 原因是长连接容易造成一些边缘 case 和异常，比如<a href="https://trac.nginx.org/nginx/ticket/1170" target="_blank" rel="external">implement keepalive timeout for upstream</a> 和 <a href="https://trac.nginx.org/nginx/ticket/1484" target="_blank" rel="external">Timeouts when proxying to Apache and using Keepalive</a>, 提到的proxy server和 proxy 的竞争发送问题, Proxy server<code>time_wait</code>过多等问题; 代码修复实现相对比较简单，不再赘述。</p>
<h2 id="0x02-BoringSSL与-TLS"><a href="#0x02-BoringSSL与-TLS" class="headerlink" title="0x02 BoringSSL与 TLS"></a>0x02 BoringSSL与 TLS</h2><p>我们知道 OpenSSL是应用最为广泛的TLS协议的实现, 由于 TLS 的重要性以及 OpenSSL 实现的复杂性，其安全问题一直都存在着; 所以，业内也有提出其他的 OpenSSL 的实现方式，比如基于OpenSSL修改衍生的<a href="https://en.wikipedia.org/wiki/BoringSSL" target="_blank" rel="external">BoringSSL</a> 和 <a href="https://en.wikipedia.org/wiki/LibreSSL" target="_blank" rel="external">LibreSSL</a>, 这一类实现和 OpenSSL 基本保持接口的兼容，也就意味着宿主程序可以以较低的成本进行迁移; 还有一类是独立实现的，比如说<a href="https://bearssl.org/index.html#overview" target="_blank" rel="external">BearSSL</a> (建议可以深入了解)之类，其有自己特意的针对性目标和场景，其接口和<code>openssl</code>也不一致, 迁移成本较大。所以, Nginx从<code>1.7.4</code>开始, 开始兼容<code>BoringSSL and LibreSSL</code>, 其兼容成本也不算特别高。</p>
<p>具体编译的方法可以参考<a href="www.lidaren.com/archives/1702">Nginx替换OpenSSL为LibreSSL</a> 和 <a href="https://sometimesnaive.org/article/64" target="_blank" rel="external">Nginx 启用 BoringSSL</a>, 其核心是Nginx 编译脚本依赖的两类文件(考虑类Unix环境), 包括: </p>
<ul>
<li><code>$OPENSSL/.openssl/include/openssl/ssl.h</code>(参考auto/lib/openssl/make文件) : 头文件的依赖</li>
<li><code>$CORE_LIBS $OPENSSL/.openssl/lib/libssl.a</code>和<code>$CORE_LIBS $OPENSSL/.openssl/lib/libcrypto.a</code>(参考参考auto/lib/openssl/conf文件) : 链接库的依赖</li>
</ul>
<p>由于编译的脚本是死的，所以在准备<code>LibreSSL</code>或者<code>BoringSSL</code>的时候，保证上面两者的兼容性就可以了</p>
<p>再简单分析<code>LibreSSL/BoringSSL</code>和 OpenSSL 的一些差异点, 整体不同的TLS library的对比可以参考<a href="https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations" target="_blank" rel="external">Wiki:Comparison of TLS implementations</a>, 上面有比较详细的对比</p>
<h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><ul>
<li><p><a href="https://icmconference.org/wp-content/uploads/G12c-Bechis.pdf" target="_blank" rel="external">LibreSSL</a> : 比较系统的介绍<code>LibreSSL</code>项目初衷，目标以及如何实现(主要在代码实现方面有所取舍)的, 可以快速了解</p>
</li>
<li><p><a href="https://bearssl.org/" target="_blank" rel="external">BearSSL: Overview</a> : <code>BearSSL</code>也是一个TLS的实现, 里面保护很多比较最新的特性，比如说<code>时间无关</code>的支持, 是学习TLS的一个很好入门</p>
</li>
<li><p><a href="https://blog.cloudflare.com/make-ssl-boring-again/" target="_blank" rel="external">Make SSL boring again</a> : CloudFlare的<code>BoringSSL</code>的迁移实践和总结, 包括其优势，比如说较早的TLS1.3的支持, <code>X25519</code>的支持等, 其不足之处, 比如说<code>Slow Base64</code>(因为保证constant-time的), <code>missing OCSP</code>等，可以看出和了解BoringSSL和Openssl 的异同点</p>
</li>
<li><p><a href="https://elib.uni-stuttgart.de/bitstream/11682/9311/1/thesis.pdf" target="_blank" rel="external">Analysing and improving the crypto ecosystem of Rust</a> : 我们知道OpenSSL 现在主要的核心问题实现方面的漏洞, 其和C/C++语言的内存模型有一些关系, Rust的语言设计能很大的规避这方面的问题，这篇长 paper(一百多页) 就是介绍了如果通过Rust 构建一个更健壮的密码系统</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180812" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/22/20180812/">weekly of 20180812</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/22/20180812/" class="article-date">
  <time datetime="2018-08-22T13:19:45.000Z" itemprop="datePublished">2018-08-22</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="http://www.linuxeden.com/a/34651" target="_blank" rel="external">传输层安全协议 TLS 1.3 RFC 8446 正式发布</a> : 一个 RFC 文档整整有160页~</p>
</li>
<li><p><a href="https://www.oschina.net/news/98827/github-open-sourced-glb-director" target="_blank" rel="external">重磅！GitHub 开源负载均衡组件 GLB Director</a> : Github开放的三层的负载均衡器</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651008578&amp;idx=3&amp;sn=05043b800d49bd3f4206911493a92dff" target="_blank" rel="external">后台服务出现“明显变慢”，该如何诊断？</a> :  相比而已比较干货的内容，可以通过其介绍的方式来 Review 自己对工具链以及方法论的完善度进行评估</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/796slUjYygDWh_V4-8Vstg" target="_blank" rel="external">IBM新创AI病毒：想打谁就打谁，看脸发作绝不误伤，隐蔽性极强</a> : AI赋能业务，无论攻防都面临新的机遇和挑战~</p>
</li>
<li><p><a href="https://github.com/google/xi-editor/blob/e8065a3993b80af0aadbca0e50602125d60e4e38/doc/crdt-details.md" target="_blank" rel="external">The Xi Text Engine CRDT</a> : “This document contains a detailed description of the data structures and operations Xi uses for text”</p>
</li>
<li><p><a href="https://medium.com/netflix-techblog/pseudo-localization-netflix-12fff76fbcbe" target="_blank" rel="external">Pseudo Localization @ Netflix – Netflix TechBlog – Medium</a> : 全球化一直是Netflix前进发展面临的挑战, 如何提升全球化部署的效率是一个巨大的调整；文章重点介绍了Netflix 如何解决本地化 UI 的问题, 通过配置”伪本地化”的方式，生成特定规则的假数据，以便预先和快速的发展问题, 可以参考另外一篇文章<a href="https://medium.com/netflix-techblog/localization-technologies-at-netflix-d033e7b13cf" target="_blank" rel="external">Localization Technologies at Netflix</a></p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://cacm.acm.org/magazines/2018/8/229771-traceability/fulltext" target="_blank" rel="external">Web Traceability</a> : 本文是前ACM 主席对于互联网”可追踪性”的一个讨论和想法。互联网的兴起大大改变了我们的生活方式，但是其虚拟，匿名，加密等特性也是一把双刃剑，一方面使得用户的隐私得到有些保障, 另一个方面也引发的网络犯罪等行为; 作者的思路是: 首先，可追踪性还是要支持的，不过需要引入一些附加的流程和手段，比如说我们路上可以随便看到车牌，但是真正能查到车票对应的人只有执法部门；其次，对于技术上面的实现，其设计的点和面比较多，需要跟进前者的机制再针对性的建设~</p>
</li>
<li><p><a href="https://www.instructables.com/id/Literary-Clock-Made-From-E-reader/" target="_blank" rel="external">Literary Clock Made From E-reader: 6 Steps (with Pictures)</a> : 文章介绍了如何对<code>Kindle</code>进行破解，把其改成一个时钟, 先 mark，有空研究下 kindle 的破解手段</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247492096&amp;idx=1&amp;sn=511646facbdac81165176a5e9fa11784" target="_blank" rel="external">都去炒AI和大数据了，落地的事儿谁来做？</a> : 真正的系统架构师，既要往上高瞻远瞩，更要考虑落地以及业务的困难点; 其实现在 AI 的概念和场景『感觉』上面可以解决很多问题，但是真正落地的时候其坑和问题肯定不会少，AI 工程的标准化和流程感觉需要持续探索和摸索~</p>
</li>
<li><p><a href="https://google.github.io/filament/Filament.md.html#toc1.1" target="_blank" rel="external">Filament</a> : “Physically-based rendering engine”, 先 mark，有空深入分析下~</p>
</li>
<li><p><a href="https://github.com/GetPublii/Publii" target="_blank" rel="external">GetPublii/Publii</a> :  “Publii is a desktop-based CMS for Windows and Mac that makes creating static websites fast and hassle-free, even for beginners”, 好像是不过不错的 CMS 工具，先 mark，maybe 会用到</p>
</li>
<li><p><a href="https://github.com/niieani/bash-oo-framework" target="_blank" rel="external">bash-oo-framework</a> : “Bash Infinity is a modern boilerplate/framework/standard library for bash “, 一个基于 bash 的 lib 库, 但个人感觉方案有点重，最好有些轻量级的方案就好了~</p>
</li>
<li><p><a href="https://visca.com/regexdict/" target="_blank" rel="external">Regex Dictionary by Lou Hevly</a> : “The Regex Dictionary is a searchable online dictionary, based on The American Heritage Dictionary of the English Language, 4th edition, that returns matches based on strings”</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-introduction_of_the_noise_protocol_framework" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/introduction_of_the_noise_protocol_framework/">Noise Protocol简介</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/20/introduction_of_the_noise_protocol_framework/" class="article-date">
  <time datetime="2018-08-20T12:20:45.000Z" itemprop="datePublished">2018-08-20</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在研究 VPN 相关的技术，会做个简单的总结，稍微系统地去介绍安全协议及其系统</p>
</blockquote>
<h2 id="0x00-何为Noise-Protocol"><a href="#0x00-何为Noise-Protocol" class="headerlink" title="0x00 何为Noise Protocol"></a>0x00 何为Noise Protocol</h2><p>从<a href="http://noiseprotocol.org/index.html" target="_blank" rel="external">官网</a>的概述，其定义为:</p>
<blockquote>
<p>Noise is a framework for building crypto protocols. Noise protocols support mutual and optional authentication, identity hiding, forward secrecy, zero round-trip encryption, and other advanced features.</p>
</blockquote>
<p>太过含糊，仅仅强调其功能特性; 不过从作者在<a href="https://fahrplan.events.ccc.de/congress/2017/Fahrplan/events/9222.html" target="_blank" rel="external">Schedule 34th Chaos Communication Congress</a>的介绍，更具象一些，说明如下:</p>
<blockquote>
<p>Noise is a framework that helps in creating secure channel protocols</p>
</blockquote>
<p>所谓的<code>secure channel</code>，就是安全通道，比如<code>TLS</code>, <code>IPsec</code>, <code>SSH</code>都是; 也就是<code>noise protocol</code>就是用于快速方便去构建安全信道的一个框架。</p>
<h2 id="0x01-WHY"><a href="#0x01-WHY" class="headerlink" title="0x01 WHY"></a>0x01 WHY</h2><p>一个自然而然的问题是，为什么需要这样的框架? 我个人的理解包括:</p>
<ul>
<li><p>从安全的角度来看，虽然我们拥有很多基础的密码原语支持，比如公钥体系，签名体系，对称加密，HASH 等, 但是在业务落地的时候这些东西如何组合也是个问题和风险点。如果组织不合理，非常有可能造成进一步的安全漏洞。基于此，形式化和清晰化的去描述和定义一个”安全协议”, 可以从更系统的层面去分析其安全问题，更全面的评估其可靠性，也避免了一些『自定义』方式带来的安全漏洞。 这个方面其实有点像我们开放我们的『加密算法』，可以让第三方去审计/评估，但是不影响加密算法的可用性。<code>noise protocol</code>同样也是，其明确定义了不同模式的交互方式和协议，我们可以更清晰的审计其健壮性</p>
</li>
<li><p>从应用角度而言, two-parties的安全信道构建一直是有强烈诉求的, 但是不同的业务场景对于安全的要求也不尽相同，比如是否需要验证身份等, 所以去构建一个『框架』，让用户可以根据自己的业务场景方便构建自己安全信道的构建方式，是能满足更广大用户</p>
</li>
</ul>
<h2 id="0x02-Noise-的抽象和规范"><a href="#0x02-Noise-的抽象和规范" class="headerlink" title="0x02 Noise 的抽象和规范"></a>0x02 Noise 的抽象和规范</h2><p>介绍完了 Noise 的简单背景之后，我们来分析 Noise 是如何去解决这个问题的。</p>
<h3 id="2-1-抽象"><a href="#2-1-抽象" class="headerlink" title="2.1 抽象"></a>2.1 抽象</h3><blockquote>
<p>如下分析来自[1]的 PPT</p>
</blockquote>
<p>一个安全信道的构建，可以划分为如下几个阶段 :</p>
<ol>
<li><p>握手(Handshake)阶段，这阶段主要用于协议的协商和AKE(Authenticated Key Exchange) 相关事宜的完成，即包括:</p>
<ul>
<li>Negotiation : 协议协商等</li>
<li>AKE : 身份验证&amp;密钥交换</li>
</ul>
</li>
<li><p>数据传输(Transport phase)阶段，根据握手阶段生成的对称密钥，加密传输相关数据</p>
</li>
</ol>
<p>如下图所示 :</p>
<p><img src="/images/secure_channel.jpeg" alt="Secure Channel"></p>
<p>但是从实践应用的角度，为了保障安全性(比如考虑前置安全性), 我们会根据情况，重新协商密钥(AKE),  所以整个交互过程，会变成如下模式:</p>
<blockquote>
<p> [01] <em> Negotiation  + N </em> (AKE + n * transport )</p>
</blockquote>
<p>意味着:</p>
<ol>
<li>一般就需要一次协商阶段/或者不需要</li>
<li>会有多次(AKE + trans)阶段，来保障传输的安全性</li>
</ol>
<p>而<code>Noise protocol</code>就是更关注后者的实现, 如下:</p>
<p><img src="/images/secure_channel_noise.jpeg" alt="secure_channel_of_noise"></p>
<p>如此一来，一个包含<code>Noise Protocol</code>的应用，其安全信道的组织方式大概如下:</p>
<p><img src="/images/noise_framework_overview.jpeg" alt="noise_framework_overview"></p>
<p>这个也是<a href="https://www.wireguard.com/" target="_blank" rel="external">Wireguard</a>的组织方式，后续的文章会再详细介绍</p>
<h3 id="2-2-规范"><a href="#2-2-规范" class="headerlink" title="2.2 规范"></a>2.2 规范</h3><p>有了上面的抽象之后，在具体实现上面, Noise 也做了相关的规范和约定；主要包括两个方面，其一是<code>模式</code>的约定，这里面主要说明了根据不同的业务场景(比如是否需要身份验证等)，如何进行握手协议; 其二是<code>密码算法</code>的约定，主要约定了交互时候具体选择的密码协议等</p>
<h4 id="2-2-1-模式约定"><a href="#2-2-1-模式约定" class="headerlink" title="2.2.1 模式约定"></a>2.2.1 模式约定</h4><blockquote>
<p>重点关注基础(fundamental),交互式(Interactive)的沟通模式</p>
</blockquote>
<p>在一个交互式的场景下，比如Alice和Bob，我们假设他们需要完成握手协议，以便后续的数据传输。一个问题是，Alice 和 Bob 有多少种握手沟通方式? 这里, 我们其用两个字母表示，分别表示发送者(Alice)和 Bob(响应者)对于对方<code>static key</code>的诉求情况 :</p>
<p>对于Alice(请求初始化者)有如下四个情况 :</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>spec说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N</strong></td>
<td>No static key for initiator</td>
<td>无需发送者的静态key(对发送者不进行身份验证)</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>Static key for initiator Known to responder</td>
<td>已知(通过其他旁路方式)发送者的静态key, 可以进行身份验证</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Static key for initiator Xmitted (“transmitted”) to responder</td>
<td>通过握手传输交互发送者的静态key</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>Static key for initiator Immediately transmitted to responder, despite reduced or absent identity hiding</td>
<td>通过握手传输，且离开发送静态 key, 这可能使其身份更容易暴露</td>
</tr>
</tbody>
</table>
<p>对于Bob(请求响应者)有如下三个情况:</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>spec说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N</strong></td>
<td>No static key for responder</td>
<td>无需响应者的静态key</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>Static key for responder Known to initiator</td>
<td>已知响应者的静态key</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Static key for responder Xmitted (“transmitted”) to initiator</td>
<td>通过握手传输交互静态key</td>
</tr>
</tbody>
</table>
<p>基于如上的自由组合，一共会有12种不同的模式; 再加上如下的规则 :</p>
<blockquote>
<p>The fundamental handshake patterns perform DH operations for authentication (“es” and “se”) as early as possible</p>
</blockquote>
<p>给定任意<code>XY</code>, 原则上面，我们都能推导其交互过程，比如<code>XX</code>，其具体如下:</p>
<table>
<thead>
<tr>
<th>A status</th>
<th></th>
<th>B status</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>s(x),e(x),rs(x),re(x)</td>
<td></td>
<td>s(x),e(x),rs(x),re(x)</td>
<td>初始状态</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td>–&gt; e</td>
<td>s(x),e(x),rs(x),re(x)</td>
<td>生成e, 发送</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td></td>
<td>s(y),e(y),rs(x),re(y)</td>
<td>B 知道e,s,re，起可以发送的 DH 有ee, es</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td>&lt;–e,ee,s,es</td>
<td>s(y),e(y),rs(x),re(y)</td>
</tr>
<tr>
<td>s(y),e(y),rs(y),re(y)</td>
<td></td>
<td>s(y),e(y),rs(x),re(y)</td>
<td>发送 A.s, 其可以DH 有se,ss</td>
</tr>
<tr>
<td>s(y),e(y),rs(y),re(y)</td>
<td>–&gt; s,se</td>
<td>s(y),e(y),rs(y),re(y) </td>
</tr>
</tbody>
</table>
<h4 id="2-2-2-基础算法约定"><a href="#2-2-2-基础算法约定" class="headerlink" title="2.2.2 基础算法约定"></a>2.2.2 基础算法约定</h4><p>我们知道，密码学虽然定义了其有限的基本的『能力原语』，但是实现上面却各不相同，纷繁杂乱；一个 hash 方法，就有大几十种选择，不同的实现可能存在着或多或少的安全风险。为此，Noise框架直接规范了其依赖的函数的具体算法，对于这些规范内的函数，其安全性和可控性是经过严格审计的，具体如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>可选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>密钥交互</td>
<td>DH25519</td>
<td>DHLEN = 32</td>
</tr>
<tr>
<td>密钥交互</td>
<td>DH448</td>
<td>DHLEN = 56</td>
</tr>
<tr>
<td>加密函数</td>
<td>ChaChaPoly</td>
<td>16 byte authentication data</td>
</tr>
<tr>
<td>加密函数</td>
<td>AESGCM</td>
<td>16 byte authentication data</td>
</tr>
<tr>
<td>哈希函数</td>
<td>SHA256</td>
<td>HASHLEN = 32, BLOCKLEN = 64 </td>
</tr>
<tr>
<td>哈希函数</td>
<td>SHA512</td>
<td>HASHLEN = 64, BLOCKLEN = 128</td>
</tr>
<tr>
<td>哈希函数</td>
<td>BLAKE2s</td>
<td>HASHLEN = 32, BLOCKLEN = 64</td>
</tr>
<tr>
<td>哈希函数</td>
<td>BLAKE2b</td>
<td>HASHLEN = 64, BLOCKLEN = 128</td>
</tr>
</tbody>
</table>
<p>如上，我们就可以约定<code>Noise Protocol Name</code>, 也可以通过其名字可以知道其协议过程，比如从<code>Noise_NX_25519_AESGCM_SHA256</code>, 可以得到:</p>
<ul>
<li>NX = Pattern name</li>
<li>25519 = DH name</li>
<li>AESGCM = Cipher name</li>
<li>SHA256 = Hash name</li>
</ul>
<p>同时根据具体选择的算法，我们还可以估算一个Noise Protocol 交互时候其数据包的大小, 比如<code>Noise_XX_25519_ChaChaPoly_SHA256</code>模式，其不同的数据包大小如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">XX:</div><div class="line">  -&gt; e                  <span class="comment">## 1</span></div><div class="line">  &lt;- e, ee, s, es       <span class="comment">## 2</span></div><div class="line">  -&gt; s, se              <span class="comment">## 3</span></div><div class="line"></div><div class="line"><span class="comment"># 说明:</span></div><div class="line"><span class="comment">## 1. DH_25519的公钥为32字节,明文, 总长度为32</span></div><div class="line"><span class="comment">## 2. e为32字节, s为48字节(AEAD模式会增加16字节)，payload(为空)加密后再增加16字节, 一共96字节</span></div><div class="line"><span class="comment">## 3. s加密后为48字节，加上payload为空的加密串,一共64字节</span></div></pre></td></tr></table></figure>
<h2 id="0x03-Noise-Protocol-实践分析"><a href="#0x03-Noise-Protocol-实践分析" class="headerlink" title="0x03 Noise Protocol 实践分析"></a>0x03 Noise Protocol 实践分析</h2><p>为了助于我们对noise protocol加密协议有进一步的理解,对于给定的一个<code>Noise Protocol Name</code>, 我们要分析其包体格式, 比如上面的<code>Noise_XX_25519_ChaChaPoly_SHA256</code>, 其交互流程如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">XX:</div><div class="line">  -&gt; e</div><div class="line">  &lt;- e, ee, s, es</div><div class="line">  -&gt; s, se</div></pre></td></tr></table></figure>
<p>那么在每个阶段，其具体发送的内容是什么呢？</p>
<p>其实在实现的时候, 发送方都维护了一个类似于状态机的内容，而<code>e</code>,<code>s</code>,<code>ee</code>之类的，则类似于<code>action</code>, 用于更新相关状态的内容；所以包的格式其实可以理解为就是对于<code>action</code>的一系列响应的结果；下面具体说明下:</p>
<h4 id="首先是基础函数方面-有如下几个能力"><a href="#首先是基础函数方面-有如下几个能力" class="headerlink" title="首先是基础函数方面, 有如下几个能力 :"></a>首先是基础函数方面, 有如下几个能力 :</h4><ul>
<li>$DH(ee|es|se|ss)$ : 用于计算一个共享密钥, 例子用到的是<code>DH25519</code></li>
<li>$hash(data)$ : 用于计算一个哈希值, 我们这边用的是<code>SHA256</code></li>
<li>$encrypt(k,h,data)$ : AEAD 模式的加密函数</li>
<li>$HKDF(ck,data)$ : KDF 函数，用于生成新的key chain</li>
</ul>
<h4 id="其次是状态机方面，对于-Alice-Bob，其本地都维护了如下的信息"><a href="#其次是状态机方面，对于-Alice-Bob，其本地都维护了如下的信息" class="headerlink" title="其次是状态机方面，对于 Alice/Bob，其本地都维护了如下的信息:"></a>其次是状态机方面，对于 Alice/Bob，其本地都维护了如下的信息:</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s,e</td>
<td>本地的临时/静态 DH组合对</td>
</tr>
<tr>
<td>rs,re</td>
<td>对方的临时/静态的 DH 组合对</td>
</tr>
<tr>
<td>h</td>
<td>当前的 hash 值，初始为空</td>
</tr>
<tr>
<td>ck</td>
<td>chain key, 初始为空，用于通过 KDF 生成新key</td>
</tr>
<tr>
<td>k, n</td>
<td>加密k, 加密时候会通过(k,n,hash) 和 AEAD 模式进行对称加密</td>
</tr>
<tr>
<td>msg</td>
<td>当前要发送的消息内容</td>
</tr>
<tr>
<td>payload</td>
<td>当前要携带的额外数据</td>
</tr>
</tbody>
</table>
<h4 id="最后是-action-方面-对于不同的-action，其定义如下"><a href="#最后是-action-方面-对于不同的-action，其定义如下" class="headerlink" title="最后是 action 方面, 对于不同的 action，其定义如下:"></a>最后是 action 方面, 对于不同的 action，其定义如下:</h4><ul>
<li><p>action e :</p>
<ul>
<li>$msg += e$</li>
<li>$h = hash(h||e)$</li>
</ul>
</li>
<li><p>action s :</p>
<ul>
<li>$s = k.empty() ? s : encrypt(s,k,h)$</li>
<li>$msg+=s$</li>
<li>$h = hash(h||s)$</li>
</ul>
</li>
<li><p>action ee/es/ss/se :</p>
<ul>
<li>$v = DH(ee|es|se|ss)$</li>
<li>$ck,k = HKDF(ck,v)$</li>
<li>$n = 0$</li>
</ul>
</li>
<li><p>action token end(全部处理完 token) :</p>
<ul>
<li>$payload = encrypt(payload,k,h) (if k!=0 )$</li>
</ul>
</li>
</ul>
<p>最后发送<code>msg+payload</code></p>
<p>有了如上的说明，我们再详细看看<code>Noise_XX_25519_ChaChaPoly_SHA256</code>的交互情况 :</p>
<ol>
<li><code>--&gt;e</code> : 按照上面的分析, 会发送明文的<code>e</code>, 同时由于其不生成k, 因为也不会额外计算payload, 其发送包体只有<code>32字节</code></li>
</ol>
<ol>
<li><code>&lt;--e,ee,s,es</code> : 其有4个 token，拆分分析, 如下表格:</li>
</ol>
<table>
<thead>
<tr>
<th>action</th>
<th>msg</th>
<th>h</th>
<th>k</th>
<th>ck</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>e</td>
<td>h1=hash(e)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>ee</td>
<td>e</td>
<td>h1</td>
<td>k1</td>
<td>ck1,k1 = HKDF(ck,ee)</td>
</tr>
<tr>
<td>s</td>
<td>e,enc(s)</td>
<td>h2=hash(h1+enc(s))</td>
<td>k1</td>
<td>ck1</td>
</tr>
<tr>
<td>es</td>
<td>e,enc(s)</td>
<td>h2</td>
<td>k2</td>
<td>ck2,k2=HKDF(ck1,es)</td>
</tr>
<tr>
<td>end</td>
<td>e,enc(s),enc(null)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>具体格式如下:</p>
<p><img src="/images/noise_xx_demo.jpeg" alt="noise_xx_demo"></p>
<p>最后一个命令同理，不再赘述；</p>
<p>基于上面的分析，详细大家可以直接计算<code>msg</code>的包体大小，也就是上一节里面展示的; </p>
<p>如下是<code>Wireshark</code>抓包的示意图:</p>
<p><img src="/images/noise_wireshark_demo.png" alt="noise_wireshark_demo"></p>
<p>具体实现代码方面，可以参考<a href="https://github.com/plizonczyk/noiseprotocol" target="_blank" rel="external">noiseprotocol:Noise Protocol Framework - Python 3 implementation
</a></p>
<p>可以参看其<code>README</code>里面关于server/client的编写，实现一个快速简单的原型;</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p>[1] <a href="https://fahrplan.events.ccc.de/congress/2017/Fahrplan/events/9222.html" target="_blank" rel="external">Lecture: The Noise Protocol Framework</a> @ Schedule 34th Chaos Communication Congress</p>
</li>
<li><p>[2] <a href="http://noiseprotocol.org/noise.html" target="_blank" rel="external">The Noise Protocol Framework</a> : White Paper</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography-noise-vpn/">cryptography, noise, vpn</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180805" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/06/20180805/">weekly of 20180805</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/08/06/20180805/" class="article-date">
  <time datetime="2018-08-06T09:19:45.000Z" itemprop="datePublished">2018-08-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/P_np_np-complete_np-hard.svg.png" alt="wiki:p_np_npc_problem"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/" target="_blank" rel="external">Detecting the use of “curl | bash” server side</a> :  直接执行<code>curl | bash</code>的命令是存在比较大的安全风险的，因为可能执行一些未经确认的恶意代码;  那有没有办法可以去构造这种攻击吗？也就是对于普通的浏览器访问或者命令行下面直接的 curl 输出，我们返回正常的内容，但是如果是执行了<code>curl | bash</code>我们就返回还有恶意代码的内容呢？作者的回答是肯定的，其主要的思路是在返回内部的时候，初步先通过 chunk 机制返回带有<code>sleep 5</code>之类的能够检测时间/bash 的监测代码，在通过在服务端对于响应时间进行判断，就能知道我们输出的内容是否运行在 bash 环境下面（会不会感觉其实和检测一个代码是否跑在一个 JS 环境下面一样？）；当然实现上面还有不少细节，比如说对于发送/接受/pipe 的 buffer 等控制和填充~</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/" target="_blank" rel="external">Modern SAT solvers: fast, neat and underused (part 1 of N) — The Coding Nest</a> : 本文的<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" target="_blank" rel="external">SAT</a>是指<code>Boolean satisfiability problem</code>, 其实也就是个<code>NP完全问题</code>(NP-complete)。虽然是NP 问题，但是也有不少的 Lib 库存在，用于去解决这方面的问题，比如说文章提到的<a href="http://minisat.se/" target="_blank" rel="external">Minisat</a>,<a href="http://dimacs.rutgers.edu/" target="_blank" rel="external">DIMACS</a>等; 从计算复杂性的理论，我们知道<code>NPC</code> 的问题是可以相互规约的，利用这个规则和现有的 Lib，我们可以认为，对于现实中存在的真正的 NP 问题，只要建立好正确对应的数学模型，将其规约到一个 NPC 问题，就能用这些基础库解决此类问题了。本文作者举了一个具体<code>数独问题</code>的例子，并演绎如何将其规约到基础的 NPC 问题，最终求解这类问题。对于，我们可以对计算复杂性的理论有进一步的了解和认识，也可以将其应用到其他的问题解决领域。先 mark 下，周末手动测试这些代码。如下的几个相关的参考资料，有助于了解整体文章:</p>
<ul>
<li><a href="http://www.matrix67.com/blog/archives/105" target="_blank" rel="external">什么是P问题、NP问题和NPC问题</a> </li>
<li><a href="http://zhishifenzi.blog.caixin.com/archives/167252" target="_blank" rel="external">最新证明面临质疑：P/NP问题为什么这么难？</a></li>
<li><a href="https://en.wikipedia.org/wiki/NP_(complexity" target="_blank" rel="external">Wikipedia: NP (complexity)</a>)</li>
</ul>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/b80Efqsh85vqaWvuB8lUcg" target="_blank" rel="external">Kafka 2.0重磅发布，新特性独家解读</a> : Kafka顺应了现在这个时代对于数据的规模化和流式化处理的需求，本身是发展也是非常迅猛；Maybe 可以其作为自己第二个侧重投入的重点工具链</p>
</li>
<li><p><a href="https://blog.cloudflare.com/how-we-scaled-nginx-and-saved-the-world-54-years-every-day/" target="_blank" rel="external">How we scaled nginx and saved the world 54 years every day</a> : 本文介绍了CloudFlare在 Nginx 部署和运维上面的一些先进经验，不少都是 Nginx 的性能深入优化点，比如<code>SO_REUSEPORT</code>, <code>read thread pool</code>, 算是真正有在规模化应用这些特性的大团队，经验等值得参考和采纳</p>
</li>
<li><p><a href="http://dockone.io/article/8106" target="_blank" rel="external">小米DevOps团队针对容器的Nginx优化</a> : 主要谈到容器化的时候，通过<code>worker_processes auto</code>的指令，并不能很好的控制 nginx 的进程数，基于此，可以通过旁路的脚本或者程序的升级来支持读取争取分配给他的CPU 线程数。其实，个人感觉，CPU 的限制是软限制，通过控制进程数并不合理，但是其深入分析问题的思路和精神值得佩服~ </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周主要关注P2P下载相关的技术</p>
</blockquote>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5" target="_blank" rel="external">磁力链接: 维基百科</a> :  对于磁力链接的概括性介绍, 本质上其是对一个种子文件的<code>URN</code></p>
</li>
<li><p><a href="http://blog.kakarott.net/archives/10017" target="_blank" rel="external">P2P技术科普（一）——-P2P基本原理</a> : 对 P2P 网络的发展以及技术演变有概括性，精要的说明，可以关注了解</p>
</li>
<li><p><a href="http://www.aneasystone.com/archives/2015/05/how-does-magnet-link-work.html" target="_blank" rel="external">磁力链接是如何实现下载的</a> : 具体介绍磁力链接的执行机制, 推荐<a href="http://magnet2torrent.com/" target="_blank" rel="external">Magnet &gt;&gt; Torrent</a>, 其可以帮忙我们将磁力链接转成 torrent 文件</p>
</li>
<li><p><a href="http://www.bittorrent.org/beps/bep_0005.html" target="_blank" rel="external">BitTorrent: DHT</a> : 介绍BitTorrent的 DHT 网络的设计思路和理念，可以加上对 P2P 网络的理解</p>
</li>
<li><p><a href="https://my.oschina.net/kanlianhui/blog/167491" target="_blank" rel="external">P2P中DHT网络原理</a> : 另外一个科普文章，可以了解</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://www.intel.cn/content/www/cn/zh/events/restoring-great-wall/preserve-great-wall-techarticle.html" target="_blank" rel="external">英特尔修复长城计划 (技术角度)</a> : 有点半软文性质的文章，主要想说明的一点是，AI 赋能的确在影响我们很多时刻解决问题的思路和理念，而这些方面又依赖于每个人的视野和判断力。</p>
</li>
<li><p><a href="https://github.com/arnoldrobbins/mcilroy-regex" target="_blank" rel="external">arnoldrobbins/mcilroy-regex: Doug McIlroy’s C++ regular expression matching library</a> : 一个 C++的正则库，先 mark，历史好像很是悠久</p>
</li>
<li><p><a href="https://www.quickcode.co/engineer-blogs" target="_blank" rel="external">Engineering Blogs</a> : “A Collection of engineering blogs from top tech companies in the world”</p>
</li>
<li><p><a href="https://ricardodsanchez.com/2018/08/03/favorite-visual-studio-code-extensions-of-2018/2018/" target="_blank" rel="external">Favorite Visual Studio Code Extensions of 2018 | Ricardo D Sanchez | Page 2018</a> : 不少插件可以关注，包括<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="external">REST Client</a>, <a href="https://marketplace.visualstudio.com/items?itemName=sdras.night-owl" target="_blank" rel="external">Night Owl</a> 等</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180722" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/30/20180722/">weekly of 20180722</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/30/20180722/" class="article-date">
  <time datetime="2018-07-30T03:40:45.000Z" itemprop="datePublished">2018-07-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488140&amp;idx=1&amp;sn=a4397201d781386f854242d0ff5d2be8" target="_blank" rel="external">Facebook使用机器学习手段来自动优化其系统性能</a> : 没有完全理解文章的内容，现在的理解是，通过声明式的方式描述程序的逻辑，同时基于此，通过输入日志和反馈，调整程序的策略，进而优化整体的性能; 总感觉有点理想化~</li>
</ul>
<ul>
<li><p><a href="https://www.oschina.net/news/98255/facebook-open-source-oomd" target="_blank" rel="external">Facebook 开源 oomd，一种处理内存溢出的新方法</a> : <code>OOMD</code>也是一个<code>OOM</code>的处理工具，但是和传统的<code>OOM</code>工具不一样，其更会侧重优化和清理用户空间的内存，这样会保障整个内核和系统的相对稳健</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNzU3NzQ0MA==&amp;mid=2652089442&amp;idx=1&amp;sn=69bae21c50c779b8c0b995bd0c654e57&amp;chksm=809b066db7ec8f7b275b8a6f1ef792aace8a920c6c87dfe30fa401add813caa84929e4f420e0#rd" target="_blank" rel="external">大话计算机: 趣味了解浮点数</a> :  关于计算机浮点数机制的介绍，这本书的内容看目录还是非常不多的，先收藏mark</p>
</li>
<li><p><a href="https://emerentius.github.io/sudoku_web/" target="_blank" rel="external">Rust Sudoku Solver</a> : 作者用rust编写了一个Sudoku的解法器, 对于sudo的解决算法还是可以深入研究分析的, 先mark下，可以参考<a href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms" target="_blank" rel="external">Sudoku solving algorithms</a>, <a href="https://attractivechaos.wordpress.com/2011/06/19/an-incomplete-review-of-sudoku-solver-implementations/" target="_blank" rel="external">An Incomplete Review of Sudoku Solver Implementations</a></p>
</li>
<li><p><a href="http://tonsky.me/blog/dsl/" target="_blank" rel="external">Designing good DSL @ tonsky.me</a> : 设计新的<code>DSL</code>是我们解决一些复杂问题或者场景的一个有效方法，作者提出了真正要设计<code>DSL</code>的时候需要的一些注意点，包括<code>Make it verbose(不用用正则的奇怪的不容易理解的语法)</code>, <code>Don’t invent second syntax</code>等，不少意见值得采纳深思</p>
</li>
<li><p><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端图片格式调研 | Garan no dou</a> : 对于图片格式，以及其编解码速度的问题有一个非常系统的分析和对比，感觉可以关注的图片格式包括<code>APNG</code>,<code>BPG</code>, 但是直观上面感觉这两年发展不算快(2015年的文章)</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="http://www.techug.com/post/meitun-deep-learning.html" target="_blank" rel="external">美团是如何基于深度学习实现图像的智能审核</a> : 两个值得关注的，一个是其审核的流程, 为”负例图片-&gt;正例图片-&gt;人审”, 这样可以保障业务迭代或者新增图片类型时，系统的健壮性；其次是其对于<code>水印检测</code>, <code>明星脸识别</code>, <code>色情图片检测</code>的策略优化，这个方面也有不少可借鉴的地方</p>
</li>
<li><p><a href="https://code.fb.com/data-infrastructure/xars-a-more-efficient-open-source-system-for-self-contained-executables/" target="_blank" rel="external">XARs: An efficient system for self-contained executables – Facebook Code</a> : </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://zkp.science/" target="_blank" rel="external">What is a zero-knowledge proof? | Zero-Knowledge Proofs</a> : Mark, 关于<code>零和知识</code>的集中资料，先mark，找个周末再完整消化下</p>
</li>
<li><p><a href="https://github.com/hq6/GdbShellPipe" target="_blank" rel="external">GdbShellPipe: Enable piping of internal command output to external commands</a> : 一个 GDB的扩展，允许在 GDB 里面执行 shell 的命令, 比如说<code>shell-pipe disas | grep mov</code>可以检索出<code>disas</code>里面含有<code>mov</code>命令的语句</p>
</li>
<li><p><a href="https://stenci.la/" target="_blank" rel="external">Stencila</a>: “An open source office suite for reproducible research”, mark</p>
</li>
<li><p><a href="https://www.univocity.com/pages/html_parser_tutorial" target="_blank" rel="external">HTML parser : uniVocity data integration</a> : 一个开源的Java HTML解析器, 具有声明式语法, 自动内容下载的特性, mark关注了解下</p>
</li>
<li><p><a href="http://www.darkside.com.au/snow/" target="_blank" rel="external">The SNOW Home Page</a> : <code>SNOW</code>是一个通过增加在一些行末尾添加空格内容，以支持信息隐藏的一个手段, 甚至可以通过引入加密算法进行加密，使得即便此规则被泄露，依旧能进行信息隐藏和保护，其最后还有一个在线的<a href="http://fog.misty.com/perry/ccs/snow/snow/snow.html" target="_blank" rel="external">WEB DEMO</a>, 有兴趣可以试用下</p>
</li>
<li><p><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/" target="_blank" rel="external">An Illustrated Proof of the CAP Theorem</a> : 关于<code>CAP</code>原理的一个比较好的可视化演示和证明，可以关注下</p>
</li>
<li><p><a href="https://john-millikin.com/software/anansi" target="_blank" rel="external">Anansi: a NoWeb-inspired literate programming preprocessor</a> : Anansi是所谓的<code>文学编程</code>模式的预处理起，所谓<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B" target="_blank" rel="external">文学编程</a>是相比于传统结构化编程的模式, 其可以让程序员在描述/书写文档的过程中完成对应的编码和文档说明(个人感觉这个模式效率其实是蛮低的)</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488196&amp;idx=1&amp;sn=c5b243b9dc7bd7b3d44aab83aba820a7" target="_blank" rel="external">作为面试官，我是怎么快速判断程序员能力的？</a> : 对于如何做一个成功的面试的一些建议，还是非常接地气的；从我个人角度来看，『面试』这个事情，其实还是在于面试官对待面试的态度和准备，只有充分准备才能起到真正面试和完成合理判断</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180708" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/30/20180708/">weekly of 20180708</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/30/20180708/" class="article-date">
  <time datetime="2018-07-30T03:35:45.000Z" itemprop="datePublished">2018-07-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://arvid.io/2018/05/05/pdbs-on-linux/" target="_blank" rel="external">PDBs on Linux</a> : PDB是windows下面的符号文件，其可以和bin文件拆分，某些时候会便于调试；默认情况下, linux的ELF的文件其调试信息的耦合在bin里面的，作者给出了自己的办法，具体为(可以收藏):</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ objcopy --only-keep-debug a.out a.out.pdb <span class="comment"># extract symbols</span></div><div class="line">$ strip a.out <span class="comment"># strip away any debug information</span></div><div class="line">$ objcopy --add-gnu-debuglink=a.out.pdb a.out <span class="comment"># attach the symbols to the executable</span></div></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://arvid.io/2018/06/30/on-cxx-random-number-generator-quality/" target="_blank" rel="external">On C++ Random Number Generator Quality</a> : 文章评估了C++lib下面随机数生成器的质量, 总结而已就是使用<a href="https://arvid.io/2018/06/30/on-cxx-random-number-generator-quality/" target="_blank" rel="external">PractRand</a>的方法评估, 可以持续关注; 另外推进作者的几篇不错的blog，包括<a href="https://arvid.io/2018/05/27/intel-microarchitectures-instruction-sets/" target="_blank" rel="external">Intel &amp; AMD Micro-Architecture Extended Instruction Sets</a>, <a href="https://arvid.io/2018/07/02/better-cxx-prng/" target="_blank" rel="external">Better C++ Pseudo Random Number Generator</a></p>
</li>
<li><p><a href="https://nullprogram.com/blog/2018/06/23/" target="_blank" rel="external">Intercepting and Emulating Linux System Calls with Ptrace « null program</a> : 深入ptrace的应用，其可以作为一个仿真器, 比如调用自定义的system call, 或者我们可以让其调用我们预定义的ABI</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491177&amp;idx=1&amp;sn=756699190c00c5bc11113819bb57dec3" target="_blank" rel="external">谨防5个陷阱！数据科学家新手快速上道秘诀</a> : 最近<code>AI前线</code>给了不少实践落地的一些建议，这篇文章也是，有不少干货可以学习，具体包括:<ul>
<li>练习数据管理技能</li>
<li>研究不同模型的优缺点</li>
<li>尽可能简化模型</li>
<li>检查你结论中的因果关系和相关性</li>
<li>优化最有用的参数</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488099&amp;idx=1&amp;sn=4b7ab3e5fd87d036e1deab2b1c0c9ecf" target="_blank" rel="external">Istio以及Service Mesh的未来</a> : 文章介绍<code>Istio</code>的简单机制，包括几个核心的组件:<code>Envoy</code>, <code>Pilot</code>,<code>Mixer</code>等，以及总结出来的其带来<code>灵活性</code>, <code>安全性</code>, <code>可观测性</code>等优点</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s/473mATiM1xnLUFKMD2FnnQ" target="_blank" rel="external">区块链的信任从何而来？</a> :  总而言之，就是用技术的手段，构建了一个大家认为『无法轻易作伪』的分布式存储系统，基于次可以构建更多的应用和业务</p>
</li>
<li><p><a href="https://www.theverge.com/2018/7/9/17549668/app-wikipedia-location-facts" target="_blank" rel="external">This app reads Wikipedia to teach you about the cities you’re driving through</a> : 作者开发了一个App，其可以通过地理位置信息，自动抓取Wikipedia上面的文章，推荐给用户(感觉是一个不错的产品玩法)</p>
</li>
<li><p><a href="https://github.com/rhysd/vim.wasm" target="_blank" rel="external">rhysd/vim.wasm: Vim editor ported to WebAssembly</a> : 将vim迁移到浏览器, 由于vim本身有不少UI交互上面的操作，因此直接编译源码到WASM并不可行，作者在blog里面也介绍了其思路, 通过disable适当的功能和构建合适的运行环境，值得学习</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491444&amp;idx=1&amp;sn=47aa445f49de52316beaec40a776dbc7" target="_blank" rel="external">Hadoop老矣，为什么腾讯还要花精力在其开源发布上</a> : 可以理解为是对现在大数据生态现状的概述</p>
</li>
<li><p><a href="https://blog.acolyer.org/2018/07/05/enclavedb-a-secure-database-using-sgx/" target="_blank" rel="external">EnclaveDB: a secure database using SGX | the morning paper</a> : </p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_15_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/nginx_1_15_2/">nginx 1.15.2 版本说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/26/nginx_1_15_2/" class="article-date">
  <time datetime="2018-07-26T08:15:29.000Z" itemprop="datePublished">2018-07-26</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0x00-Feature-List"><a href="#0x00-Feature-List" class="headerlink" title="0x00 Feature List"></a>0x00 Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: the $ssl_preread_protocol variable in the ngx_stream_ssl_preread_module.</p>
</li>
<li><p>Feature: now when using the “reset_timedout_connection” directive nginx will reset connections being closed with the 444 code.</p>
</li>
</ul>
<p>这里我们重点关注第二个特性(第一个特性，后续我们专门写篇介绍Nginx和SSL应用的文章再具体分析)</p>
<h2 id="0x01-Reset-Timeoutd-Connection"><a href="#0x01-Reset-Timeoutd-Connection" class="headerlink" title="0x01 Reset Timeoutd Connection"></a>0x01 Reset Timeoutd Connection</h2><p>第二个机制可以直译说明如下:</p>
<blockquote>
<p>如果开启<code>reset_timedout_connection</code>配置后，Ngnix接收<code>HTTP 444</code>状态码后，会重置对应的连接</p>
</blockquote>
<p>可以简单拆解为如下三个问题讨论:</p>
<ul>
<li>HTTP 444状态码的作用和目的</li>
<li>指令<code>reset_timedout_connection</code>的机制和作用</li>
<li>整体这个feature的作用</li>
</ul>
<h3 id="1-1-HTTP-444状态码"><a href="#1-1-HTTP-444状态码" class="headerlink" title="1.1 HTTP 444状态码"></a>1.1 HTTP 444状态码</h3><p>其实<code>444</code>是Nginx内部的状态码,从<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return" target="_blank" rel="external">nginx return</a>的指令，看到说明如下:</p>
<blockquote>
<p>…The non-standard code 444 closes a connection without sending a response header …</p>
</blockquote>
<p>同时<a href="https://httpstatuses.com/444" target="_blank" rel="external">Http Status</a>网站也有详细说明, 如下: </p>
<blockquote>
<p>A non-standard status code used to instruct nginx to close the connection without sending a response to the client, most commonly used to deny malicious or malformed requests.</p>
</blockquote>
<p>这样就比较明确, HTTP 444是Nginx内部的状态码, 其主要是作用是告诉 nginx可以直接关闭对应的链接，无需发送响应头部。这可以有效处理恶意或者畸形的流量。</p>
<h3 id="1-2-reset-timedout-connection指令"><a href="#1-2-reset-timedout-connection指令" class="headerlink" title="1.2 reset_timedout_connection指令"></a>1.2 reset_timedout_connection指令</h3><p>该指令是由<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#reset_timedout_connection" target="_blank" rel="external">ngx_http_core_module</a>提供的，如下是官方的说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* Syntax:   reset_timedout_connection on | off;</div><div class="line">* Default:	reset_timedout_connection off;</div><div class="line">* Context:	http, server, location</div><div class="line"></div><div class="line">Enables or disables resetting timed out connections. The reset is performed as follows. Before closing a socket, the SO_LINGER option is set on it with a timeout value of 0. When the socket is closed, TCP RST is sent to the client, and all memory occupied by this socket is released. This helps avoid keeping an already closed socket with filled buffers in a FIN_WAIT1 state for a long time.</div></pre></td></tr></table></figure>
<p>简而言之, 当开启<code>reset_timedout_connection</code>后，Nginx 会通过设置<code>SO_LINGER</code>的选项快速关闭超时的连接, 其作用是保障系统和 Nginx 能够快速释放无用的连接的资源。 具体实现上面，就是通过控制<code>SO_LINGER</code>选项。</p>
<p>关于<a href="https://notes.shichao.io/unp/ch7/#so_linger-socket-option" target="_blank" rel="external">SO_LINGER</a>其作用，可以简述为是控制<code>close</code>的行为, 参考<a href="http://blog.51cto.com/xwandrew/2046615" target="_blank" rel="external">Linux Socket SO_LINGER选项
</a>(个人感觉解释的比较清晰明了)的说明，可以简述如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SO_LINGER选项有如下结构：</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></div><div class="line">     <span class="keyword">int</span> l_onoff; <span class="comment">/* 0 = off, nozero = on */</span></div><div class="line">     <span class="keyword">int</span> l_linger; <span class="comment">/* linger time */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当设置 l_onoff为1，l_linger为0，则连接立即终止，TCP将丢弃残留在发送缓冲区中的数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；在远端的recv()调用将以WSAECONNRESET出错。</p>
<p>这个也是Nginx的默认行为如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: ngx_http_request.c, 快速关闭请求</span></div><div class="line"><span class="keyword">if</span> (clcf-&gt;reset_timedout_connection) &#123;</div><div class="line">    linger.l_onoff = <span class="number">1</span>;</div><div class="line">    linger.l_linger = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setsockopt(r-&gt;connection-&gt;fd, SOL_SOCKET, SO_LINGER,</div><div class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *) &amp;linger, <span class="keyword">sizeof</span>(struct linger)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ngx_log_error(NGX_LOG_ALERT, <span class="built_in">log</span>, ngx_socket_errno,</div><div class="line">                        <span class="string">"setsockopt(SO_LINGER) failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-3-整体-Feature-作用"><a href="#1-3-整体-Feature-作用" class="headerlink" title="1.3 整体 Feature 作用"></a>1.3 整体 Feature 作用</h3><p>如上，整体的作用其实就是让 Nginx <a href="http://mailman.nginx.org/pipermail/nginx-devel/2018-July/011271.html" target="_blank" rel="external">能够快速释放相关的资源</a>, 如下是前后的流程对比</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//before</span></div><div class="line">A  +---------&gt;  B +--------&gt;  C</div><div class="line"></div><div class="line">                  <span class="number">1.</span> <span class="keyword">return</span> <span class="number">444</span></div><div class="line">                &lt;-----------+</div><div class="line"></div><div class="line">     <span class="number">2.</span>normal close</div><div class="line">   &lt;------------+</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//now</span></div><div class="line">A  +---------&gt;  B +--------&gt;  C</div><div class="line"></div><div class="line"></div><div class="line">  <span class="number">2.</span> reset socket  <span class="number">1.</span> <span class="keyword">return</span> <span class="number">444</span></div><div class="line"> &lt;-----------+  &lt;-----------+</div></pre></td></tr></table></figure>
<h2 id="0x02-Nginx-模块的执行顺序"><a href="#0x02-Nginx-模块的执行顺序" class="headerlink" title="0x02 Nginx 模块的执行顺序"></a>0x02 Nginx 模块的执行顺序</h2><p>算是这次的补充说明, 是好久之前追查的一个问题，才发现之前对 Nginx 模块的执行顺序一直理解有误，这边记录说明下。</p>
<p>我们知道nginx的一个状态机驱动的模型, 那么在同一个阶段（状态）下面, 模块的执行顺序如何呢? 具体结论如下:</p>
<p>在非 filter 模块情况下, <code>在configure的时候, 越晚添加的模块就会越先执行(挂载在同一阶段的模块哈)</code>, 几个注意点如下:</p>
<ol>
<li><p>上面描述的是在<code>configure</code>阶段越晚添加的越先执行, 指的是 Nginx 默认的configure，由于一些产品线的nginx 都会包一层自己的编译处理逻辑，这个时候就需要关注其是如何新增模块的(也就是新增模块和真正 configure)的关系</p>
</li>
<li><p>Nginx扩展的自己<code>config</code>也会影响或者控制模块的执行顺序，默认的config如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP_AUX_FILTER_MODULES=<span class="string">"<span class="variable">$HTTP_AUX_FILTER_MODULES</span> ngx_http_baidu_problem_tracing_module"</span></div></pre></td></tr></table></figure>
<p>但是如果改写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP_AUX_FILTER_MODULES=&quot;ngx_http_baidu_problem_tracing_module $HTTP_AUX_FILTER_MODULES &quot;</div></pre></td></tr></table></figure>
<p>原因具体下面说明;</p>
<p>现在我们来看一个模块/扩展是如何接入 Nginx 的状态机的;</p>
<p>1. configure阶段, 这个过程，Nginx 的脚本通过我们的编译控制，收集相关的信息，最终会生成一个 Shell 变量，这个变量包含了我们要编译进去的所有模块名称，如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="variable">$HTTP</span> = YES ]; <span class="keyword">then</span></div><div class="line">    modules=<span class="string">"<span class="variable">$modules</span> <span class="variable">$HTTP_MODULES</span> <span class="variable">$HTTP_FILTER_MODULES</span> \</span></div><div class="line">             <span class="variable">$HTTP_HEADERS_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_AUX_FILTER_MODULES</span> \</div><div class="line">             <span class="variable">$HTTP_COPY_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_RANGE_BODY_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_NOT_MODIFIED_FILTER_MODULE</span>"</div><div class="line"></div><div class="line">    NGX_ADDON_DEPS=<span class="string">"<span class="variable">$NGX_ADDON_DEPS</span> \$(HTTP_DEPS)"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>这个里面需要说明的一点是module是直接引用了<code>$HTTP_AUX_FILTER_MODULES</code>之类的变量，而这些变量是每个扩展的<code>config</code>文件自己控制的，也就是说你把变量名字写在前后，直接影响你在<code>modules</code>里面的顺序</p>
<ol>
<li>代码生成阶段，通过如上的环境变量, Nginx会生成类似于如下的文件, </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_module_t</span> *ngx_modules[] = &#123;</div><div class="line">    &amp;ngx_core_module,</div><div class="line">    &amp;ngx_errlog_module,</div><div class="line">    &amp;ngx_conf_module,</div><div class="line">    &amp;ngx_events_module,</div><div class="line">    &amp;ngx_event_core_module,</div><div class="line">    &amp;ngx_epoll_module,</div><div class="line">    &amp;ngx_openssl_module,</div><div class="line">    &amp;ngx_regex_module,</div><div class="line">    &amp;ngx_http_module,</div><div class="line">    &amp;ngx_http_core_module,</div><div class="line">    &amp;ngx_http_log_module,</div><div class="line">    &amp;ngx_http_upstream_module,</div><div class="line">    &amp;ngx_http_static_module,</div><div class="line">    &amp;ngx_http_autoindex_module,</div><div class="line">    &amp;ngx_http_index_module,</div><div class="line">    <span class="comment">/* 这里说明 access 是 auth basic 在 access 阶段先执行的 */</span></div><div class="line">    &amp;ngx_http_auth_basic_module,</div><div class="line">    &amp;ngx_http_access_module,</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>启动初始化阶段, 其在<code>http/ngx_http.c</code>会有大概如下的伪代码:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file: http/ngx_http.c</span></div><div class="line">        n += cmcf-&gt;phases[i].handlers.nelts;</div><div class="line"></div><div class="line"><span class="comment">// 从后面开始，追加到对于ph里面; 也就是越早在ngx modules里面被引用的，在会放在ph的越前面</span></div><div class="line">        <span class="keyword">for</span> (j = cmcf-&gt;phases[i].handlers.nelts - <span class="number">1</span>; j &gt;=<span class="number">0</span>; j--) &#123;</div><div class="line">            ph-&gt;checker = checker;</div><div class="line">            ph-&gt;handler = h[j];</div><div class="line">            ph-&gt;next = n;</div><div class="line">            ph++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>执行阶段如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_http_core_run_phases</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_int_t</span>                   rc;</div><div class="line">    <span class="keyword">ngx_http_phase_handler_t</span>   *ph;</div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    ph = cmcf-&gt;phase_engine.handlers;</div><div class="line"></div><div class="line">    <span class="comment">// 顺序执行</span></div><div class="line">    <span class="keyword">while</span> (ph[r-&gt;phase_handler].checker) &#123;</div><div class="line"></div><div class="line">        rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rc == NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，可以明确: </p>
<blockquote>
<p>在非filter 模块情况下, 在configure的时候, 越晚添加的模块就会越先执行(挂载在同一阶段的模块哈)</p>
</blockquote>
<h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><ul>
<li><p><a href="https://forum.nginx.org/read.php?2,246978,246999" target="_blank" rel="external">Re: How to control the order of execution modules in nginx</a></p>
</li>
<li><p><a href="http://blog.aka-cool.net/blog/2014/03/06/nginx-module-execute-order-in-same-phrase/" target="_blank" rel="external">挂载在同一阶段的Nginx模块的执行顺序 - Aka.Why</a> : 重点参考该作者的分析</p>
</li>
<li><p><a href="https://item.jd.com/29369702559.html" target="_blank" rel="external">深入理解Nginx：模块开发与架构解析-第2版</a> : 里面有重点介绍 nginx的<code>configure</code>的执行过程</p>
</li>
<li><p><a href="https://www.kancloud.cn/kancloud/master-nginx-develop/51904" target="_blank" rel="external">模块编译顺序 · Nginx开发从入门到精通 · 看云</a> : 大部分内容都是 OK 的,但是关于<code>HTTP MODULE</code>的论述有些问题，可以选择性了解下</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_15_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/17/nginx_1_15_1/">nginx 1.15.1 版本说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/17/nginx_1_15_1/" class="article-date">
  <time datetime="2018-07-17T08:50:29.000Z" itemprop="datePublished">2018-07-17</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Feature-List"><a href="#Feature-List" class="headerlink" title="Feature List"></a>Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: the “random” directive inside the “upstream” block.</p>
</li>
<li><p>Feature: improved performance when using the “hash” and “ip_hash” directives with the “zone” directive.</p>
</li>
</ul>
<p>一个是引入了<code>random</code>的upstream机制，还有一个是优化了<code>zone</code>区的<code>hash</code>性能; 下面我们详细拆解其功能</p>
<h2 id="Upstream-Zone机制"><a href="#Upstream-Zone机制" class="headerlink" title="Upstream Zone机制"></a>Upstream Zone机制</h2><p>Nginx在<code>1.9.0</code>版本引入了<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#zone" target="_blank" rel="external">zone</a>的机制, 官方手册说明如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:    zone name [size];</div><div class="line">* Default:    —</div><div class="line">* Context:    upstream</div><div class="line">&gt; This directive appeared in version 1.9.0.</div><div class="line"></div><div class="line">Defines the name and size of the shared memory zone that keeps the group’s configuration and run-time state that are shared between worker processes.</div></pre></td></tr></table></figure>
<p>也就是其核心能力是使得upstream的相关配置以及状态，支持在进程间共享。这方面的优势显而易见，依照<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#zone" target="_blank" rel="external">NGINX Load Balancing - HTTP Load Balancer
</a>说明，我们可以总结为:</p>
<ul>
<li><p>其可以方便的支持健康检查,动态upstream配置等，而无需担心多进程数据同步的问题</p>
</li>
<li><p>状态数据，比如<code>max_fail</code>等信息，可以被多个进程共享，这样是的业务避免无效的请求和重试, 否则每个进程都得去触发<code>max_fail</code>之类的阈值</p>
</li>
</ul>
<p>关于upstream zone另外一个可以关注的点是其<code>实现机制</code>。直观来看的话，从单进程到多进程共享的数据结构，可能对源码会有较大的改动，尤其是有不少现存的upstream module,  不过nginx引入了一个相对巧妙的机制, 可以通过<code>ngx_http_upstream_zone_module.c</code>了解，其核心思路是: </p>
<ol>
<li>将进程内的数据拷贝到共享内存里面</li>
<li>将所有的指针指向共享内存空间</li>
</ol>
<p>这样<code>几乎</code>(主要有时候还需要解决多进程并发读写的问题)可以透明的将数据迁移到共享内存里面; 大致代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_upstream_init_zone</span><span class="params">(<span class="keyword">ngx_shm_zone_t</span> *shm_zone, <span class="keyword">void</span> *data)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span>                          len;</div><div class="line">    <span class="keyword">ngx_uint_t</span>                      i;</div><div class="line">    <span class="keyword">ngx_slab_pool_t</span>                *shpool;</div><div class="line">    <span class="keyword">ngx_http_upstream_srv_conf_t</span>   *uscf, **uscfp;</div><div class="line">    <span class="keyword">ngx_http_upstream_main_conf_t</span>  *umcf;</div><div class="line"></div><div class="line">    <span class="comment">/* 省去部分代码，指向共享内存区域 */</span></div><div class="line">    shpool = (<span class="keyword">ngx_slab_pool_t</span> *) shm_zone-&gt;shm.addr;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* copy peers to shared memory */</span></div><div class="line"></div><div class="line">    umcf = shm_zone-&gt;data;</div><div class="line">    uscfp = umcf-&gt;upstreams.elts;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; umcf-&gt;upstreams.nelts; i++) &#123;</div><div class="line">        uscf = uscfp[i];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (uscf-&gt;shm_zone != shm_zone) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 讲每个upstream conf 拷贝到共享内存区域 */</span></div><div class="line">        <span class="keyword">if</span> (ngx_http_upstream_zone_copy_peers(shpool, uscf) != NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以回到这次的feature, 对所谓的『ip_hash/hash』的性能优化，其实就是对zone里面读写锁的精细化控制。</p>
<h2 id="Random-Upstream"><a href="#Random-Upstream" class="headerlink" title="Random Upstream"></a>Random Upstream</h2><p>另外一个比较大的特性是引入<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#random" target="_blank" rel="external">random upstream</a>的支持, 其官方手册说明如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* Syntax:	random [two [method]];</div><div class="line">* Default:	—</div><div class="line">* Context:	upstream</div><div class="line"></div><div class="line">The optional two parameter instructs nginx to randomly select two servers and then choose a server using the specified method. The default method is least_conn which passes a request to a server with the least number of active connections.</div></pre></td></tr></table></figure>
<p>这里我们主要关注<code>random two least_conn</code>的情况; 什么意思呢?</p>
<p>用随机算法的时候，我们最担心的就是随机不均衡的问题, 所以对于我们upstream的random算法，其也要考虑这个方面的情况, 而<code>two least_conn</code>就是处理这个问题的有效手段，下面具体分析。</p>
<p>首先回到一个纯粹的数学问题，N个请求让N个服务器处理，则处理请求最多的服务器其会处理多少请求呢？</p>
<p>我们知道正常情况下，平均一个服务器会处理一个请求，但是事实上这个是低概率事件, 从<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="external">Balanced Allocations</a>的分析，其原话是:</p>
<blockquote>
<p>the fullest box has, with high probability, ln $n$ / ln ln $n(1 + o(1))$ ball in it</p>
</blockquote>
<p>也就是其实最大负载的机器其处理的请求数会远超于均值, 而如果用<code>Two Random Choices</code>(随机选两个，其次选择负载低的策略), 其概率大概为 $ln \ ln\ n$</p>
<p>如下是去概率函数分布图: </p>
<p><img src="/images/two-choice-info.svg" alt="two-random-choice"></p>
<p>总而言之, 双次选择会使得我们的负载均衡的表现更为优异。</p>
<p>如上公式的数学推导其实是比较复杂的(至少我没有看懂), 所以这里在简单分享自己对”N个请求让N个服务器处理，则处理请求最多的服务器其会处理多少请求呢?”这个问题的程序员解法;(Maybe有错误哈)</p>
<p>首先定义概率密度函数:</p>
<ul>
<li>$f(k)$ : 表示N个球放N个盒子,处理请求最多的盒子其处理请求数量为k的概率</li>
<li>则上面的问题，其实求的就是该分布的期望, 可以有:</li>
</ul>
<p>$$E = \sum_{k=1}^{n}{f(k)*k}$$</p>
<p>其次，我们分析如何求解$f(k)$, 这里面我们通过传统概率算法计数法来计算对应的概率, 具体如下:</p>
<ul>
<li>N个球放入N个盒子，不考虑球的差异性，其有 $\binom{2*n-1}{n}$ 可能性</li>
<li><p>再考虑如果最多盒子对应的球的个数为k的放法, 我们定义为$c(n_1,n_2,k)$, 表明$n_1$个球放入$n_2$盒子，最多的盒子里面有$k$个球的方法数,则显然有:</p>
<ul>
<li>$c(n,n,1)$ = 1</li>
<li>$c(n,n,n)$ = n</li>
</ul>
</li>
</ul>
<p>而对于$c(n,n,k)$我们则使用递归法统计， 我们可以估算其最多有$i$个盒子里面有$k$个球，基于次分析:</p>
<p>$$c(n_1,n_2,k) =  \sum_{i=1}^{n} (cc(i) <em> (\sum_{j=1}^{k-1}c(n_1-i</em>k,n_2-i, j)))$$</p>
<p>其中$cc(i)$ 表明$i$个盒子有$k$个球，选取的办法有$\binom{n_2}{i}$<br>而公示后半部分的意思是剩余的盒子里面，最多为1,2,…,k-1个球的放法</p>
<p>按照如上的公示，可以得到代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s</span><span class="params">(ball,box,k)</span> :</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ball &gt; box <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> box &gt; ball <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        total = math.factorial(box) / math.factorial(ball) / math.factorial(box - ball)</div><div class="line">        <span class="keyword">return</span> total</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ball == box <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    </div><div class="line">    total = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,ball+<span class="number">1</span>) :</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> i * k &gt; ball :</div><div class="line">            <span class="keyword">break</span></div><div class="line">            </div><div class="line">        <span class="keyword">if</span> i &gt; box :</div><div class="line">            <span class="keyword">break</span></div><div class="line">        </div><div class="line">        tmp1 = math.factorial(box) / math.factorial(i) / math.factorial(box - i)</div><div class="line">        tmp2 = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k) :</div><div class="line">            tmp2 += s(ball- i*k, box-i, k-j)</div><div class="line">        total += tmp1 * tmp2</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> total</div></pre></td></tr></table></figure>
<p>依照如上公示，我们可以得到一些期望值如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ball_exp(<span class="number">10</span>) = <span class="number">3.7</span></div><div class="line">ball_exp(<span class="number">20</span>) = <span class="number">4.7</span></div><div class="line">ball_exp(<span class="number">40</span>) = <span class="number">5.6</span></div></pre></td></tr></table></figure></p>
<p>和上面的数据推导数据不完全一致，但是还是符合相应的函数曲线的</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://fly.io/articles/simple-wins-power-of-2-load-balancing/" target="_blank" rel="external">When Simple Wins: The Power of Two Random Choices</a> : 介绍<code>Two-Random-Choices</code>在<code>fly.io</code>的应用</p>
</li>
<li><p><a href="http://liblb.com/p2c.html#experiment" target="_blank" rel="external">An Empirical Study of Load Balancing Algorithms</a> : 对<code>Two Random Choices</code>的深入介绍和说明</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-20180624" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/02/20180624/">weekly of 20180624</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/07/02/20180624/" class="article-date">
  <time datetime="2018-07-02T04:49:45.000Z" itemprop="datePublished">2018-07-02</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/hongkong.jpg" alt="香港"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://news.ycombinator.com/item?id=17363871" target="_blank" rel="external">Jsonnet – A data templating language | Hacker News</a> : Jsonnet是一个Json的模板语言，可以简单快速的构建基于Json的数据结构；PS: 其应用场景应该是作为中间工具，让业务用比较低的成本编写Json(支持计算/变量等)，然后转换成最终的Json，降低业务json的维护和改造成本, 但是感觉其学习成本也不低</p>
</li>
<li><p><a href="https://www.bleepingcomputer.com/news/security/changes-in-webassembly-could-render-meltdown-and-spectre-browser-patches-useless/" target="_blank" rel="external">Changes in WebAssembly Could Render Meltdown and Spectre Browser Patches Useless</a> : WebAssembly提供了一个能让程序更高效运行在浏览器的机制，但是也可能存在一些副作用，比如一旦引入类似于<code>multi-thread</code>的机制，就可能引入一些安全问题和风险, 比如之前CPU的Meltdown和Spectre漏洞</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491111&amp;idx=1&amp;sn=4dae1d28412e4a09e8cc56e3d35284cf" target="_blank" rel="external">独家揭秘：腾讯千亿级参数分布式ML系统无量背后的秘密</a> : 信息量很大，先mark，本周消化下</p>
</li>
<li><p><a href="https://blog.acolyer.org/2018/06/26/deep-code-search/" target="_blank" rel="external">Deep code search | the morning paper</a> : 挺有意思的一个系统，通过深度学习的方法来了解代码的大概功能，基于此，可以解决一些语义检索的问题，比如说”read an object from xml”, 可能有一天会取代<code>stack overflow</code></p>
</li>
<li><p><a href="https://khanna.cc/blog/structuring-deep-learning-projects/" target="_blank" rel="external">Structuring Deep Learning Projects</a> : 本文介绍一个架构化的深度学习项目的开展方式，具体包括: </p>
<ol>
<li>Pick a cost function.</li>
<li>Pick an initial network architecture.</li>
<li>Fit the training set well on the cost function.</li>
<li>Fit the validation set well on the cost function.</li>
<li>Verify performance on a test set.</li>
<li><p>Verify performance in the real world.</p>
<p>其实这也是普适的机器学习方法</p>
</li>
</ol>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>About Perf Tool</p>
</blockquote>
<ul>
<li><p>选择工具: <a href="http://www.brendangregg.com/blog/2015-07-08/choosing-a-linux-tracer.html" target="_blank" rel="external">Choosing a Linux Tracer (2015)</a>  作者分享了自己如何选择trace的参考依据，结论是建议大部分情况可以优先考虑perf tool(系统默认支持，不过和系统版本相关性较大)</p>
</li>
<li><p>入门使用 :</p>
<ul>
<li><a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="external">Perf: Tutorial</a> : 入门了解</li>
<li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="external">Brendangregg: perf Examples</a> : 系统介绍</li>
</ul>
</li>
<li><p>机制原理 : </p>
<ul>
<li><a href="https://jvns.ca/blog/2016/03/12/how-does-perf-work-and-some-questions/" target="_blank" rel="external">How does perf work? (in which we read the Linux kernel source)</a></li>
<li><a href="https://news.ycombinator.com/item?id=11277172" target="_blank" rel="external">Hacker News Comment On How does perf work</a></li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491140&amp;idx=1&amp;sn=8849bce1ea612049a07f6406c244a771" target="_blank" rel="external">最强指南：处理35种不良数据的正确方式</a> : 一些处理数据的tips建议，可以关注的点包括<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E7%A6%8F%E7%89%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="external">本福特定律</a>,<a href="https://www.quora.com/What-is-p-hacking" target="_blank" rel="external">结果被p-hack</a></p>
</li>
<li><p><a href="https://github.com/oddisland/Draft" target="_blank" rel="external">Draft:Online markdown editor</a> : 感觉是一个还不错的markdown在线编辑器</p>
</li>
<li><p><a href="https://pomax.github.io/bezierinfo/zh-CN/" target="_blank" rel="external">A Primer on Bézier Curves</a> : 进行mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491127&amp;idx=1&amp;sn=9897b560cb0350e8ece0f61b3dc461c4" target="_blank" rel="external">这是我看过解释TensorFlow最透彻的文章！</a> : 继续mark</p>
</li>
<li><p><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">Valloric/YouCompleteMe: A code-completion engine for Vim</a> : A code-completion engine for Vim, 一个比较系统的代码补全工具的合集, 还可以参看<a href="https://ops.tips/gists/navigating-the-linux-kernel-source-with-youcompleteme/" target="_blank" rel="external">Navigating the Linux Kernel source tree with YouCompleteMe | OpsTips</a>这个的介绍说明</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>