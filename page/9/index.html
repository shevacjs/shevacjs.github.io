<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/9/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-io_in_linux_and_nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/io_in_linux_and_nginx/">linux和nginx下的异步文件IO管理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/05/io_in_linux_and_nginx/" class="article-date">
  <time datetime="2015-04-05T06:17:28.000Z" itemprop="datePublished">2015-04-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx在其最近发布的<a href="http://nginx.org/en/CHANGES" target="_blank" rel="external">1.7.11版本增加了thread pool</a>的feature, 其引入的<a href="http://nginx.org/en/docs/ngx_core_module.html#thread_pool" target="_blank" rel="external">thread_pool</a>主要是能真正意义的保证读写文件的非阻塞以及异步。为什么需要主动添加<code>thread pool</code>这个机制来支持异步非阻塞的文件读写呢？这里简单说下linux的文件IO管理和以及nginx的thread poo机制的必要性，最后说下nginx thread pool的大致实现机制。</p>
<p>其实关于linux和nginx的IO管理，已经有非常详细的说明文档，具体包括如下:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
</ul>
<p>这里只是针对上面介绍内容的一个简单总结和概述</p>
<h3 id="linux下的异步IO支持"><a href="#linux下的异步IO支持" class="headerlink" title="linux下的异步IO支持"></a>linux下的异步IO支持</h3><p>linux下主要有如下两个方式的异步IO支持，分别如下:</p>
<h4 id="glibc-异步IO支持"><a href="#glibc-异步IO支持" class="headerlink" title="glibc 异步IO支持"></a>glibc 异步IO支持</h4><p>这个是glibc提供的一系列函数，包括<code>aio_read</code>, <code>aio_suspend</code>等(‘man aio_read’查看具体用法), 其核心特点是使用较为方便，但是在实现层面的话，其实是在用户层通过多线程实现的，并非真正意义上面的异步IO，因此其性能相对于真正意义上面的异步IO要慢一些。</p>
<h4 id="native-AIO支持"><a href="#native-AIO支持" class="headerlink" title="native AIO支持"></a>native AIO支持</h4><p>其实linux本身已经提供了对异步io的支持[2.5版本开始]，也就是<code>io_submit</code>, <code>io_setup</code>之类的函数，但是glibc并没有对这类函数进行封装，因此如果要使用的话，可以通过:<br>1) syscall直接调用操作系统API<br>2) <a href="http://lse.sourceforge.net/io/aio.html" target="_blank" rel="external">libaio</a> : 一个轻量级的封装库</p>
<p>来使用。</p>
<p>由于直接是操作系统的支持，因此此类函数的性能相对比与glibc的aio性能上面有较大的提升，但同时也面临着如下两个比较大的问题，导致其应用范围大大受限:</p>
<ul>
<li>使用AIO必须打开<code>IO_DIRECT</code> flag，同时要求读写的的大小和偏移要以区块的方式对齐</li>
<li>启用AIO同时会关闭<code>sendfile</code>，也就意味着此时会丧失了零拷贝的特征；如果继续使用sendfile, 意味着读可能会阻塞</li>
</ul>
<p>总之，在现有的linux体系下，对文件的异步读写，没有完美的简单的解决方案。</p>
<h3 id="nginx对异步IO的支持"><a href="#nginx对异步IO的支持" class="headerlink" title="nginx对异步IO的支持"></a>nginx对异步IO的支持</h3><p>nginx和异步IO相关的主要指令有:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">syntax : aio on | off | thread ;</div><div class="line"></div><div class="line">是否启动aio，如果是指定其关联的thread pool name </div><div class="line"></div><div class="line">syntax : directio size | off ;</div><div class="line"></div><div class="line">是否启用directio; 或者在大于size之后才启用directio</div><div class="line"></div><div class="line">syntax : sendfile on | off  ;</div><div class="line"></div><div class="line">是否启用sendfile </div><div class="line"></div><div class="line">## 加上最新的thread pool</div><div class="line"></div><div class="line">syntax : thread_pool name threads=number [max_queue=number];</div><div class="line"></div><div class="line">创建一个thread pool</div></pre></td></tr></table></figure>
<p>具体可以参看<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#aio" target="_blank" rel="external">nginx官方说明文档</a></p>
<p>基于如上的总结，当<code>aio</code>, <code>directio</code>, <code>sendfile</code>都开启的时候(如果有off的情况，判断较为简单，不在赘述)，整个nginx对文件的读取策略如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                     _  use aio   _</div><div class="line">                   /                \</div><div class="line">                 yes            has thread pool</div><div class="line">                /                      \</div><div class="line">directio &gt; size                        support asyn &amp; noblock IO</div><div class="line">                \                      /</div><div class="line">                 no             has thread pool</div><div class="line">                   \                 /</div><div class="line">                    \_ use sendfile /</div></pre></td></tr></table></figure>
<h3 id="nginx的thread-pool机制"><a href="#nginx的thread-pool机制" class="headerlink" title="nginx的thread pool机制"></a>nginx的thread pool机制</h3><p>本来想详细介绍nginx thread pool的实现机制，但是发现可以展开讨论的内容不多。这里就做个系统性的总结。</p>
<p>由于linux系统对异步IO的支持有着或多或少的局限性，如果nginx要保证其整个worker进程异步非阻塞的模型有一定的难度，因为在读取文件的时候可以存在着阻塞的情况。</p>
<p>为此nginx的解决方案是引入thread pool, 用户可以创建特定个数的thread pool，每个thread pool可以指定其具体的OS线程数。现在thread pool的核心作用就是托管一些可能存在阻塞的IO操作（包括普通的read, sendfile）, 当有此类操作的时候，nginx会根据用户的配置把任务递送给线程池，尽量不阻塞worker进程。</p>
<p>具体到thread pool的实现，没有特别的地方(不过我也没看的特别细)，通过<code>pthread lib</code>维护一堆线程, 用户可以提交具体的task给线程池，让其消费。</p>
<p>其主要作用可能是会提高那些存在高IO读取的webserver的并发支持数。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://cnodejs.org/topic/4f16442ccae1f4aa270010a7" target="_blank" rel="external">linux AIO(异步IO)那点事儿</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></li>
<li><a href="http://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux" target="_blank" rel="external">Difference between POSIX AIO and libaio on Linux?</a></li>
</ul>
<p>lenky关于AIO的系列文章:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2184" target="_blank" rel="external">nginx对Linux native AIO机制的应用(配置篇)</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2186" target="_blank" rel="external">nginx对Linux native AIO机制的应用（实现篇）</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-log_rotation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/log_rotation/">nginx日志切分方案说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/07/log_rotation/" class="article-date">
  <time datetime="2015-03-07T07:34:36.000Z" itemprop="datePublished">2015-03-07</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx的日志切分问题一直是运维nginx时需要重点关注的。本文将简单说明下nginx支持的两种日志切分方式。</p>
<h3 id="定时任务切分"><a href="#定时任务切分" class="headerlink" title="定时任务切分"></a>定时任务切分</h3><p>所谓的定时任务切分，是指通过定时任务（比如<code>crontab</code>)，发送信号给nginx，让其重新打开文件。该方法也是nginx官网上面比较推荐的,<a href="http:http://wiki.nginx.org/LogRotation" target="_blank" rel="external">原文</a>说明比较清楚，这里在说明下：</p>
<p>发送<code>USR1</code> 信号会让nginx主动重新打开日志文件，故操作如下：</p>
<pre><code>$ mv access.log access.log.0
$ kill -USR1 `cat master.nginx.pid`
$ sleep 1
$ gzip access.log.0    # do something with access.log.0
</code></pre><p>总结 ：优点是思路较为简单，但效果明显，而且对error_log 同样适用；缺点是有外部依赖（比如 <code>crontab</code>)</p>
<h3 id="自切分"><a href="#自切分" class="headerlink" title="自切分"></a>自切分</h3><p>自切分是指让nginx自身实现日志切分功能，不依赖crontab等东西。 其主要原理是依赖access_log的强大功能—- 可以用变量定义请求的log路径。</p>
<p>nginx的acess_log 功能非常强大，其完整指令说明如下，这里主要说明定义日志路径的功能；关于syslog还有gzip, buffer等特性，后续再说明。</p>
<p>access_log指令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	Syntax:	access_log path [format [buffer=size [flush=time]] [if=condition]];</div><div class="line">			   access_log path format gzip[=level] [buffer=size] [flush=time] [if=condition];</div><div class="line">			   access_log syslog:server=address[,parameter=value] [format [if=condition]];</div><div class="line">			   access_log off;</div><div class="line">	Default:	access_log logs/access.log combined;</div><div class="line">	Context:	http, server, location, if in location, limit_except</div><div class="line">    </div><div class="line">```	</div><div class="line">    </div><div class="line">注意path部分是支持nignx变量的，这也就意味这我们只要通过配置正确的nginx变量，就可以实现小时等级别的日志自动拆分了。</div><div class="line"></div><div class="line">一个简单的问题就出现了，假设nginx要实现这个机制，那岂不是每打印一个请求log就得打开文件，写日志，关闭文件？ 这样显然效率太差了，为了解决这个问题，nginx又引入了一个机制，叫做 open_file_cache，简单的说，这个东西的功能就是会缓存打开的文件，只有满足一定条件的时候才会重新去check当前fd对应的文件是否合法，是否需要重新打开。 open file cache的指令如下：</div><div class="line"></div><div class="line">```nginx</div><div class="line"></div><div class="line">	Syntax:	 open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</div><div class="line">				open_log_file_cache off;</div><div class="line">	Default:	 open_log_file_cache off;</div><div class="line">	Context:	 http, server, location</div></pre></td></tr></table></figure>
<p>open_log_file_cache 里面几个参数的含义为：</p>
<ul>
<li><strong>max</strong> : 设置缓存中描述符的最大数量；如果缓存被占满，最近最少使用（LRU）的描述符将被关闭。</li>
<li><strong>inactive</strong> : 设置缓存文件描述符在多长时间内没有被访问就关闭； 默认为10秒。</li>
<li><strong>min_use</strong>s : 设置在inactive参数指定的时间里， 最少访问多少次才能使文件描述符保留在缓存中；默认为1。</li>
<li><strong>valid</strong> :设置一段用于检查超时后文件是否仍以同样名字存在的时间； 默认为60秒。</li>
<li><strong>off</strong> :禁用缓存。</li>
</ul>
<p>综上，要让nginx自切分，需要两个步骤，其一，配置合理的access_log;其二，开启open_log_file_cache提升性能； 下面是用实现小时级别日志切分的配置demo</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#提取nginx变量</div><div class="line">if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)")</div><div class="line">&#123;</div><div class="line">	set $year $1; </div><div class="line">	set $month $2; </div><div class="line">	set $day $3; </div><div class="line">	set $hour $4; </div><div class="line">	set $minutes $5; </div><div class="line">	set $seconds $6; </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#配置access_log ；以  hour 为界</div><div class="line">access_log  logs/access.log.$year$month$day$hour;                                                                         </div><div class="line"></div><div class="line">#配置open_log_file_cache</div><div class="line">open_log_file_cache max=10 inactive=60s valid=1m min_uses=2;</div></pre></td></tr></table></figure>
<p><strong>总结</strong> : 自切分可一定程度上面满足日志切分的需求；但是对性能会有一定的影响； 另外，并不支持error_log的切分，个人更推荐产品线采用方式一的方法切。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>本文主要阐述了nignx日志切分的方案，希望能够帮助大家提升对nginx的理解。另外nginx的日志管理，还是很多值得学习，注意的点，包括syslog支持，gzip支持（想想protobuf）。后续会再为介绍。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-mixed_content_control" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/mixed_content_control/">关于https嵌套http iframe的问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/mixed_content_control/" class="article-date">
  <time datetime="2015-03-06T03:13:44.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>主要是https 和 http页面嵌套，引用的一些具体规则？哪些是允许的，哪些是不允许的？</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一般地，我们主要规范https页面上面对http请求的场景。http页面可以嵌入https一般浏览器不会太care</p>
<p>浏览器把https嵌入的外部资源分成两大类，如下:</p>
<ul>
<li>Mixed Passive Content (a.k.a. Mixed Display Content) : 被动页面嵌入内容，此类的资源不会对已有的https主页面产生修改，更新之类的操作，具体包括:  images, audio, and video loads. </li>
<li>Mixed Active Content (a.k.a. Mixed Script Content) : 主动页面嵌入内容，此类的资源可能会影响原来的页面的展现和内容，具体包括: JavaScript, CSS, objects, xhr requests, iframes, and fonts</li>
</ul>
<blockquote>
<p>PS: 不同浏览器对MPC和MAC的分类不一定一致，比如说iframe在chrome下面属于MPC,而在ie/firefox属于MAC</p>
</blockquote>
<p>一般的浏览器如果发现一个资源属于MAC，就会blocking此类请求</p>
<p>故，综上，在IE浏览器下面一个https页面嵌入http请求会直接被block</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.mozilla.org/tanvi/2013/04/10/mixed-content-blocking-enabled-in-firefox-23/" target="_blank" rel="external">Mixed Content Blocking Enabled in Firefox 23!</a></li>
<li><a href="http://www.tinywebgallery.com/blog/iframe-do-not-mix-http-and-https" target="_blank" rel="external">Why you should not mix http and https when using iframes</a></li>
<li><a href="http://lison.sinaapp.com/?p=317" target="_blank" rel="external">HTTPS和HTTP相互间IFRAME的浏览器限制及安全提示</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-about_https" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/about_https/">https 概述</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/about_https/" class="article-date">
  <time datetime="2015-03-06T03:13:34.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>个人学习目标:</p>
<ol>
<li>了解https的核心以及几个常见的概念</li>
<li>了解https的大致交流流程</li>
<li>明确https的性能关键点&amp;优化点</li>
<li>了解https在具体实践过程的常见问题以及解决方案</li>
</ol>
<p>几点总结 :</p>
<ul>
<li>关于加密解密都是非常细致的一个处理过程，有非常多的细节需要关注，但尽量会把协议本身</li>
<li>多用一些图示和衍生的demo展示来加深对https的理解</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p>整个交换过程可以大致分为两个阶段:</p>
<ol>
<li><p>TLS握手: 协商此次交互的用于加密的对称密钥，这个过程颇为复杂，等下会详解，核心思想是通过非对称密钥和双方的随机数生成一个密钥</p>
</li>
<li><p>具体内容交互: 此时双方都用上一步生成的对称密钥，加密要交互的内容，进行通信</p>
</li>
</ol>
<h2 id="TLS握手流程"><a href="#TLS握手流程" class="headerlink" title="TLS握手流程"></a>TLS握手流程</h2><p>如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client                                  server</div><div class="line"></div><div class="line">ClientHello             --------&gt;</div><div class="line">        </div><div class="line">                                        ServerHello </div><div class="line">                                        ServerCertificate</div><div class="line">                        &lt;--------       ServerKeyExchange</div><div class="line">                                        CertificateRequest</div><div class="line">                                        ServerHelloDone</div><div class="line"></div><div class="line">ClientCertificate</div><div class="line">ClientKeyExchange</div><div class="line">Certificate Verify      --------&gt;</div><div class="line">Change the Cipher Spce</div><div class="line">Client Finish Message</div><div class="line"></div><div class="line">                                        Change Cipher Spec</div><div class="line">                        &lt;--------       Server Finish Message</div><div class="line"></div><div class="line">&lt;--------------    Application Data  ----------------------&gt;</div></pre></td></tr></table></figure>
<p>总结:</p>
<ul>
<li>client&amp;server加起来一共两个RTT的过程</li>
<li>协商出来的密钥大致是: 2 * client ranodw + server random </li>
<li>整个交互过程还是明文的，不过生成的密钥是使用非对称加密算法加密的</li>
</ul>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>几个关键的性能点</p>
<h3 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h3><p>如上，如果每次交互都需要重新进行TLS握手，需要浪费两个RTT，这个是不大希望的，我们可以引入如下两个机制，使得在进行TLS握手的时候，就需要一个RTT，包括:</p>
<ul>
<li>会话标识符(Session Identifier) :</li>
<li>会话记录单(Session Ticket) :</li>
</ul>
<h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><p>在进行TLS握手的时候，一般地，我们要求client端去严重证书的合法性，一个重要的判断是证书的有效时间的问题，主要有如下两个方法:</p>
<ul>
<li>证书撤销名单(CRL, Certificate Revocation List)</li>
<li>在线证书状态协议(OCSP, Online Certificate Status Protocol)</li>
</ul>
<p>如上是具体的协议，而浏览器在具体工作的时候，不同的浏览器行为也不一致，比如:</p>
<ul>
<li>某些浏览器会使用自己的更新机制推送更新CRL名单</li>
<li>某些浏览器只会针对扩展证书(EV证书)进行实时的OCSP和CRL检查</li>
</ul>
<p>这些情况很复杂。对整个系统设计来说，可以引人一个叫做<code>OCSP封套</code>的优化措施: 服务器可以在证书链里面包含证书颁发机构的OCSP响应，让浏览器跳过在线查询。把查询OCSP操作转移到服务器可以让服务器缓存签名的OCSP响应。当然OCSP响应也包含一系列问题，包括:</p>
<ul>
<li>OCSP的包体大小(400 ~ 4000)可能会导致TCP窗口拥塞</li>
<li>只能包括一个OCSP响应，导致浏览器对其他的证书仍然需要发送OCSP响应</li>
</ul>
<h2 id="应用及问题"><a href="#应用及问题" class="headerlink" title="应用及问题"></a>应用及问题</h2><h3 id="第三方cdn服务商的https支持"><a href="#第三方cdn服务商的https支持" class="headerlink" title="第三方cdn服务商的https支持"></a>第三方cdn服务商的https支持</h3><p>对于CloudFlare这样的云服务提供商，要给第三方做cdn的加速支持，如果此时主站点的域名是通过https提供服务，这就要求cdn缓存的静态文件也是需要走https，由于cdn是第三方的(CloudFlare)，主站显然不大可能把https的私钥放在服务商那边，对于此类场景要怎么办?</p>
<p>CloundFlare在<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="external">Keyless SSL: The Nitty Gritty Technical Details</a> 介绍了一个所谓的<code>Keyless SSL</code>机制，核心的思路就是： 正常情况下, 整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。</p>
<h3 id="nginx对SSL的支持"><a href="#nginx对SSL的支持" class="headerlink" title="nginx对SSL的支持"></a>nginx对SSL的支持</h3><p>如上ssl/tls相对于普通的http1.0/1.1协议复杂很多，因此整个nginx的SSL的指令和变量也是非常负责的，详情可以参看</p>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#example" target="_blank" rel="external">Module ngx_http_ssl_module</a></li>
<li><a href="http://nginx.org/cn/docs/http/configuring_https_servers.html#optimization`" target="_blank" rel="external">Nginx: 配置HTTPS服务器</a></li>
</ul>
<h2 id="推荐了解的名词"><a href="#推荐了解的名词" class="headerlink" title="推荐了解的名词"></a>推荐了解的名词</h2><ul>
<li>数字签名&amp;数字证书 : <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></li>
</ul>
<h2 id="参考-amp-推荐文章"><a href="#参考-amp-推荐文章" class="headerlink" title="参考&amp;推荐文章"></a>参考&amp;推荐文章</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank" rel="external">HTTPS的七个误解（译文）</a></li>
</ul>
<h2 id="todo-for-me"><a href="#todo-for-me" class="headerlink" title="todo for me"></a>todo for me</h2><ol>
<li>nginx搭建一个完整的https服务</li>
<li>对tls恢复方式的进一步了解(session identifier &amp; session ticket)</li>
<li>用http watch观看https的交互</li>
</ol>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-web_browser_and_protocol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/web_browser_and_protocol/">从浏览器角度看web交互</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/web_browser_and_protocol/" class="article-date">
  <time datetime="2015-03-06T03:13:24.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>web浏览器已经成为我们获取信息最重要的工具之一，我们也不仅仅把web浏览器当成简单的http内容获取+页面渲染的功能，而是希望在web上面构建越来越多的应用，比如实时会议之类的，这里简单说明下从web浏览器角度，分析他应该和现在支持的web交互功能</p>
<h2 id="浏览器要干嘛"><a href="#浏览器要干嘛" class="headerlink" title="浏览器要干嘛"></a>浏览器要干嘛</h2><p>浏览器终归到底是一个client，负责和server交互，如果不考虑本地渲染的复杂功能，我们对浏览器的考差点就是他如何支持一个交互的</p>
<p>一个交互可以划分如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client api ---&gt; protocol support ---&gt; server</div></pre></td></tr></table></figure>
<p>可见，浏览器主要关心两个大点：</p>
<ul>
<li>client api : 浏览器需要提供标准的api，有个规范的标准便于在不同平台上面的迁移</li>
<li>protocol : 其实就是对具体api的实现，比如用http交互等</li>
</ul>
<p>上面就是一个宏观上面的分析，下面说明具体的实现和现状</p>
<h2 id="Client-API-html5-以及js"><a href="#Client-API-html5-以及js" class="headerlink" title="Client API : html5 以及js"></a>Client API : html5 以及js</h2><p>HTML语言充当了client api一个最重要的角色，用于描述浏览器的行为，当然还包括javascript, css等</p>
<p>新的HTML5规范还增加了新的API规范，其实就是对之前html的补充，包括:</p>
<h2 id="Protocols-http-websocket"><a href="#Protocols-http-websocket" class="headerlink" title="Protocols : http, websocket"></a>Protocols : http, websocket</h2><p>protocol就是浏览器要实现的协议，当然http协议是最核心的，也是必须要实现的；但是，随着client api的增加，对于新的api可能就需要实现特定的协议(比如websocket)，因此，现如今，浏览器支持的协议是越来越多，下面是一个简单分类:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>(现在)依赖协议</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ajax(XmlHttpRequest)</td>
<td>http</td>
<td>-</td>
</tr>
<tr>
<td>Server-Sent Event</td>
<td>http</td>
<td>服务器以text/event-stream内容响应</td>
</tr>
<tr>
<td>websocket</td>
<td>http + websocket</td>
<td>http发起连接,ws具体交互</td>
</tr>
<tr>
<td>webrtc</td>
<td>udp+ice+srtp等</td>
<td>基于udp构建</td>
</tr>
</tbody>
</table>
<p>因此浏览器的协议支持图大致如下:</p>
<p><img src="./browser_protocol_support.png" alt="Alt text"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>其一:</p>
<p>api可以理解为是对具体功能的描述，而协议是对具体实现的描述，两者并不是强耦合的，比如说websocket的api，其描述的就是对一个双向的，自由格式的内容交互的支持。其现在的底层实现是基于websocket 协议的，但是http 2协议显然也能满足这个功能，也是可以用了实现这个协议的。</p>
<p>其二:</p>
<p>下图描绘几个api和server交互的场景</p>
<p><img src="./ajax_vs_websocket.png" alt="Alt text"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>web性能权威指南</li>
<li>web之困:现代web应用安全指南 </li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-0225_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/25/0225_bitch_about/">生活与生存</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/25/0225_bitch_about/" class="article-date">
  <time datetime="2015-02-24T16:25:11.000Z" itemprop="datePublished">2015-02-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是大年初七凌晨，如之前所料，基本上所有的人都各奔东西，一年一次的聚散又是要匆匆而过</p>
<p>这次春节和之前差不多，基本上一半的时间都是和那些同学聚在一起，一起踢过球，喝过酒，打过牌，打过麻将，当然包括各种玩笑，谈话，还是很开心的</p>
<p>有时候会想自己为什么会更享受在家的生活，想的的一些原因包括:</p>
<ul>
<li>不需要工作了</li>
<li>因为有一群同学在，什么东西都可以吐槽</li>
<li>住在家里</li>
</ul>
<p>其实认真想想上面几个点都有一点，但其实自己有一个简单的总结，就是在这边的话，感觉自己更像在<code>生活</code>,其实之前自己对生活和生存，虽然有非常明确的语义以及其具体含义的理解，但是自己慢慢感触这个却是随着自己岁数的不断增大，现在自己的情况，更多的精力应该是让自己生存下去，让自己一直努力，让自己坚持不懈…</p>
<p>我自己希望能够在工作和<code>生活</code>中找到更好的平衡点，让自己的活的更自在一些，嗯，的确一直在调整…</p>
<p>今天看到一篇文章，大道理讲的很多，但里面有一个简单的观点，大致是说，不要太过分的欣赏和佩服自己某一刻的努力，大致的意思是世界上比你多努力的人多了去了。。。嗯，有时候后自己就会陷入这个状态，然后盲目的迷失了…</p>
<p>不再细说，今年自己要好好努力，也希望一切静好:)</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-linux_kernel_lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/06/linux_kernel_lock/">由linux锁机制想起来的</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/06/linux_kernel_lock/" class="article-date">
  <time datetime="2015-02-06T08:26:33.000Z" itemprop="datePublished">2015-02-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由linux锁机制想起来的"><a href="#由linux锁机制想起来的" class="headerlink" title="由linux锁机制想起来的"></a>由linux锁机制想起来的</h1><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>根本的目标是要实现同步机制，数据不会被打乱。</p>
<p>而在哪些情况需要同步机制呢？</p>
<ul>
<li>多处理器的情况：</li>
<li>抢占式系统 :</li>
<li>其他：</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>一般是指令自己触发的，处理也是比较简单的，主要有两种：</p>
<ul>
<li>页错误： 应该是唯一会出现的内核异常，此时会进行一些换页操作</li>
<li>其他（比如除以0，int 3）等：一般的流程是，cpu触发异常—&gt; 内核异常流程处理 —&gt; 发送信号给用户进程 –&gt; 如果用户进程不处理，就kill进程 </li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>先简单分类:</p>
<ul>
<li>I/O 中断:</li>
<li>时钟中断:</li>
<li>多处理器中断:</li>
</ul>
<p>按照处理的策略一般分为：硬中断和软中断（或者是所谓的下半部)</p>
<p>硬中断：一般是非常简单的处理逻辑<br>软中断：会拆分很多，包括softirq, tasklist, work queue, kernel thread, 具体见：<a href="https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY" target="_blank" rel="external">https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY</a></p>
<h2 id="关于抢占式内核"><a href="#关于抢占式内核" class="headerlink" title="关于抢占式内核"></a>关于抢占式内核</h2><ul>
<li><p>中断和抢占的区别</p>
<ul>
<li>中断总是存在的，响应硬件的事件</li>
<li>抢占主要是指是否执行的代码是否能被其他进程抢占</li>
</ul>
</li>
<li><p>用户态抢占和内核抢占</p>
<ul>
<li>根据被抢占的时机区分用户台态和内核态抢占</li>
<li>用户态抢占: 用户台的抢占一般比较容易，在系统调用或者中断处理完成之后返回用户态的时候判断就可以了，另外由于此时用户态的上下文保存的较为完成，直接切换到其他的进程，至少感觉实现成本不是很高</li>
<li>内核态抢占: 简单的说，如果一段代码执行在内核态，能否也被抢占，个人感觉如果支持的话，其主要成本对整个内核的一些同步机制和代码等造成的影响，下面是copy的说明</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">如果内核是不可抢占的（比如说2.4的内核），一旦切进内核态，只要代码不是主动释放CPU它就可以一直占着CPU。例外，虽不可抢占，但若此时发生中断，代码还是要交出CPU，但是中断返回之后，代码又能霸占CPU了，此为可中断但不可抢占。</div><div class="line"></div><div class="line">如果内核是可抢占的（比如2.6或之后的内核），上述情况就不会发生了。内核抢占发生在以下3种情况：</div><div class="line"></div><div class="line">1. 从中断返回内核态时，若此时可抢占，则会强制调用schedule（），尝试抢占，被中断的内核代码不一定能继续霸着CPU。</div><div class="line"></div><div class="line">2.内核变成可抢占状态，此时也会尝试抢占。</div><div class="line"></div><div class="line">3.内核代码主动调用schedule（）。</div><div class="line"></div><div class="line">虽然2.6的内核提供内核抢占，但是也提供关闭的手段。是否可抢占是由preemt_count变量控制（per-cpu），有锁这个计数就+1，释放锁就-1.为0才是可抢占。每当释放锁的时候都会检查是否为0，为0则尝试抢占。</div></pre></td></tr></table></figure>
<h2 id="关于进程上下文和中断上下文"><a href="#关于进程上下文和中断上下文" class="headerlink" title="关于进程上下文和中断上下文"></a>关于进程上下文和中断上下文</h2><p>个人感觉进程，两个上下文主要有两个含义，一个代表具体上下文关联的环境，比如寄存器之类的；另一个是一段内核代码运行的环境。而后者是更为常见和需要关注的。</p>
<p>断上下文是引申出来的概念，其主要的目标是明确一个内核代码是否能执行某些操作。比如一个内核代码能否睡眠？ 因为在中断上下文的情况下，是不允许睡眠的。。。</p>
<p>而更具体实际的差别在于，进程上下文是指一段代码代表一个进程在执行，主要有两种情况:</p>
<ul>
<li>一个系统调用导致陷入内核后的代码执行；</li>
<li>异常出发导致的异常执行</li>
</ul>
<p>而中断上下文是但一个中断发生时，其内核代码管理的环境；</p>
<p>中断上下文的要求是比较多的，包括:</p>
<ul>
<li>睡觉或者放弃cpu</li>
<li>尝试获取信号量</li>
<li>执行耗时任务</li>
<li>访问用户空间的虚拟地址 : </li>
</ul>
<p>中断处理流程中不能睡眠，具体可以见: <a href="http://www.oschina.net/question/565065_57618" target="_blank" rel="external">http://www.oschina.net/question/565065_57618</a><br>这个上面的讨论</p>
<p>具体可以见: <a href="http://www.embedu.org/Column/Column240.htm" target="_blank" rel="external">http://www.embedu.org/Column/Column240.htm</a></p>
<h2 id="各种链接哈"><a href="#各种链接哈" class="headerlink" title="各种链接哈"></a>各种链接哈</h2><ul>
<li><a href="http://hacklu.com/blog/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%AD%E6%96%AD-75/" target="_blank" rel="external">内核抢占和中断</a></li>
<li><a href="http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/" target="_blank" rel="external">http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/</a></li>
<li><a href="http://guojing.me" target="_blank" rel="external">http://guojing.me</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_close" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/tcp_close/">tcp的关闭处理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/01/tcp_close/" class="article-date">
  <time datetime="2015-02-01T15:41:49.000Z" itemprop="datePublished">2015-02-01</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>tcp的系列文章，不深究源码，偏于理解&amp;应用</p>
</blockquote>
<h2 id="状态图迁移"><a href="#状态图迁移" class="headerlink" title="状态图迁移"></a>状态图迁移</h2><p>一般tcp的关闭称为四次挥手，要求client/server端都关闭该通道的连接，他们的状态迁移图如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#这里暂不考虑同时关闭的情况</span></div><div class="line"></div><div class="line">主动关闭方                  被动关闭方</div><div class="line"></div><div class="line">ESTABLISTED                 ESTABLISED</div><div class="line">    |                           |</div><div class="line">  (send fin)                (get fin</div><div class="line">    |                       /snd ack)</div><div class="line">    |                           |</div><div class="line">    v                           v</div><div class="line">FIN_WAIT_1                  CLOSE_WAIT</div><div class="line">    |                           |</div><div class="line">  (get ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (send fin)</div><div class="line">FIN_WAIT_2                      |</div><div class="line">    |                           v</div><div class="line"> (getfin                    LAST_ACK</div><div class="line"> /send ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (get ack )</div><div class="line">TIME_WAIT                       |</div><div class="line">    |                           |</div><div class="line">  (2* MSL)                      v</div><div class="line">    |                        CLOSED</div><div class="line">    v</div><div class="line">CLOSED</div></pre></td></tr></table></figure>
<h2 id="API关系"><a href="#API关系" class="headerlink" title="API关系"></a>API关系</h2><p>关闭的函数主要有两个，如下:</p>
<ul>
<li>close : close主要是减少句柄的引用计数，如果为0，在发送fin信号，关闭这一端的连接;</li>
<li>shutdown : shutdown则是直接发送FIN信号，不考虑引用计数的问题，可以导致一些正在连接的socket直接无效了</li>
</ul>
<p>而在具体使用上面，还有一些细节，包括:</p>
<ul>
<li><p>close一般情况下是非阻塞的，但我们可以通过设置SO_LINGER的socket选项对close的行为做一些控制,使之变成非阻塞，具体包括:</p>
</li>
<li><p>shutdown可以控制关闭读或者关闭写</p>
</li>
</ul>
<p>这里面的一个经典问题的<code>客户端关闭时，如何让服务端尽量的收到数据?</code>，这个后续再详述。</p>
<h2 id="常见问题-amp-配置"><a href="#常见问题-amp-配置" class="headerlink" title="常见问题&amp;配置"></a>常见问题&amp;配置</h2><p>回到tcp的状态迁移本身，这里面说明下常见的问题：</p>
<ul>
<li>A和B交互，如果A send data后，直接close，会有上面影响？</li>
</ul>
<p>首先，我们必须非常明确&amp;理解，socket close的作用，如上，一般的就是减少引用计数，如果为0的话，就发送fin，故我们可以推测如下情况:</p>
<ol>
<li><p>A发送成功fin也接收到了ack，此时A的状态迁移到了fin_time_2; 同样可以考虑两个场景:<br> 1.1 B那边也close了socket，此时B的socekt发送ack过来，则A走正常的关闭流程，从fin_wait_2 –&gt; time_wait-&gt;close<br> 1.2 B那边由于长短链接或者协议约定的不一致，B并不关闭socket，此时B的socket已经变成了close wait; 而A只能继续处在fin_time_2的状态</p>
<p> 问题1.2属于不正常的，一般怎么处理呢?</p>
<ul>
<li>为了保证A不浪费太多时间在FIN_WAIT_2，对于FIN_WAIT_2有个(TCP_FIN_TIMEOUT，默认60s)的限制，也就是说如果A 60s后还没有接收到对方的fin，则自己会自动切到关闭(<code>or time wait:待明确</code>)状态</li>
<li>上面的FIN_WAIT_2状态超时有个细节需要关注，那就是此时的socket必须是属于孤儿状态，也就说没有任何句柄和他们关联，如果有句柄和他关联的话，就就会一直处在FIN_WAIT_2状态。之所以强调这点，是因为tcp本身是允许半关闭的，也就是说肯定有socket是持久的处在FIN_WAIT_2状态的，因为tcp需要提供一个机制来保证该状态的存在，其中最关键的一点就是要先判断一个socket是否是孤儿socket。代码demo如下:</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 假设对方不关闭close fd，分析本端的行为</span></div><div class="line"><span class="comment">//关闭句柄，假设引用计数会变成0</span></div><div class="line">close(fd);</div><div class="line"><span class="comment">// 此时，发送FIN信号，本地的socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 由于没有句柄关联，60s后，改socket将关闭 </span></div><div class="line"></div><div class="line"><span class="comment">// 同样是发送FIN信号，本地socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 但是由于有句柄关联，改状态会一直持续</span></div><div class="line">shutdown(fd, SHUT_WR);</div><div class="line"></div><div class="line"><span class="comment">//shutdow 还有SHUT_RD(关闭读,不发送信号)，SHUT_RDWR(关闭读写，类似close)</span></div></pre></td></tr></table></figure>
<pre><code>* B那边由于被动关闭，而自己也不处理，socket会处于CLOSE WAIT状态，`奇怪的是，系统并没有给close wait一个超时的时间`, 因此我们需要自己想办法清理，`一般close相关的程序就OK了`
</code></pre><h3 id="FIN-WAIT-1的超时问题"><a href="#FIN-WAIT-1的超时问题" class="headerlink" title="FIN_WAIT_1的超时问题"></a>FIN_WAIT_1的超时问题</h3><p>首先明确，如果一个socket进入FIN_WAIT_1，很大可能性是已经没有句柄关联了(shutdown？)</p>
<p>如果此时发送失败的话，会受到<code>tcp_orphan_retries</code>参数的控制（重试次数）</p>
<p>同时为了保证系统的资源有限，<code>tcp_max_orphans</code> 这个参数控制了系统可以存在的最多孤儿socket的个数</p>
<h3 id="TIME-WAIT的存在必要性问题"><a href="#TIME-WAIT的存在必要性问题" class="headerlink" title="TIME_WAIT的存在必要性问题"></a>TIME_WAIT的存在必要性问题</h3><h3 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST ACK"></a>LAST ACK</h3><h2 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h2><ul>
<li><p>TCP里面有些状态有超时，有些没有，个人理解其根本原则在于：<code>资源能否被控制住</code>，如果你的资源属于一个进程，那么就不会去限制你的超时，因为进程存在，控制进程就可以了，进程死了你也就死了；如果你已久脱离了进程的管辖，比如说孤儿状态下的FIN_WAIT_2，我们就不能让他活的太持久</p>
</li>
<li><p>可以理解对于一个状态要有超时，</p>
</li>
<li>对于孤儿的socket</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-loader_and_linker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/loader_and_linker/">linux系统下的链接&amp;加载</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/01/loader_and_linker/" class="article-date">
  <time datetime="2015-02-01T15:41:35.000Z" itemprop="datePublished">2015-02-01</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p><code>.a</code>文件，一大堆<code>.o</code>文件的组合体，对于系统库而言，一般一个<code>.o</code>文件对于一个函数<br>静态文件的链接世界上就是一大堆<code>.o</code>文件的代码的合并&amp;段合并（比如把<code>.text</code>段合并起来），组成一个新的目标文件;<br>其核心要解决的问题包括:</p>
<ul>
<li>符号重定位 ： 不同obj文件里面的地址在调整之后，需要调整对应的一些地址（函数地址，变量地址等）；解决方案是每个obj都有一个重定位段，用于记录需要重定位的地址和符号信息(<code>.rel.text</code>,<code>.rel.data</code>等 )</li>
<li>符号决策：强符号/弱符号</li>
</ul>
<p>总的来说，静态链接是比较简单，可以理解为就是简单的代码拷贝，加上基址重定位</p>
<h2 id="动态库实现"><a href="#动态库实现" class="headerlink" title="动态库实现"></a>动态库实现</h2><p>如上，静态库存在两个比较大的问题：</p>
<ul>
<li>bin文件对存储空间的浪费</li>
<li>执行时候对内存的浪费</li>
</ul>
<p>解决的思路很简单，就是让bin链接的库是动态加载的，一个简单的办法就是让上面做静态链接的过程放在程序的加载过程，也就是所谓的装载重定位(<code>-shared</code>标签)，但装载重定位存在一个问题就是，不同的bin的装载的地址不一致，导致加载进来的动态库的虚存地址也不一致，因此并不能起到节省内存的效果，如何解决呢？</p>
<p>方法就是让编译出来的so地址无关，这样无论应用程序把so装载到那个地方，所有的经常都能恭喜相同的代码段。</p>
<p>要生成地址无关的代码(<code>-fPIC</code>),解决也比较简单。由于每个so最终会主要包括两个段: text段和data段，其中text段是要共享的，data段是每个进程都会有的，而data和text的偏移量的固定的，因此所有的地址都可以先存在data段(<code>GOT表</code>)，然后访问的时候先去访问GOT表，获取真正的地址。</p>
<p>事实上，为了优化动态库的加载速度等，系统还做了一些比如延迟加载等技术，这里就不深入探讨。</p>
<h2 id="linux动态库的组织"><a href="#linux动态库的组织" class="headerlink" title="linux动态库的组织"></a>linux动态库的组织</h2><p>所谓的动态库的组织，其实就是要提供一个通用的机制方便其他elf文件加载&amp;链接，核心解决两个问题</p>
<h3 id="去哪里找"><a href="#去哪里找" class="headerlink" title="去哪里找"></a>去哪里找</h3><ol>
<li>系统路径: /lib, /usr/lib, /usr/loca/lib, 可以参看FHS规范</li>
<li>配置查找路径: 查看<code>ld.so.con</code>配置的路径</li>
<li>一些系统变量，比如LD_LIBRARY_PATH</li>
</ol>
<p>查找的规则顺序是3-&gt;2-&gt;1 </p>
<p>其他一些可以关注的点包括: LD_PRELOAD, LD_DEBUG, -rpath</p>
<h3 id="找哪个"><a href="#找哪个" class="headerlink" title="找哪个"></a>找哪个</h3><p>由于动态库可能会一直升级，基本我们找到了那个so，我们能否使用之，会不会版本太老或者太新等。为止，我们需要有相关的规范约定动态库能够被使用，具体来说，由如下三个部分沟通:</p>
<h4 id="so版本库概念"><a href="#so版本库概念" class="headerlink" title="so版本库概念"></a>so版本库概念</h4><p>具体约定每个so按照如下命名规则:</p>
<p>lib_name_.so._x_._y_._z_</p>
<ul>
<li>x : 主版本号,表示重大升级，不同主版本号可以不兼容</li>
<li>y : 次版本号，表示增量升级，新建一些接口，且会兼容老的版本</li>
<li>z : 发布版本号，一般表示库的错误的修正，不增加新的接口，兼容老版本</li>
</ul>
<p>由上，我们只要保证一个程序在查找so的时候满足如下规则即可:</p>
<ul>
<li>相同的主版本号</li>
<li>查找到次版本号高于或者等于程序需要的此版本号</li>
</ul>
<h4 id="so-name"><a href="#so-name" class="headerlink" title="so-name"></a>so-name</h4><p>so-name简单的说，就是表示一个程序要链接的so-name，so-name是可以让应用程序就记录<code>so-name</code>，而非具体的so的版本信息，故<code>so-name</code>主要定义如下:</p>
<ul>
<li>每个so-name 包括libname和主版本号信息，比如libtest.2，2是主版本</li>
<li>由于主版本不能保证指向的so能兼容所有程序，姑系统会让<code>so-name</code>指向该主版本对应的最高的此版本so,比如:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ll libtest.so.2</div><div class="line">libtest.so.2 -&gt; libtest.so.2.4.1 [2.4是最高的次版本]</div></pre></td></tr></table></figure>
<p>在ELF文件<code>.dynamic</code>段里面记录的链接库信息就是用的so-name</p>
<p>同时为了保证总能指向最新的此版本so，当so升级的时候，需要运行<code>ldconfig</code>去调整so-name对应的软连接</p>
<h4 id="符号版本机制"><a href="#符号版本机制" class="headerlink" title="符号版本机制"></a>符号版本机制</h4><p>so-name虽然能解决很大一部分问题，但是有时候，我们希望做更细粒度的控制，比如如果一个so升级了，但是其中部分函数没有修改，我们依旧希望这个部分的代码能被老版本的ELF使用，怎么做呢？很多简单，就是给每个符号加一个版本信息</p>
<p>当在linux gcc下面其实上述符号版本并没有大规模使用，gcc通报拆分so（glibc软件包提供了20多个共享库）,来达到细粒度控制so版本的目标。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>一些异类，主要是两类 最核心的so，包括:</p>
<ul>
<li>glibc :</li>
<li>ld : </li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-Distributed_systems_for_fun_and_profit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/25/Distributed_systems_for_fun_and_profit/">Distributed systems for fun and profit读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/01/25/Distributed_systems_for_fun_and_profit/" class="article-date">
  <time datetime="2015-01-25T08:26:33.000Z" itemprop="datePublished">2015-01-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>如果我们有足够的资金，我们大可以不使用什么分布式系统，把硬件弄的足够牛逼即可。</p>
<p>但是，不行。因此我们的愿景的采用商用的普通的服务器就能支持我们超大计算量，存储量的需求。</p>
<p>我们关注的是如果设计一个分布式的系统，我们的核心目标包括:</p>
<ul>
<li><p>可扩展性:</p>
</li>
<li><p>性能(或者说延迟):</p>
</li>
<li><p>可用性:</p>
</li>
</ul>
<p>而我们面临的挑战是:</p>
<p>主要有两个核心的物理因素:</p>
<ul>
<li>节点的个数:</li>
<li>节点的距离(主要是交互时延) ：</li>
</ul>
<p>受到上面两个因素的影响:</p>
<ol>
<li>节点个数的增加意味着系统里面节点失效概率的增加；</li>
<li>节点个数的增加意味着节点直接的交互也会增加;</li>
<li>而节点地理位置的间隔也意味着交互交互延迟的增加</li>
</ol>
<p>另外还有一个所谓的<code>智能性</code>，因为</p>
<p>如何做？</p>
<p>抽象&amp;建模</p>
<p>对于数据如何存储在分布式节点上面，两个核心的办法,包括:</p>
<ol>
<li>分片 : 可以将每一个节点上面的数据量减少；</li>
<li>复制<ul>
<li>优点: 冗余的话可以发挥多个节点的计算能力</li>
<li>优点: 冗余的话可以提高系统的容错性</li>
<li>缺点: 复制要求着数据拷贝，也就是意味着我们必须遵循一个特定的数据一致性模型（强一致，弱一致)?</li>
</ul>
</li>
</ol>
<h2 id="抽象和建模"><a href="#抽象和建模" class="headerlink" title="抽象和建模"></a>抽象和建模</h2><h3 id="系统条件和结果抽象"><a href="#系统条件和结果抽象" class="headerlink" title="系统条件和结果抽象"></a>系统条件和结果抽象</h3><p>系统模型，一个分布式系统意味着有如下特征:</p>
<ul>
<li>并行的计算和存储</li>
<li>节点直接通过网络交互</li>
<li>没有共享内存和全局时钟</li>
</ul>
<p>而我们在建立一个系统模型的时候，其实就是抽象和简化整个系统的特征，对于一个分布式系统，我们主要关心:</p>
<ul>
<li>节点拥有什么样的能力，他们什么时候会挂掉？<ul>
<li>一般只是crash</li>
<li>不考虑节点欺骗的情况，比如拜占庭问题 </li>
</ul>
</li>
<li>节点直接的交互状态是怎么样的？<ul>
<li>消息是否会丢弃：</li>
<li>是否会发生网络分区的情况</li>
</ul>
</li>
<li>系统的属性，比如消息发送的时序性<ul>
<li>同步系统:</li>
<li>异步系统: 消息的分发和处理都是无序的</li>
</ul>
</li>
</ul>
<p>基于如上三个核心属性的抽象，再引入一个结果的抽象： <code>一致性要求</code></p>
<h3 id="两个基本理论"><a href="#两个基本理论" class="headerlink" title="两个基本理论"></a>两个基本理论</h3><p>第一个是 FLP理论， 跳过<br>第二个是 CAP理论, 这个大家可能听到的比较多，具体为:</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><ul>
<li><p>强一致性</p>
</li>
<li><p>弱一致性</p>
<ul>
<li>基于client控制的一致性支持</li>
<li>最终一致性</li>
</ul>
</li>
<li><p><a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="external">CAP理论</a></p>
</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/8/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>