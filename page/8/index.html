<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/8/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-about_nginx_cve_2016_4450" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/about_nginx_cve_2016_4450/">关于nginx的CVE-2016-4450的安全问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/12/about_nginx_cve_2016_4450/" class="article-date">
  <time datetime="2016-06-12T07:34:36.000Z" itemprop="datePublished">2016-06-12</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于nginx的CVE-2016-4450的安全问题"><a href="#关于nginx的CVE-2016-4450的安全问题" class="headerlink" title="关于nginx的CVE-2016-4450的安全问题"></a>关于nginx的CVE-2016-4450的安全问题</h1><p>nginx在5-31凌晨发布了一个安全漏洞修复的说明: <a href="http://nginx.org/en/security_advisories.html" target="_blank" rel="external">NULL pointer dereference while writing client request body</a> , 关于漏洞的细节没有详述，仅仅在邮件里面说明如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">A special last buffer with cl-&gt;buf-&gt;pos set to NULL can be present in</div><div class="line">a chain when writing request body if chunked encoding was used.  This</div><div class="line">resulted in a NULL pointer dereference if it happened to be the only</div><div class="line">buffer left after a do...while loop iteration in ngx_write_chain_to_file().</div><div class="line"></div><div class="line">The problem originally appeared in nginx 1.3.9 with chunked encoding</div><div class="line">support.  Additionally, rev. 3832b608dc8d (nginx 1.9.13) changed the</div><div class="line">minimum number of buffers to trigger this from IOV_MAX (typically 1024)</div><div class="line">to NGX_IOVS_PREALLOCATE (typically 64).</div><div class="line"></div><div class="line">Fix is to skip such buffers in ngx_chain_to_iovec(), much like it is</div><div class="line">done in other places.</div></pre></td></tr></table></figure>
<p>这里简单说下具体这个crash的分析&amp;复现过程</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>从邮件和给予的<a href="http://nginx.org/download/patch.2016.write2.txt" target="_blank" rel="external">补丁</a>可以看出, 应该主要是如下核心代码出现问题:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* nginx 1.8.0 源码为例说明 */</span></div><div class="line"><span class="comment">/* 过滤了无关代码 */</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    prev = <span class="literal">NULL</span>;</div><div class="line">    iov = <span class="literal">NULL</span>;</div><div class="line">    size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    vec.nelts = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* create the iovec and coalesce the neighbouring bufs */</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (cl &amp;&amp; vec.nelts &lt; IOV_MAX) &#123;</div><div class="line">        <span class="keyword">if</span> (prev == cl-&gt;buf-&gt;pos) &#123;</div><div class="line">            iov-&gt;iov_len += cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            iov = ngx_array_push(&amp;vec);</div><div class="line">            <span class="keyword">if</span> (iov == <span class="literal">NULL</span>) &#123;</div><div class="line">                <span class="keyword">return</span> NGX_ERROR;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cl = cl-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span>(cl)</div></pre></td></tr></table></figure>
<p>从上面的代码，简单的静态分析可以看出(个人感觉), 如果<code>prev == cl-&gt;buf-&gt;pos</code> 都是NULL的话，<code>iov</code> 也肯定是NULL, 如果走这个流程，就会发生段异常, 从这个 <code>do {} while()</code> 的结构来看, 是存在这个可能性的</p>
<p>加上作者在邮件里面是阐述，大概可以猜测crash应该是如下条件会产生的:</p>
<ul>
<li>cl-&gt;buf-&gt;pos 为NULL : 满足条件是如果是input 是chunk编码, last_buf会是这样的</li>
<li>prev : 也为 NULL :  满足条件是从<code>do-while</code>循环进入</li>
</ul>
<p>第二个条件是触发条件应该是： 在第二，三等次进入外层的<code>do-while</code>循环的时候(第一次肯定不行), 也就是写完一个IOV_MAX的时候</p>
<p>所以总计下来构造如下特点的请求就可能导致nginx crash:</p>
<ul>
<li>输入包体为chunk</li>
<li>输入包体的大小正好让nginx在写文件的时候, 多次写iov数组的时候，出发临界条件</li>
</ul>
<p>下面就看我们如果构造此类请求了</p>
<h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p>在具体看请求构造的时候，先简单说明nginx输入请求包体读取流程;<br>在支持<code>transfer-encoding:chunked</code>的请求下，nginx会解析进来的请求，然后将输入的内容以如下的形式组织:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chain --------&gt;  chain ----------&gt; chain --------- chain</div><div class="line">   |               |                 |               |</div><div class="line">   |               |                 |               |</div><div class="line">   \/              \/                \/              \/</div><div class="line">   buf1            buf2              buf3            buf4 (last buf)</div></pre></td></tr></table></figure>
<p>其中<code>last_buf</code> 代表一个请求内容的结束, 每个buf缓存一部分数据</p>
<p>综上，如果要让他出现异常，只要让输入的请求，在nginx内部表针如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">chain --------&gt;  chain ----------&gt; chain ---(IOV_MAX)------- chain</div><div class="line">   |               |                 |                        |</div><div class="line">   |               |                 |                        |</div><div class="line">   \/              \/                \/                       \/</div><div class="line">   buf1            buf2              buf(IOV_MAX)          buf (last buf)</div></pre></td></tr></table></figure>
<p>基于次，我们来看看需要构造多大的包体来让nginx crash</p>
<h2 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h2><p>nginx内部有如下几个参数影响对请求包体的控制，如下 :</p>
<ul>
<li>client_max_body_size : 最大的body size</li>
<li>client_body_buffer_size : client body在内存的缓存大小，如果超过这个，就要write到文件</li>
</ul>
<p>所以第一步, 我们发送的包体大小要小于<code>client_max_body_size</code> 并且 大于<code>client_body_buffer_size</code> </p>
<p>第二步，我们需要构造的长度是约等于<code>IOV_MAX * buf</code> : </p>
<ul>
<li>正常在我们64位的linux机器上面可以理解buf大小大约是<code>16K</code>(具体为什么是16K还需要分析, 通过gdb可以看到)</li>
<li>IOV_MAX 在不同的平台value也不一样，在64位机器比较明显是1024</li>
</ul>
<p>所以我们需要构造的body，在我们的平台上面至少是 : <code>16K * 1024 = 16M</code>, 而且为了不让被拆到不同的chain, 我们的<br><code>client_body_buffer_size</code> 也要大于16M , 但是这样又反过来会导致数据全部在内存，不会写文件，所以我们要构造的具体包体大小是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">size = client_body_buffer_size + IOV_MAX * buf</div></pre></td></tr></table></figure>
<p>其中<code>client_body_buffer_size</code> 和 <code>IOV_MAX * buf</code> 还要去一些水分(给nginx的内部数据结构用，但是范围基本是确定了)</p>
<p>从上面的添加分析，可以看到其实要触发这个请求不容易，简单要求概括如下(在我们的机器平台上):</p>
<ul>
<li>client_body_buffer_size 配置大于 16M</li>
<li>client_max_body_size 大于 32M</li>
</ul>
<p>如下是具体的复现过程:</p>
<h2 id="请求复现"><a href="#请求复现" class="headerlink" title="请求复现"></a>请求复现</h2><p>如上，由于对<code>client_body_buffer_size</code>和<code>client_max_body_size</code> 有一定的要求，我们先构造如下一个nginx配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 8094;</div><div class="line">    access_log logs/access_log main;</div><div class="line"></div><div class="line">    underscores_in_headers on;</div><div class="line">    ignore_invalid_headers off;</div><div class="line">    client_body_buffer_size 20m;</div><div class="line">    client_max_body_size 60m;</div><div class="line">    root /home/users/chenjiansen/nginx_lua_access/dir_list;</div><div class="line">    location = /set_cache &#123;</div><div class="line">        lua_need_request_body on;</div><div class="line">        content_by_lua &apos; ngx.say(&quot;aaa&quot;)&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引入如下的gdb脚本，用于分析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">define print_nginx_chain</div><div class="line">    set $total = 0</div><div class="line">    set $index = 0</div><div class="line">    set $cur = $arg0</div><div class="line">    while $cur</div><div class="line"></div><div class="line">        if $cur-&gt;buf-&gt;last_buf</div><div class="line">            print &quot;end last in chain&quot;</div><div class="line">            loop_break</div><div class="line">        end</div><div class="line"></div><div class="line">        set $cur_size =  ($cur-&gt;buf-&gt;last - $cur-&gt;buf-&gt;pos)</div><div class="line">        set $total = $total + ($cur-&gt;buf-&gt;last - $cur-&gt;buf-&gt;pos)</div><div class="line">        printf &quot;%p,pos:%p, last:%p, index:%u, size:%u, total:%u \n&quot;, $cur, $cur-&gt;buf-&gt;pos, $cur-&gt;buf-&gt;last, $index,</div><div class="line"> $cur_size, $total</div><div class="line">        set $cur = $cur-&gt;next</div><div class="line">        set $index = $index + 1</div><div class="line">    end</div><div class="line"></div><div class="line">    print $total</div><div class="line">end</div></pre></td></tr></table></figure>
<p>开始测试, 如上，我们先随便构造一个范围区间在<code>36M</code> 左右的文件用于发送:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 创建36M文件 aaa</span></div><div class="line">dd <span class="keyword">if</span>=pb_temp_data  ibs=1 count=37721088 of=aaa</div><div class="line"></div><div class="line"><span class="comment"># 用curl发送，注意编码</span></div><div class="line">curl --data-binary @aaa  <span class="string">"127.0.0.1:8094/set_cache"</span> -H<span class="string">"transfer-encoding:chunked"</span></div></pre></td></tr></table></figure>
<p>在nginx的gdb设下如下断点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(gdb) b ngx_http_write_request_body</div><div class="line">(gdb) r</div><div class="line">Breakpoint 1, ngx_http_write_request_body (r=0xd5e170) at src/http/ngx_http_request_body.c:493</div><div class="line">493     rb = r-&gt;request_body;</div><div class="line">(gdb) n</div><div class="line">495     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,</div><div class="line">(gdb) print_nginx_chain_size rb-&gt;bufs</div><div class="line">$1 = 20961274</div></pre></td></tr></table></figure>
<p>可以看到第一个chain用了<code>20961274</code>字节, 再看下第二个chain:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    (gdb) print_nginx_chain rb-&gt;bufs</div><div class="line">    0xe2d6f0,pos:0x7fffe83dc010, last:0x7fffe83dec0a, index:0, size:11258, total:11258</div><div class="line">    0xe2d680,pos:0x7fffe83dec12, last:0x7fffe83dec52, index:1, size:64, total:11322</div><div class="line">    ---------</div><div class="line">    0x21f4e40,pos:0x1ddef8e, last:0x1de2f42, index:2044, size:16308, total:16743442</div><div class="line">--&gt; 0x21f4dd0,pos:0x1de2f4a, last:0x1de2f8a, index:2045, size:64, total:16743506 </div><div class="line">--&gt; 0x21f4d60,pos:0x1de2f8a, last:0x1de6f3e, index:2046, size:16308, total:16759814</div><div class="line">    0x21f4cf0,pos:0x1de6f46, last:0x1de6f86, index:2047, size:64, total:16759878</div><div class="line">    0x21f4c80,pos:0x1de6f86, last:0x1deaf3a, index:2048, size:16308, total:16776186</div><div class="line">    0x21f4c10,pos:0x1deaf42, last:0x1deaf6f, index:2049, size:45, total:16776231</div><div class="line">    0x21f4ba0,pos:0x1deaf6f, last:0x1dedb4e, index:2050, size:11231, total:16787462</div><div class="line">    $12 = &quot;end last in chain&quot;</div><div class="line">    $13 = 16787462</div></pre></td></tr></table></figure>
<p>关注index是<code>2045</code>和<code>2046</code>那一行，由于需要除以2（细节问题）, 所以可以判断<code>total:16743506</code>这个大小应该是边界条件，也就是说我们需要发送一个: <code>16743506 + 20961274 = 37704780</code></p>
<p>重新生成数据编译如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">dd <span class="keyword">if</span>=pb_temp_data  ibs=1 count=37721088 of=aaa</div><div class="line"></div><div class="line">curl --data-binary @aaa  <span class="string">"127.0.0.1:8094/set_cache"</span> -H<span class="string">"transfer-encoding:chunked"</span></div></pre></td></tr></table></figure>
<p>成功出core</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>总体上看配置需要满足一定的条件才能出发core</li>
<li>对于特定配置的文件，在不同平台，不同配置参数的情况下，出发的阈值并不一样，但是用户探测的成本也不算特别高</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_11_0" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/05/nginx_1_11_0/">nginx 1.11.0 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/05/nginx_1_11_0/" class="article-date">
  <time datetime="2016-06-05T15:16:20.000Z" itemprop="datePublished">2016-06-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一期的feature比较多，具体如下:</p>
<h2 id="feature说明"><a href="#feature说明" class="headerlink" title="feature说明"></a>feature说明</h2><ul>
<li>对于一些upstream，支持<code>transparent</code> bind, 比如 proxy_bind etc.</li>
<li>引入了新的变量<code>request_id</code>, <code>proxy_protocol_port</code> 和 <code>realip_remote_port</code>, 具体可以看: <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="external">http core variable</a></li>
<li>对<code>ngx_http_realip_module</code>的些许增强</li>
<li>安全相关的一些特性(待补充)</li>
<li>对EPOLLRDHUP特性的引入</li>
</ul>
<h3 id="upstream-addr-bind"><a href="#upstream-addr-bind" class="headerlink" title="upstream addr bind"></a>upstream addr bind</h3><p>可以先参看<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind" target="_blank" rel="external">proxy bind</a>指令的说明，引入<code>transparent</code>的主要特点是支持bind的话，只能是local IP address，现在可以支持绑定到非本地的ip地址, 不过这个需要比较高的权限</p>
<p>可以考虑的问题是: 为什么有些时候需要强制bind到某些Ip，有哪些可以应用的场景?</p>
<h3 id="ngx-http-realip-module增强"><a href="#ngx-http-realip-module增强" class="headerlink" title="ngx_http_realip_module增强"></a>ngx_http_realip_module增强</h3><p>包括：</p>
<ul>
<li>引入变量<code>realip_remote_port</code> : 记录客户端的端口信息</li>
<li>支持基于<a href="http://tools.ietf.org/html/3986" target="_blank" rel="external">RFC 3986</a>协议的端口信息，可以替换为真实的client port</li>
</ul>
<p>后者意味着，如果BFE支持，我们现在有能力可以拿到客户端的真实port, 而不仅仅是ip, 对于一些作弊之类的判断有一定的提升效果</p>
<h3 id="关于EPOLLRDHUP特性"><a href="#关于EPOLLRDHUP特性" class="headerlink" title="关于EPOLLRDHUP特性"></a>关于EPOLLRDHUP特性</h3><p>具体可以看这篇文章 <a href="http://no001.blog.51cto.com/1142339/1314657/" target="_blank" rel="external">EPOLL 事件之 EPOLLRDHUP</a> ，说是还是比较清楚的</p>
<p>简单来说，一些比较老的linux内核，对于close操作，是通过一个read信号触发的，所以我们应用程序判断对方close的情况，一般是做两个事情，一个是响应读信号，其实尝试去读，如果读到了EOF，则表明close</p>
<p>在新的内核里面，关闭操作是可以直接通过EPOLLRDHUP来标准的，这样在epoll层面，就能判断，可以减少业务的判别逻辑</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-weekly-of-20160605" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/05/weekly-of-20160605/">weekly of 20160605</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/05/weekly-of-20160605/" class="article-date">
  <time datetime="2016-06-05T15:15:29.000Z" itemprop="datePublished">2016-06-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><ul>
<li><p><a href="https://code.facebook.com/posts/1031317120284314/safety-check-streamlining-deployment-around-the-world/" target="_blank" rel="external">Safety Check: Streamlining deployment around the world</a> : facebook safety功能的实现机制，其中如何快速传播的思路很是精巧；同时，也可以感受到facebook对任何一个业务的技术上面的机制追求</p>
</li>
<li><p><a href="http://queue.acm.org/detail.cfm?id=2940294" target="_blank" rel="external">Debugging Distributed Systems</a> : 通过可视化的手段分析分布式系统的各种事件，文章不短，现在还没搞懂他和dapper系统的不同之处</p>
</li>
<li><p><a href="http://techblog.netflix.com/2016/04/its-all-about-testing-netflix.html" target="_blank" rel="external">It’s All A/Bout Testing: The Netflix Experimentation Platform</a> : netflix的文章, 先mark，周末再看</p>
</li>
<li><p><a href="http://tmq.qq.com/2016/06/test_online/" target="_blank" rel="external">利用线上数据提升移动app质量</a> : 个人比较认可的一个思路，随着移动互联网的发展，服务载体的app化，以及现在大数据的趋势，如何把这两个融合起来为产品的质量，体验提升更有用的保障的一个可以去review，思考的地方</p>
</li>
<li><p><a href="http://www.infoq.com/cn/articles/https-difficult" target="_blank" rel="external">HTTPS之难</a> : 作者具体介绍了在实施https的过程中遇到的一些问题，包括TLS性能相关的问题，referer信息等；文章整体还是比较接地气的</p>
</li>
</ul>
<h2 id="资料工具"><a href="#资料工具" class="headerlink" title="资料工具"></a>资料工具</h2><ul>
<li><p><a href="http://www.ha97.com/5702.html" target="_blank" rel="external">主流大数据采集平台的架构图解</a> : </p>
</li>
<li><p><a href="http://insights.thoughtworkers.org/ba-capability-and-development-path-in-thoughtworks/" target="_blank" rel="external">BA的广度和深度</a> : </p>
</li>
<li><p><a href="http://insights.thoughtworkers.org/bsi-app-developing/" target="_blank" rel="external">內建安全的软件开发</a> : 本文主要论证了在如下的移动互联网情况下，如何更好的做起安全的保障，提出服务的安全相关问题不应是一个事后的措施，而应该是整合到整个研发流程过程中的</p>
</li>
<li><p><a href="http://huoding.com/2011/07/13/91" target="_blank" rel="external">通过IOStat命令监控IO性能</a> : 关于IO的相关参数的详细说明</p>
</li>
<li><p><a href="http://www.infoq.com/cn/news/2016/05/big-data-machine-weekly-10" target="_blank" rel="external">大数据与机器学习周报 第10期：Twitter Heron正式开源</a> : infoq的关于大数据方面的资源list，感觉很不错, 值得收藏</p>
</li>
<li><p><a href="https://xituqu.com/207.html" target="_blank" rel="external">设计向 20+优秀的Icons图标合集</a> : mark, 画PPT的时候应该是需要用的</p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=512113734&amp;idx=1&amp;sn=868043069fee8ff6c95699ce5aae6658#rd" target="_blank" rel="external">Facebook开源软件列表</a> : 真心厉害，大部分开源的项目我们都耳熟能详，可以深入看的项目有<code>huxley</code>, <code>Stetho</code></p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-weekly-of-20160529" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/29/weekly-of-20160529/">weekly of 20160529</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/29/weekly-of-20160529/" class="article-date">
  <time datetime="2016-05-29T15:01:29.000Z" itemprop="datePublished">2016-05-29</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="新鲜事"><a href="#新鲜事" class="headerlink" title="新鲜事"></a>新鲜事</h2><ul>
<li><p><a href="http://tech.adroll.com/blog/data/2016/05/24/traildb-open-sourced.html" target="_blank" rel="external">Announcing TrailDB - An Efficient Library for Storing and Processing Event Data</a> : 关于event data数据存储的另外一个思路</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=11787152" target="_blank" rel="external">Same-site Cookies</a> : 新引入的”same-site”机制，通过次申明可以让浏览器在做跨越请求的时候，不携带目标域名的cookie，这个机制可以有效的解决CSRF的问题, 可以多看看<a href="https://news.ycombinator.com/item?id=11787152" target="_blank" rel="external">hacker news</a>上面讨论</p>
</li>
</ul>
<h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><ul>
<li><p><a href="http://techblog.netflix.com/2016/05/application-data-caching-using-ssds.html" target="_blank" rel="external">Application data caching using SSDs</a> : Netflix的文章，介绍如何支持全球的在线业务, 包括<a href="http://techblog.netflix.com/2016/03/global-cloud-active-active-and-beyond.html" target="_blank" rel="external">Global Cloud - Active-Active and Beyond</a></p>
</li>
<li><p><a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> : 关于浮点计算的说明，都是英文，先mark，需要找个中文快速理解下</p>
</li>
<li><p><a href="https://blog.benjojo.co.uk/post/ssh-port-fluxing-with-totp" target="_blank" rel="external">TOTP SSH port fluxing</a> : <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" target="_blank" rel="external">TOTP</a>(Time-based One-time Password Algorithm)类似于我们的ssh token,  不过作者是利用动态token作为port的前缀, 类似的技术可以参看<a href="https://en.wikipedia.org/wiki/Port_knocking" target="_blank" rel="external">Port knocking</a></p>
</li>
<li><p><a href="http://weibo.com/ttarticle/p/show?id=2309403978986932807291" target="_blank" rel="external">用最少的机器支撑万亿级访问，微博6年Redis优化历程</a> : 微博的redis落地实践，对一些常见的问题的处理方案&amp;思路</p>
</li>
<li><p><a href="http://xiezhenye.com/2013/02/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E8%BF%90%E8%A1%8C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84-rlimit.html" target="_blank" rel="external">动态修改运行中进程的 rlimit</a> : 主要介绍了可以动态调整运行程序的rlimit参数的办法，采用系统调用<code>prlimit</code>或者trick的gdb修改, 文中的gdb代码比较恶心，可以参考这篇文章里面<a href="https://gregchapple.com/updating-ulimit-on-running-linux-process/" target="_blank" rel="external">Updating ulimit on a running Linux process</a>, gdb的强大之处</p>
</li>
</ul>
<h2 id="资料工具"><a href="#资料工具" class="headerlink" title="资料工具"></a>资料工具</h2><ul>
<li><p><a href="http://weibo.com/ttarticle/p/show?id=2309403978201981434927" target="_blank" rel="external">云舒，一个技术至上者的理想主义</a> : 听闻其名，看过其文，每一个牛逼的人都是对其信念和追求的用不停息的坚持</p>
</li>
<li><p><a href="https://eigenstate.org/notes/regex-debug" target="_blank" rel="external">Eigenstate : Regex Debugging</a> : 用于调试正则表达式，真是牛逼</p>
</li>
<li><p><a href="http://synisma.neocities.org/perf_scale_cheatsheet.pdf" target="_blank" rel="external">Software Performance &amp; Scalability: A Cheatsheet</a> : 还不错</p>
</li>
<li><p><a href="http://www.jianshu.com/p/05de8f667eea" target="_blank" rel="external">顶尖程序员不同于常人的5个区别</a> : 简单的励志文章，需要一直督促自己</p>
</li>
<li><p><a href="https://github.com/lichuang/Lua-Source-Internal" target="_blank" rel="external">lichuang/Lua-Source-Internal</a> : lua的源码剖析，比云风之前的文章还要详细，好好学习(有空真想自己写个lua的VM)</p>
</li>
<li><p><a href="http://openresty.org/posts/dynamic-tracing/" target="_blank" rel="external">动态追踪技术漫谈</a> : by 章亦春, 比较科普的文章；非凡之人，必有非凡的魄力，非凡的坚持</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-first-blog-of-Hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/first-blog-of-Hexo/">first blog of Hexo</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/21/first-blog-of-Hexo/" class="article-date">
  <time datetime="2016-05-20T17:09:12.000Z" itemprop="datePublished">2016-05-21</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前主要采用jeklly 做blog生成器，不过由于之前的VPS有问题，现在算是直接没有了；真是令人忧伤</p>
<p>这个VPS一定要坚持下去:)</p>
<p>另外，这个周末，希望能讲之前的文章都迁移过来</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-weekly-of-20160522" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/19/weekly-of-20160522/">weekly of 20160522</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/19/weekly-of-20160522/" class="article-date">
  <time datetime="2016-05-19T04:34:36.000Z" itemprop="datePublished">2016-05-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>about weekly : 每周个人推荐的技术文章合集</p>
</blockquote>
<h2 id="新鲜事"><a href="#新鲜事" class="headerlink" title="新鲜事"></a>新鲜事</h2><h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><ul>
<li><p><a href="https://engineering.quora.com/Applications-of-NLP-at-Quora?share=1" target="_blank" rel="external">Applications of NLP at Quora</a> : 介绍NLPJ技术在Quora的具体应用实践，包括质量检测等</p>
</li>
<li><p><a href="https://imququ.com/post/enable-alpn-asap.html" target="_blank" rel="external">为什么我们应该尽快支持 ALPN？</a> : 本文具体说明了当要支持http/2的时候，需要依赖https的协商机制(NPN or ALPN),  继而说明对openssl lib的要求情况，科普文</p>
</li>
</ul>
<h2 id="资料工具"><a href="#资料工具" class="headerlink" title="资料工具"></a>资料工具</h2><ul>
<li><p><a href="http://blog.petrzemek.net/2016/04/06/things-about-vim-i-wish-i-knew-earlier/" target="_blank" rel="external">Things About Vim I Wish I Knew Earlier</a> : 介绍vim的一些技巧和思路，我个人觉得<code>set relativenumber</code>可以好好考虑</p>
</li>
<li><p><a href="http://madusudanan.com/blog/understanding-postgres-caching-in-depth" target="_blank" rel="external">Understanding caching in Postgres - An in-depth guide</a> : mark, postgres好像越来越受重视了，本文具体介绍postgres的cache机制</p>
</li>
<li><p><a href="http://tonybai.com/2016/05/16/understanding-unikernels/" target="_blank" rel="external">理解Unikernels</a> : <code>Unikernels</code> 重新定义了对软件栈的组织方式，全新的思维方式，可以考虑和<code>docker</code>的异同之处</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/nginx_1_9_13/">nginx 1.9.13 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/03/30/nginx_1_9_13/" class="article-date">
  <time datetime="2016-03-30T06:17:29.000Z" itemprop="datePublished">2016-03-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*) Change: non-idempotent requests (POST, LOCK, PATCH) are no longer</div><div class="line">passed to the next server by default if a request has been sent to a</div><div class="line">backend; the &quot;non_idempotent&quot; parameter of the &quot;proxy_next_upstream&quot;</div><div class="line">directive explicitly allows retrying such requests.</div><div class="line"></div><div class="line">*) Feature: the ngx_http_perl_module can be built dynamically.</div><div class="line"></div><div class="line">*) Feature: UDP support in the stream module.</div><div class="line"></div><div class="line">*) Feature: the &quot;aio_write&quot; directive.</div><div class="line"></div><div class="line">*) Feature: now cache manager monitors number of elements in caches and</div><div class="line">tries to avoid cache keys zone overflows.</div><div class="line"></div><div class="line">*) Bugfix: &quot;task already active&quot; and &quot;second aio post&quot; alerts might</div><div class="line">appear in logs when using the &quot;sendfile&quot; and &quot;aio&quot; directives with</div><div class="line">subrequests.</div><div class="line"></div><div class="line">*) Bugfix: &quot;zero size buf in output&quot; alerts might appear in logs if</div><div class="line">caching was used and a client closed a connection prematurely.</div><div class="line"></div><div class="line">*) Bugfix: connections with clients might be closed needlessly if</div><div class="line">caching was used.</div><div class="line">Thanks to Justin Li.</div><div class="line"></div><div class="line">*) Bugfix: nginx might hog CPU if the &quot;sendfile&quot; directive was used on</div><div class="line">Linux or Solaris and a file being sent was changed during sending.</div><div class="line"></div><div class="line">*) Bugfix: connections might hang when using the &quot;sendfile&quot; and &quot;aio</div><div class="line">threads&quot; directives.</div><div class="line"></div><div class="line">*) Bugfix: in the &quot;proxy_pass&quot;, &quot;fastcgi_pass&quot;, &quot;scgi_pass&quot;, and</div><div class="line">&quot;uwsgi_pass&quot; directives when using variables.</div><div class="line">Thanks to Piotr Sikora.</div><div class="line"></div><div class="line">*) Bugfix: in the ngx_http_sub_filter_module.</div><div class="line"></div><div class="line">*) Bugfix: if an error occurred in a cached backend connection, the</div><div class="line">request was passed to the next server regardless of the</div><div class="line">proxy_next_upstream directive.</div><div class="line"></div><div class="line">*) Bugfix: &quot;CreateFile() failed&quot; errors when creating temporary files on</div><div class="line">Windows.</div></pre></td></tr></table></figure>
<p>这一期的feature和功能还是很多的，下面重点说明几个: </p>
<h2 id="upstream-重试策略"><a href="#upstream-重试策略" class="headerlink" title="upstream 重试策略"></a>upstream 重试策略</h2><p>这个问题的背景初现于<a href="https://trac.nginx.org/nginx/ticket/488#comment:4" target="_blank" rel="external">proxy_next_upstream_action to distinguish different network actions</a>, 整体意思是: 默认情况下，nginx对于upstream的重试，是不加以区别的，尤其对于一些非幂等操作的请求(PUT, LOCK, PATCH)也是如此，这样的策略对业务可能存在一定的风险, 所以需要加以控制，如下是新的<code>proxy_next_upstream</code>的说明 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* non_idempotent</div><div class="line">normally, requests with a non-idempotent method (POST, LOCK, PATCH) are not passed to the next server if a request has been sent to an upstream server (1.9.13); enabling this option explicitly allows retrying such requests</div></pre></td></tr></table></figure>
<p>也就是从<code>1.9.13</code> 版本开始，nginx默认不会重试一个已经发出去的POST请求, 需要通过<code>non_idempotent</code> 进行控制</p>
<blockquote>
<p>!!! : 这个和贴吧现有的策略不一致，迁移的时候需要注意</p>
</blockquote>
<h2 id="aio-write"><a href="#aio-write" class="headerlink" title="aio_write"></a>aio_write</h2><p>这个指令允许，我们在写文件的时候，也是一个异步的过程，之前的<code>aio</code>主要是允许读操作进行异步，具体<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#aio_write" target="_blank" rel="external">官方解释</a>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">If aio is enabled, specifies whether it is used for writing files. Currently, this only works when using aio threads and is limited to writing temporary files with data received from proxied servers</div></pre></td></tr></table></figure>
<p>注意 : 现在异步写只是在接收proxy的返回包体使用的，其他地方并未开启</p>
<p>关于nginx的异步文件IO机制，具体可以见之前的一篇文章 : <a href="http://nginx.baidu.com/book/nginx_dev_manual/internal/io_in_linux_and_nginx.html" target="_blank" rel="external">linux和nginx下的异步文件IO管理</a></p>
<h2 id="UDP-Proxy支持"><a href="#UDP-Proxy支持" class="headerlink" title="UDP Proxy支持"></a>UDP Proxy支持</h2><p>这个版本开始，同样开始支持UDP代理了, 整个UDP代理其实和做一个TCP代理，至少理解上面不会查很多，如下是一个具体UDP代理的配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">53</span> udp;</div><div class="line">    <span class="attribute">proxy_responses</span> <span class="number">1</span>;</div><div class="line">    <span class="attribute">proxy_timeout</span> <span class="number">20s</span>;</div><div class="line">    <span class="attribute">proxy_pass</span> dns.example.com:<span class="number">53</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面可以去思考的一个问题是:   </p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/nginx_1_9_10/">nginx 1.9.10 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/30/nginx_1_9_10/" class="article-date">
  <time datetime="2016-01-30T06:17:29.000Z" itemprop="datePublished">2016-01-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">*) Security: invalid pointer dereference might occur during DNS server</div><div class="line">       response processing if the &quot;resolver&quot; directive was used, allowing an</div><div class="line">       attacker who is able to forge UDP packets from the DNS server to</div><div class="line">       cause segmentation fault in a worker process (CVE-2016-0742).</div><div class="line"></div><div class="line">*) Security: use-after-free condition might occur during CNAME response</div><div class="line">       processing if the &quot;resolver&quot; directive was used, allowing an attacker</div><div class="line">       who is able to trigger name resolution to cause segmentation fault in</div><div class="line">       a worker process, or might have potential other impact</div><div class="line">       (CVE-2016-0746).</div><div class="line"></div><div class="line">*) Security: CNAME resolution was insufficiently limited if the</div><div class="line">       &quot;resolver&quot; directive was used, allowing an attacker who is able to</div><div class="line">       trigger arbitrary name resolution to cause excessive resource</div><div class="line">       consumption in worker processes (CVE-2016-0747).</div><div class="line"></div><div class="line">*) Feature: the &quot;auto&quot; parameter of the &quot;worker_cpu_affinity&quot; directive.</div><div class="line"></div><div class="line">*) Bugfix : ...</div></pre></td></tr></table></figure>
<p>可以看到主要是几个安全问题的修复，以及一个新的feature的支持; 下面简单说明这个两个点</p>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>几个安全问题都是关于<code>resolver</code>指令，主要问题在于在解析DNS时需要对异常有更强的容错能力，风险点包括如下:</p>
<ul>
<li>DNS的服务伪造一个UDP包体可以导致nginx crash</li>
<li>其他的异常情况导致的nginx crash</li>
</ul>
<p>今天问题自己总结如下:</p>
<p>当我们使用<code>resolver</code>指令的时候，nginx需要和dns服务器进行交互，以便获取具体域名对应的IP; 整个这个交互的过程是nginx自己编码和dns服务交互,  这样存在的一个问题是一旦nginx的容错逻辑有问题，尤其是和外界的dns服务交互的时候，一旦这个DNS服务器可以恶意伪造请求的时候, 比如返回不正常的body的时候, nginx容错一旦处理有点偏颇，就会crash</p>
<p>所以这种情况一般会出现在: <code>配置了resolver指令，且对于的dns服务器不可信</code></p>
<blockquote>
<p>具体可以见 : <a href="http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html" target="_blank" rel="external">http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html</a></p>
</blockquote>
<h2 id="worker-cpu-affinity指令优化"><a href="#worker-cpu-affinity指令优化" class="headerlink" title="worker_cpu_affinity指令优化"></a>worker_cpu_affinity指令优化</h2><p>这个指令的功能比较简单，就是可以自动设置cpu的亲和性, demo如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">worker_cpu_affinity</span> auto;</div></pre></td></tr></table></figure>
<p>具体代码的实现还是比较简单的，不再赘述</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_keepalive_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/tcp_keepalive_proxy/">让nginx支持TCP长连接代理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/19/tcp_keepalive_proxy/" class="article-date">
  <time datetime="2016-01-19T06:17:30.000Z" itemprop="datePublished">2016-01-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">              -----&gt; LCS </div><div class="line">            /</div><div class="line">Client(PHP) -------&gt; LCS</div><div class="line">            \</div><div class="line">             ------&gt; LCS</div></pre></td></tr></table></figure>
<p>如上，我们客户端需要和LCS交互，正常情况下，由于PHP比较难做长链接(当然RAL后续可以做长连接的支持)，所以现在每次和LCS交互，都需要建立一次TCP连接，然后做数据传输；现在问题是，如果LCS在其他的IDC，这样client和LCS每次都得做一次跨机房的三次握手, 这样对服务稳定性等都有一定的影响</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                        -----&gt; LCS </div><div class="line">                      /</div><div class="line">Client(PHP)---&gt; Proxy -------&gt; LCS</div><div class="line">                      \</div><div class="line">                        ------&gt; LCS</div></pre></td></tr></table></figure>
<p>一个方案是如上，加上一个proxy，这个Proxy的作用是和LCS维护一个长连接，和client保持短连接，同时让Client和Proxy部署在一个IDC, Proxy和LCS可以跨IDC；此时Proxy和LCS的由于是长连接交互，不必要每次都有个跨IDC的三次握手, 但也有如下的问题:</p>
<ul>
<li>增加了一层，意味着多一层网络交互，</li>
<li>长连接的跨IDC交互有可能也避免不了跨IDC的网络异常问题</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如上，上面的proxy，其实就是我们说的nginx proxy, 现在的问题是nginx虽然支持简单的tcp proxy，但是并不支持downstream是短链接，然后upstream是长连接(upstream和downstream的长短链接必须一致), 但是我们知道nginx http模块里面是有一个keepalive模块的，所以技术上面应该问题不大的，我们要做的就是把那个东西迁移过来, 具体如下:</p>
<h3 id="关于nginx-HTTP-长连接"><a href="#关于nginx-HTTP-长连接" class="headerlink" title="关于nginx HTTP  长连接"></a>关于nginx HTTP  长连接</h3><ul>
<li>内部实现 : <a href="http://blog.csdn.net/gzh0222/article/details/8523635" target="_blank" rel="external">http://blog.csdn.net/gzh0222/article/details/8523635</a></li>
<li>大概思路 :<ul>
<li>对于一个具体的upstream，可以设置其connection pool的size</li>
<li>每次需要访问upstream的时候，先去connection pool里面查找, 如果存在，就用改连接；否则新建一个连接</li>
<li>当访问结束的时候, 不主动断开连接，而且放回到连接池; 如果连接池是满的，需要释放最老的无用的连接(LRU)</li>
</ul>
</li>
</ul>
<h3 id="配置demo"><a href="#配置demo" class="headerlink" title="配置demo"></a>配置demo</h3><p>依照http upstream keepalive module的工作原理，我们编写了一个tcp upstream keepalie模块，具体代码请见<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">ngx_stream_keepalive_module</a></p>
<p>如下是简单的配置demo</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> stream_test &#123;</div><div class="line">        <span class="comment"># 设置连接池的大小, 用法同http upstream keepalive module</span></div><div class="line">        <span class="attribute">keepalive</span> <span class="number">10</span>;</div><div class="line">        <span class="attribute">server</span> yf-forum-rdcjs1.yf01.baidu.com:<span class="number">12388</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">12345</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> stream_test;</div><div class="line">        <span class="attribute">proxy_protocol</span> <span class="literal">on</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题-amp-思路"><a href="#问题-amp-思路" class="headerlink" title="问题&amp;思路"></a>问题&amp;思路</h3><p>一旦加入一个proxy，我们其实又面临一个问题，以上图为例，就是LCS如何获取真正的client ip? </p>
<p>像http协议的代理，一般会在应用层做这个事情，比如说通过<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html" target="_blank" rel="external">ngx_http_realip_module</a> 把相关的信息放到header里面，这样是能满足业务需求的; 那tcp proxy怎么办?</p>
<p>像TCP层一下的代理，比如说<a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server" target="_blank" rel="external">LVS</a>一般会需要<a href="http://www.just4coding.com/blog/2015/11/16/toa/" target="_blank" rel="external">内核的支持</a>，以便我们正确的获取客户端的IP，感觉解决方案都是挺重的</p>
<p>一个简单的方案是<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">The PROXY protocol</a>, 这个协议原理&amp;思路非常简单，就是在协议代理，新建连接的时候，会传输具体的代理信息。比如按照上图，当<code>Proxy</code>和<code>LCS</code>建立连接的时候，他做的第一个事情是发送一个文本信息，告诉<code>LCS</code>相关的client信息，大概如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PROXY TCP4 192.168.0.1 192.168.0.11 56324 443</div></pre></td></tr></table></figure>
<p>所以此时客户端需要修改其读取逻辑，在首次连接之后，需要尝试去读取proxy的信息，如果存在，就可以做一些具体的解析</p>
<p>同时，也要求proxy做一些修改，在发送请求给后端的时候，需要额外带上这些信息，具体可以通过<a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_protocol" target="_blank" rel="external">proxy_protocol</a>这个指令控制;</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">nginx stream module官方链接</a></li>
<li><a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol具体说明文档</a> </li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/10/tcp_proxy/">关于nginx的tcp代理支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/10/tcp_proxy/" class="article-date">
  <time datetime="2016-01-10T06:17:31.000Z" itemprop="datePublished">2016-01-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP代理简述"><a href="#TCP代理简述" class="headerlink" title="TCP代理简述"></a>TCP代理简述</h2><p>所谓的TCP proxy是一个用于代理tcp协议的中间代理；比如类似我们的http代理, 我们的mysqlproxy等; tcp代理相比于其他的proxy，具有如下特征:</p>
<ul>
<li>由于TCP代理是传输层的代理，所以能支持更多的业务，无论是http, mysql, redis, websocket等应用层协议他都能代理</li>
<li>由于TCP代理是底层的协议，所以虽然能代理，但是对业务的控制能力也变弱(只能拿到传输层的信息): 比如我们不能像http代理那样，通过cookie，refer做请求的转发和控制</li>
</ul>
<p>其实，我们也可以把他理解为一个LVS, 或者公司内的BGW(他们是IP层的负载均衡代理); 但是又比他们稍微高一点</p>
<p>如下是简单的一个不同网络层的软件的示范:</p>
<table>
<thead>
<tr>
<th>网络层</th>
<th>具体软件/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td>LVS, BGW</td>
</tr>
<tr>
<td>TCP</td>
<td>haproxy, nginx</td>
</tr>
<tr>
<td>HTTP</td>
<td>nginx, haproxy</td>
</tr>
</tbody>
</table>
<h2 id="nginx的TCP代理功能简述"><a href="#nginx的TCP代理功能简述" class="headerlink" title="nginx的TCP代理功能简述"></a>nginx的TCP代理功能简述</h2><p>nginx是从1.9.0版本开始支持tcp代理, 称之为<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">stream</a>模块, 发展到现在的1.9.9版本, 已经初步具备了tcp proxy的功能了, 如下是一个简单的nginx stream配置; 可以注意到:</p>
<ul>
<li>tcp代理是一个stream模块, 要放在stream段</li>
<li>http里面的很多功能，比如access_log, realip 等都不能使用(可以思考为什么)</li>
</ul>
<p>通过下面的配置，我们就可以实现一个mysql的proxy，自动做几个db的负载均衡；图来自于<a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">nginx官方文档</a></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> db &#123;</div><div class="line">        <span class="attribute">server</span> db1:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db2:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db3:<span class="number">3306</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> db;</div><div class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">1s</span>; <span class="comment"># detect failure quickly</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>架构示意图:</p>
<p><img src="./nginx-plus-load-balancing.png" alt="nginx tcp proxy demo"></p>
<h2 id="关于nginx-tcp代理注意点"><a href="#关于nginx-tcp代理注意点" class="headerlink" title="关于nginx tcp代理注意点"></a>关于nginx tcp代理注意点</h2><p>如果你准备要写一个nginx stream模块的扩展，你会发现和之前的http差异会比较大，下面简单说几点现在写stream proxy总结的一些问题</p>
<h3 id="文档未稳定"><a href="#文档未稳定" class="headerlink" title="文档未稳定"></a>文档未稳定</h3><p>现在nginx还没文档化nginx stream扩展的具体开发模式，从源码上面查看，nginx也是一直在调整，比如1.9.0和1.9.9的module定义就有所不同，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.9.0 源码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 1.9.9 源码, 多了 postconfiguration 定义</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* postconfiguration */</span> </div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到, 连核心的module定义都有所调整, 所以这个方面估计还需要进一步观察</p>
<h3 id="调试有一定的成本"><a href="#调试有一定的成本" class="headerlink" title="调试有一定的成本"></a>调试有一定的成本</h3><p>要注意到我们现在是在写tcp proxy，所以之前用于调试的curl, access_log都不能直接使用了; 依照我现在的个人经验，推荐大家熟悉如下两个工具:</p>
<ul>
<li>nc : arbitrary TCP and UDP connections and listens<ul>
<li>作为server端，可以尝试 : nc -lk </li>
<li>作为client端，可以尝试 : echo “xxx” | nc {host} {port} 或者 nc {host} {post} (后者会保持长连接)</li>
</ul>
</li>
</ul>
<p>nc 可以让我们非常简单的去发送tcp的包体，用于作为我们测试的原始流量, 也可以非常简单的搭建一个tcp server</p>
<ul>
<li>tcpdump :<ul>
<li>命令大概如下(最基本的) : tcpdump -vvv -nn -X -i any (host 10.46.178.51 and port 12388)(condition)</li>
<li>要求对tcp的协议交互有较深的理解, 各种flag</li>
</ul>
</li>
</ul>
<p>关于nc和tcpdump, 文章的末尾给了几个链接，是非常适合系统性学习的</p>
<h3 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h3><p>由于tcp proxy的特殊性，导致其现在还不大方便有类似http模块access_log的日志(http有请求的概念，但是tcp没有); 所以tcp proxy的日志基本上都是通过error log体现的<br>贴吧线上的常规日志级别是notice, 如果我们要观察比如一个client连接，发送多少数据之类的，建议把日志级别调成<code>info</code>级别; 如下是大概的info级别的日志信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 client 127.0.0.1:45607 connected to 0.0.0.0:12345</div><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 proxy 10.46.178.51:60713 connected to 10.36.89.18:12388</div><div class="line">2016/01/10 00:32:49 [info] 9530#0: *13 client disconnected, bytes from/to client:16/0, bytes from/to upstream:0/16</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于tcpdump的:</p>
<ul>
<li><a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="external">A tcpdump Primer with Examples</a> :  tcpdump工具非常不错的说明，便于理解</li>
<li><p><a href="https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/" target="_blank" rel="external">UDP/TCP Checksum errors from tcpdump &amp; NIC Hardware Offloading</a> : 关于tcpdump的<code>incorret chksum</code>问题说明</p>
</li>
<li><p><a href="http://www.thegeekstuff.com/2012/04/nc-command-examples/" target="_blank" rel="external">8 Practical Linux Netcat NC Command Examples</a></p>
</li>
</ul>
<p>关于tcpproxy的文章:</p>
<ul>
<li><p><a href="https://www.nginx.com/resources/admin-guide/tcp-load-balancing/" target="_blank" rel="external">TCP LOAD BALANCING</a> : nginx官方blog，介绍如何具体配置nginx</p>
</li>
<li><p><a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">MySQL High Availability with NGINX Plus and Galera Cluster</a> : 一个tcp proxy的具体demo，用于做mysql的复杂均衡</p>
</li>
</ul>
<p>下一篇文章会介绍<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">tcp proxy长连接</a>的实现；已经<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol</a>的情况以及使用</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>