<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/13/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-distribute_store_system" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/10/distribute_store_system/">分布式存储系统总结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/01/10/distribute_store_system/" class="article-date">
  <time datetime="2015-01-10T08:20:03.000Z" itemprop="datePublished">2015-01-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>分布式存储系统VS单机存储: 存储在多个机器!!!</p>
<p>引发的问题:</p>
<p>原来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client --&gt; store system</div></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client ___&gt; st1</div><div class="line">        \_&gt; st2</div><div class="line">        \_&gt; st3</div></pre></td></tr></table></figure>
<ol>
<li>存储的分布式: 哪种策略做分布式(client-&gt;st的策略)：负载均衡，支持扩展性;</li>
<li>容错性: st1,st2…容易出现异常，系统需要具有容错的能力;</li>
<li>事务性的支持: 传统单机的事务保证如果在分布式系统给予支持;</li>
</ol>
<h2 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h2><p>根据具体的存储数据模式，对整个系统的设计也相差很大，下面是一个简单的划分:</p>
<ol>
<li>分布式文件系统:</li>
<li>分布式键值系统：</li>
<li>分布式表格系统:</li>
<li>分布式数据库:</li>
</ol>
<p>个人理解，上面四个系统的功能逐渐复杂，系统设计也是依次复杂;</p>
<h2 id="核心协议"><a href="#核心协议" class="headerlink" title="核心协议"></a>核心协议</h2><blockquote>
<p>个人理解</p>
</blockquote>
<p>核心协议拥有抽象分布式系统常见的问题，并且提供一个通用的解决方案，这里面主要说到两个比较重要的协议</p>
<p>### </p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-rsync_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/30/rsync_bitch_about/">由rsync命令引发的</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/30/rsync_bitch_about/" class="article-date">
  <time datetime="2014-12-29T16:57:41.000Z" itemprop="datePublished">2014-12-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在鼓捣静态集群，而rsync是我们用于同步不同机器之间文件的一个最为传统的方式，因此认真研究了一遍，到现在总得有两个收获：</p>
<ul>
<li>rsync的算法</li>
<li>对常见命令的使用感概</li>
</ul>
<h2 id="rsync算法"><a href="#rsync算法" class="headerlink" title="rsync算法"></a>rsync算法</h2><p>先简单说下rsync的算法吧，这个其实在很多blog都有，这边我简单描述下，不过希望是以推敲的方式导出:</p>
<p>假设我们现在要同步两个文件src(机器 FROM )和dst(机器 TO)，他们在不同的机器上面，现在rsync算法核心要解决的问题是:</p>
<blockquote>
<p>在src和dst文件相似的情况下，尽量少的带宽来同步问题</p>
</blockquote>
<p>基于这个目标，算法的核心思路其实就是在src尽量发现dst已经存在的内容（这样就不需要传输了呗）</p>
<p>因此最好有个算法能够把dst的摘要传输到src这边；然后src能够比对dst哪些是已经存在的，哪些是不存在的；基于此在TO机器上面生成目标问题；故简单算法如下:</p>
<ol>
<li>TO机器上面，对dst文件算相关摘要，然后发给FROM机器</li>
<li>FROM机器根据摘要，分析出dst哪些部分是和src一致的，哪些是不一致的；不一致的需要全部传输，一直的只要发送标记就可以了, 算好之后，生成一个新的文件信息，发给TO机器</li>
<li>TO机器跟进新的文件信息，构建新的目标问题</li>
</ol>
<p>这个是核心思路，剩余两个问题：</p>
<ul>
<li>摘要的计算： 一般需要分段&amp;hash校验</li>
<li>src如何快速和dst的摘要做对比，同样需要注意：<ol>
<li>src这边的匹配，需要支持快速的从(k1,k2,…kn) –&gt; (k2,k3,…k(n+1)) ：这样才支持src这边一个一个比对</li>
<li>dst过来的时候，最好对摘要（很多摘要）算相关的hash，这样的话，src可以快速知道摘要是否在dst存在;</li>
</ol>
</li>
</ul>
<p>对于前者，我们需要引入一个一个类似<code>rolling hash</code>的特定hash算法；对于后者，我们一般在hash是一个方式，其他的快速排序好的查找也是一个方式；</p>
<h2 id="对常用命令的感慨"><a href="#对常用命令的感慨" class="headerlink" title="对常用命令的感慨"></a>对常用命令的感慨</h2><ul>
<li>很多命令了解仅限于表面</li>
<li>对常用的命令没有做很好的系统归纳和梳理</li>
</ul>
<p>尤其是后者，争取找个时间弄个和linux命令相关的总结</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://coolshell.cn/articles/7425.html" target="_blank" rel="external">http://coolshell.cn/articles/7425.html</a> : 对rolling sum说明的有点问题</li>
<li><a href="http://rsync.samba.org/tech_report/tech_report.html" target="_blank" rel="external">http://rsync.samba.org/tech_report/tech_report.html</a> 作者是算法说明</li>
<li><a href="http://en.wikipedia.org/wiki/Rsync#Algorithm" target="_blank" rel="external">http://en.wikipedia.org/wiki/Rsync#Algorithm</a> 维基百科的说明，一直都很专业</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-linux_lock_impl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/linux_lock_impl/">linux 常见锁说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/27/linux_lock_impl/" class="article-date">
  <time datetime="2014-12-27T07:02:14.000Z" itemprop="datePublished">2014-12-27</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前一次的文章<a href="http://shevacjs.com/lock/2014/12/13/lock/">锁机制概述</a>，大致简单说明了MP系统下面锁的基本原理。这里，再简单说明下在2.6内核体系下面，linux支持的锁，包括内核态和用户态(pthread系列的)。</p>
<h2 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是最基本的锁支持，在linux内核下，自旋锁的API有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irqsave</span><span class="params">(<span class="keyword">spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></div></pre></td></tr></table></figure>
<p>其中<code>irqsave</code>和<code>bh</code>都是处理和中断有关的，因为在中断等上下文一旦处理不好就可能导致死锁。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量可以任务是提供一个支持睡醒的锁支持，</p>
<h3 id="基于性能优化的衍生锁"><a href="#基于性能优化的衍生锁" class="headerlink" title="基于性能优化的衍生锁"></a>基于性能优化的衍生锁</h3><p>这里主要介绍两种, 他们都是针对读写锁的优化，一般都是只试用在一般的场景，这简单说明他们的设计思路。</p>
<ul>
<li>Seq Lock :</li>
</ul>
<p>seq lock考虑的场景是读多写少。因此在正常读取的时候，如果加上spinlock的收益是非常低的，故其采取如下策略:</p>
<ul>
<li>允许多个读者同时访问数据，同时只允许一个写者在更新数据；</li>
<li>核心指导思想是，通过一个flag来标记要保护的区段的数据是否被更新过，读者可以冲入的读，但需要通过flag来判别是否数据被更新过，如果是，读者需要重新读取新的数据，故读，写者分工如下:<ul>
<li>读者：读取之后，判断flag，以决定是否需要重新读取</li>
<li>写者：在修改数据的时候需要更新flag</li>
</ul>
</li>
</ul>
<p>如下是简单的示意图：其中读者需要判断<code>((count_pre != count_post) &amp;&amp; (count_pre % 2 == 0))</code>来决定数据是否被更新/正在被更新</p>
<p><img src="seqlock_demo.png" alt="seqlock_demo"></p>
<ul>
<li>Rcu Lock</li>
</ul>
<p>RCU也是对读写锁的一个优化，适用的场景也是读多写少，但是有其独特的应用场景，先考虑seqlock存在的问题：</p>
<ul>
<li>seq-lock可以认为是写优先的，读需要重复频繁的读来确认数据没有被更新；</li>
<li>seq-lock保护的数据一般是要求不能含有指针的，因为写者很容易直接更新指针的内容，demo如下:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">char</span>* info;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// sql-lock reader</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    data copy_data = curr_data;</div><div class="line">&#125; <span class="keyword">while</span>(no change)</div><div class="line"></div><div class="line"><span class="comment">// do something with copy data</span></div><div class="line"></div><div class="line">f(copy_data)</div></pre></td></tr></table></figure>
<p>这个里面的copy data其实是可能存在问题的,其对应的info等内容是会被修改的，而这个情况又是内核里面最最常见的场景，需要有更好的解决方案，RCU就是要提供这种支持的，RCU的特性包括：</p>
<ul>
<li>RCU是读者优先的，读者不需要任何互斥也不需要任何锁，直接读取就OK；</li>
<li>写者的核心指导思想是(Read-Copy Update), 写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。</li>
</ul>
<p>思路是比较简单的，但是实现上面还是比较复杂的，这里就不详述，具体可以参考推荐的RCU文章;</p>
<h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><h2 id="锁的资源消耗"><a href="#锁的资源消耗" class="headerlink" title="锁的资源消耗"></a>锁的资源消耗</h2><h2 id="遗留问题-amp-思考"><a href="#遗留问题-amp-思考" class="headerlink" title="遗留问题&amp;思考"></a>遗留问题&amp;思考</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><ul>
<li>seqlock,rcu等的维基百科，都有非常系统的介绍</li>
<li><a href="http://blog.sina.com.cn/s/blog_5210e67e0100935d.html" target="_blank" rel="external">Linux 内核的同步机制，第4部分顺序锁（seqlock</a></li>
<li><a href="http://www.verydemo.com/cj.jsp?c=34&amp;u=linuxseqlockamprcu-qian-xi-duo-xian-cheng-zhi-shun-xu-suo" target="_blank" rel="external">linux seqlock &amp; rcu 浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/" target="_blank" rel="external">Linux 2.6内核中新的锁机制–RCU</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-lockfree/" target="_blank" rel="external">透过 Linux 内核看无锁编程</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-1226_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/1226_bitch_about/">1227吐槽</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/27/1226_bitch_about/" class="article-date">
  <time datetime="2014-12-26T17:01:06.000Z" itemprop="datePublished">2014-12-27</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是2014-12-27凌晨1点左右，又是半夜，发现睡前吐槽是个好习惯。</p>
<p>明天就是周六了，早上可以好好睡一觉的吧，这是我现在能想到最开心的事情了。</p>
<p>这周忙的要死，基本上每天一到公司，就像陀螺一直在转一样，还有一些乱七八糟的事情，但很多事情走没有预想中的顺利，唉，都不知怎么办，只能自己一个一个搞，希望自己能坚持下去。</p>
<ul>
<li>周一周二忘了干嘛了。。。</li>
<li>周三：上午CBG-BIT技术培训，交流ksarch规划，讨论静态集群事情，讨论运维的事情</li>
<li>周四：上午server端RD例会，下午思考明年规划，然后3个小时讨论明年规划</li>
<li>周五：上午例会，静态文件处理，下午静态集群交流，CDN沟通，运维跟进，报警跟进</li>
</ul>
<p>今天周五也不是那么太平，一直在跟一个客户端的问题，20：30左右的时候才搞完，然后跑去球场的时候都快20：50了，踢了差不多40分钟的球，意兴阑珊的回来，才发现肚子好饿。最讨厌的就是，小区门口基本上没有一个可以吃饭的地方，尤其是供一个人吃饭的地方，弄的我现在特讨厌周末吃饭，选择困难啊。</p>
<p>这两天得花个时间写自己工作上面的年度总结，其实自己心里默想了，唉，失多得少，悲大于喜，也不知作何言。</p>
<p>当然也有开心的事情，晚上六点多的时候，我妈电话我了，我妹生了个女儿，不过我还不知道如何称呼之:)</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-an_problem_about_so_copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/23/an_problem_about_so_copy/">一个so不能copy引发的问题&amp;思考</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/23/an_problem_about_so_copy/" class="article-date">
  <time datetime="2014-12-22T17:23:09.000Z" itemprop="datePublished">2014-12-23</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题的背景其实比较简单，也很常见，就是如果一个bin文件，通过<code>dlopen</code>的方式打开so，继续连接的时候；在程序进行升级的时候，如果bin文件还在执行，不能简单的copy，一般是需要用mv之类的方法，否则很容易出core。</p>
<p>这是为什么呢？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先比较cp命令和mv命令的区别，大致如下：</p>
<ul>
<li>cp –&gt; open(O_WRONLY | O_TRUNC) : 原来文件的inode不变，修改内容</li>
<li>mv –&gt; unlink | create ：删除原来文件, inode 失效</li>
</ul>
<p>总而言之，<code>最大的区别是inode的节点的变化</code>。那这为什么会导致程序出core呢？</p>
<p>这个推敲过程比较复杂，这里就简单说明概括性的结论,而且结论还不一定对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>下面分析仅仅使用于linux</p>
</blockquote>
<ul>
<li><p>为什么可以被copy？<br>  linux下面的文件被加载到内存执行，一般就两个情况，一个是exe/bin文件，一个是so文件。理论上，或者理想的话，一个文件如果被加载到内存，且程序在被执行过程，这个时候对他的原始文件的修改，是应该不被允许的。而事实上，是怎么样的呢？</p>
<ul>
<li>对bin文件：的确系统提供了保护机制，但是系统监控的最要是以inode节点为依据的。也就是说，如果你对同一个inode节点做变更的话，是不被允许的（也就是会发生TEXT BUSY)之类的错误；但是你如果先unlink，在copy一个同样名字的bin文件过来，就是可以的（这也就是linux可以热升级bin文件的缘故）。</li>
<li>对动态加载的so文件，系统是通过mmap映射文件加载进来的，早期的linux支持DENYWRITE的选项，后来废弃了（man手册上面说明是因为会导致dos攻击，为什么？）。因此理论上我们是可以随便把一个内容cp到一个正在运行的so上面的。</li>
</ul>
</li>
<li><p>copy发生了什么?<br>  明确了so可以被copy后，让我们看为什么copy之后会发生core呢？理论上你的东西都已经跑到内存里面了，我随便改改文件应该没什么影响啊？根据<code>深入理解LINUX内核</code>上面对mmap的说明，大概猜测如下：</p>
<ul>
<li>linux是有页高速缓存的，用于缓存文件的内容；</li>
<li>mmap做内存文件映射的时候，其实并没有开辟什么新的内存空间，而是直接指向了页高速缓存的区域；</li>
<li><p>当外部程序对文件进行修改的时候，页高速缓存就会失效；下一次主程序读取的时候，就会重新从磁盘文件里面加载最小的文件内容；(这个通过程序的验证，可以通过写个mmap的程序读取会动态发生内容改变的程序);</p>
<p>总的来说，通过mmap获取的内存区域，在文件发生内容变化的时候，其内存地址对于的内容也会发生改变</p>
</li>
</ul>
</li>
<li><p>程序为什么会core呢？</p>
<p>  有了上面的基础，整个原因就比较清晰了；因为一个so里面被加载之后，总是需要做地址重定向的；在copy发生后，我们只是简单的更改了内容，当没有重定向地址，这样就导致了此时在访问次共享内存的时候，很多地址都是无效的，那肯定容易出core啊</p>
</li>
</ul>
<h2 id="跟进"><a href="#跟进" class="headerlink" title="跟进"></a>跟进</h2><ul>
<li>页高速缓存的机制</li>
<li>linux常见命令对应的操作系统调用情况</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://unix.stackexchange.com/questions/74142/why-does-a-software-package-run-just-fine-even-when-it-is-being-upgraded?lq=1" target="_blank" rel="external">Why does a software package run just fine even when it is being upgraded?</a></li>
<li><a href="http://unix.stackexchange.com/questions/74165/how-to-upgrade-shared-library-without-crash" target="_blank" rel="external">How to upgrade shared library without crash?</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_622a99700100pjv3.html" target="_blank" rel="external">linux下So覆盖导致coredump问题的分析</a></li>
<li><a href="http://www.piao2010.com/%E4%B8%BA%E4%BD%95cp%E8%A6%86%E7%9B%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93so%E4%BC%9A%E5%AF%BC%E8%87%B4coredump" target="_blank" rel="external">为何cp覆盖进程的动态库(so)会导致coredump</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-1220_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/20/1220_bitch_about/">写在1220</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/20/1220_bitch_about/" class="article-date">
  <time datetime="2014-12-19T17:59:57.000Z" itemprop="datePublished">2014-12-20</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>好像很晚了，很困，但不想马上睡，想做点事情；</p>
<p>这周工作上面，好多事情，都是线上的问题，包括nginx，网络以及一系列的机器死机，一直疲于应付；项目上面的事情问题更多了，都不知道怎么办；新的项目也没有顺利启动；想想都是问题，下周还得跟着，唉。。。。</p>
<p>生活上面没什么好说的，基本上每天的生活的东西都可以计算出来了；但担心的事情依旧没有解决，不知道怎么办。。。今天踢球的时候，天气很冷，风很大，人也很少，只有7个人，但我们还是坚持踢了两个小时，感谢陪我一起受罪的小伙伴们。突然想想，如果现在没有踢球，我会是怎么挨过来的。。。</p>
<p>最近有人在问我以后的事情，我发现我真是没有所谓的思考，基本上现在想都懒得想，世界上太多事情，基本控制不了，先做好自己吧，也希望能做好自己。同时也发现，年纪越大，也终究开始承认自己的无能之处了…</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/06/lock/">锁机制概述</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/06/lock/" class="article-date">
  <time datetime="2014-12-06T08:26:33.000Z" itemprop="datePublished">2014-12-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="锁机制概述"><a href="#锁机制概述" class="headerlink" title="锁机制概述"></a>锁机制概述</h1><blockquote>
<p>现代体系结构上的UNIX系统 读书笔记&amp;思考</p>
</blockquote>
<h2 id="互斥问题-amp-锁"><a href="#互斥问题-amp-锁" class="headerlink" title="互斥问题 &amp; 锁"></a>互斥问题 &amp; 锁</h2><p>在linux内核上面，或多或少都存在所谓的临界区，用户保护不允许被多个进程同时访问的资源。因此，操作系统或者硬件体系本身需要提供一种机制，来保证这些资源是互斥的使用。</p>
<p>这里介绍的锁，以及其衍生的一些概念（比如信号量）等，来说明一个操作系统在实现时面临的同步问题，面对这些问题可以采取的方案，思路等。最后介绍作为一个现在的操作系统linux，其提供的内核同步支持以及用户态支持。</p>
<h2 id="UP-系统面临的同步问题"><a href="#UP-系统面临的同步问题" class="headerlink" title="UP 系统面临的同步问题"></a>UP 系统面临的同步问题</h2><p>我们先考虑一个简单的系统，比如在之前，整个系统都只有一个CPU，这个时候他们会有临界区的问题吗？</p>
<p>答案是肯定，虽然我们可以一再简化系统的功能（比如不支持内核抢占），但是至少在如下两个运行环境下的代码，是需要考虑同步问题的：</p>
<ul>
<li><p>和中断程序共享资源的代码：由于系统总是要开中断的（想象我们关闭时钟中断可能带来的问题），此时这些代码段，面临着和中断并发访问带来的问题</p>
</li>
<li><p>处在进程上下文切换环境下的代码段：考虑一些代码段，由于底层资源轻轻未得到满足（比如网络IO）等，此时，我们一般会主动放弃CPU，让系统调度其他的进程进行处理。但我们需要保证，我们代码段所保护的资源，不能被新调度进来的其他进程破坏</p>
</li>
</ul>
<p>抽象的，其实就两大类问题，因为任意的一个UP kernel，如果不支持内核抢占的话，他的运行环境能发生并发的环境就两个情况，一个是中断，一个是进程的切换。</p>
<p>在一个UP的系统，如上问题，可以用如下的方案解决：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>抽象问题</th>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>短期互斥</td>
<td></td>
<td>一个内核代码可能会被并发执行</td>
<td>非抢占内核</td>
</tr>
<tr>
<td>长期互斥</td>
<td>进程上下文的资源保护</td>
<td>进程切换时如何保证资源</td>
<td>对每个资源有个flag标记，只有占有flag标记的进程才能访问资源</td>
</tr>
<tr>
<td>中断互斥</td>
<td>中断上下文的资源保护</td>
<td>如何</td>
<td>关闭中断</td>
</tr>
</tbody>
</table>
<p>再简单看下长期互斥和中断互斥实现的伪代码</p>
<ul>
<li>带有中断处理器的互斥</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="meta"># splhi 可以认为是关闭中断，splx是恢复中断</span></div><div class="line">s = splhi();</div><div class="line">counter ++;</div><div class="line">splx(s);</div></pre></td></tr></table></figure>
<ul>
<li>长期互斥的伪代码实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_object</span><span class="params">(<span class="keyword">char</span>* flag)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(*flag)</div><div class="line">    	sleep(flag);</div><div class="line">    *flag = <span class="number">1</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> unlock_object(<span class="keyword">char</span>* flag)</div><div class="line">&#123;</div><div class="line">	*flag = <span class="number">0</span>;</div><div class="line">    wakeup(flag);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="UP到MP面临的问题"><a href="#UP到MP面临的问题" class="headerlink" title="UP到MP面临的问题"></a>UP到MP面临的问题</h2><p>单一个UP的kernel迁移到MP的时候，上面的同步机制可以认为是全部失效。大致简单说明如下:</p>
<ul>
<li>短期互斥: 在UP的情况下，只要不支持抢占，一个资源就无法被并发访问，但是MP情况下，一个资源随时有可能被多个processor直接访问，因为是否抢占都不能解决改问题</li>
<li>带有中断的互斥：在UP情况下，只要屏蔽当前cpu的中断，就可以保证临界区的资源被保护，同样，由于多个cpu的存在，仅仅屏蔽当前CPU的中断，也无法保护临界区的资源</li>
<li>长期互斥： review长期互斥的实现代码，同样会发现在MP环境下的问题，比如由于while和flag=1现在不是原子的，导致有可能都进入临界区</li>
</ul>
<p>综上，如果一个kernel要迁移MP，需要采用新的策略来解决一系列的同步问题。</p>
<h2 id="自旋锁的引入"><a href="#自旋锁的引入" class="headerlink" title="自旋锁的引入"></a>自旋锁的引入</h2><p>我们下面主要考虑SMP kernel的实现方案。因为，事实上，在UP迁移到MP的过程中，我们可以采用很多折衷的策略，一个最简单的迁移机制就是所谓的<code>主从架构</code>，就是kernel就跑着一个cpu上面，这样kernel就类似一个UP了，所需要解决的问题就是如果和其他的cpu管理运行队列等，这个就不详细说明。</p>
<p>在MP系统下面，需要硬件体系提供一些基本的同步支持，比如xchg等，我们将这个引申为<code>自旋锁</code>，可以认为是整个系统最核心，最基本的同步原语，不同硬件环境下面的自旋锁可以有不同的实现。</p>
<p>但是自旋锁的使用，必须十分小心，因为他一直耗着cpu，一旦出现死锁，系统就将不可用，具体如下：</p>
<ul>
<li>正常情况下，一个进程第二次尝试获取一个锁：如果不考虑递归上锁的支持的话，这个情况也会导致系统死锁；</li>
<li>中断情况下：如果该处理器的基准代码已经拥有了锁，而同时改处理器的中断的处理也要获取这个锁，由于改cpu已经没机会释放锁了，这也会导致死锁。一个处理的方案是，在基准代码之前屏蔽相关的中断，防止一个cpu拥有自旋锁的同时，又产生中断。</li>
<li>进程切换时，如果要睡眠，也可能出发死锁：且不论其他cpu在等待睡眠进程拥有的锁带来的性能损耗（要等很久），极端情况下也会发生死锁，因为有可能所有的cpu被调度后都在等待这个自旋锁，此时，没人任何的空闲的cpu能够把睡眠的进程拉起来，让他去释放锁，整个系统也就死锁了。因此，我们是<code>不允许一个进程跨越一个上下文切换还能占有一个自旋锁</code></li>
</ul>
<p>关于进程切换（睡眠）带来的锁的问题，一个方案是将某个进程占有的以及活的他们的顺序记录在改进程的U区（进程user data区域）。于是，上下文切换代码的能够释放正在被挂起的进程的锁。当进程在休眠之后重新执行的时候，它必须活的它之前占有的所有锁。这也可以由上下文切换代码执行。</p>
<blockquote>
<p>感觉这边需要证明一个东西，就是一个序列，比如 L a,b,c UL 和 L a UL,L b,c UL 是等价的，否则为什么可以按照上面那样做？？</p>
</blockquote>
<h2 id="MP的方案"><a href="#MP的方案" class="headerlink" title="MP的方案"></a>MP的方案</h2><p>有了自旋锁，我们再看看如何解决上面几个问题：</p>
<ul>
<li><p>短期互斥<br>  有了自旋锁，短期互斥，非常方便处理，只要对要保护的代码（资源）加上一个自旋锁保护即可。</p>
</li>
<li><p>带有中断的互斥<br>  如上，会面临资源被其他cpu抢占的情况（同时也要避免死锁的情况），因为需要调整此时锁的实现，具体如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 基准代码</div><div class="line"></div><div class="line">s = splhi();</div><div class="line">lock(&amp;drive_lock);</div><div class="line">counter ++;</div><div class="line">unlock(&amp;drive_lock);</div><div class="line">splx(s);</div><div class="line"></div><div class="line"># 中断处理代码:</div><div class="line"></div><div class="line">lock(&amp;drive_lock);</div><div class="line">counter ++;</div><div class="line">unlock(&amp;drive_lock);</div></pre></td></tr></table></figure>
<pre><code>可以分析，通过关闭中断，可以保证基准代码和中断的代码不会在一个cpu上面（避免死锁）；而如果中断代码和基准代码在不同的cpu上面的话，通过自旋锁来保护资源。
</code></pre><ul>
<li>长期互斥</li>
</ul>
<p>如上，在一个MP系统的长期互斥的问题，主要是while和flag＝1的操作并不是原子的。有了自旋锁，这个问题就能解决了，具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_object</span><span class="params">(<span class="keyword">char</span>* flag_ptr)</span></span></div><div class="line">&#123;</div><div class="line">    lock(&amp; object_locking);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(*flag_ptr)</div><div class="line">        sleep(flag_ptr);</div><div class="line"></div><div class="line">    *flag_ptr = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    unlokc(&amp; object_locking); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_object</span><span class="params">(<span class="keyword">char</span>* flag_ptr)</span></span></div><div class="line">&#123;</div><div class="line">    lock(&amp; object_locking);</div><div class="line"></div><div class="line">    *flag_ptr = <span class="number">1</span>;</div><div class="line"></div><div class="line">    wakeup(flag_ptr);</div><div class="line"></div><div class="line">    unlock(&amp; object_locking);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一点，在lock_object的时候，当进程获取自旋锁后，发现flag_ptr为1，需要sleep等待资源的释放；也就意味着我们这里是会发生<code>一个占有自旋锁的进程，需要休眠</code>，这个情况，如上，会让进程切换的上下文进程处理的（包括锁的释放&amp;获取）</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>考虑到上面的<code>长期互斥</code>的支持，可以发现的两个比较大的问题：</p>
<ol>
<li>sleep/wakeup 的时候会唤醒多个等待进程，可能存在<code>惊群效应</code></li>
<li>为了允许拥有自旋锁的进程能够睡醒，在进程进行上下文切换的时候，需要保存一些锁的信息以便恢复</li>
</ol>
<p>因此，这里我们引入了一个新的同步原语，信号量，信号量本身是非常强大的，下面简单介绍下。</p>
<ul>
<li>定义</li>
</ul>
<blockquote>
<p>copy from wiki</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。</div><div class="line"></div><div class="line">运作方式：</div><div class="line"></div><div class="line">初始化，给与它一个非负数的整数值。</div><div class="line">运行 P（wait()），信号量S的值将被减少。企图进入临界区段的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区段。</div><div class="line">运行 V（又称signal()），信号量S的值会被增加。退出离开临界区段的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。</div></pre></td></tr></table></figure>
<ul>
<li>作用</li>
</ul>
<p>由于count可以自己定义，因此我们对信号量的使用也是可以丰富的，比如:</p>
<pre><code>* 互斥：当count为1的时候，就是一个mutex
* 同步：可以用来对一个事件的同步
* 资源分配: ---
</code></pre><ul>
<li>实现</li>
</ul>
<p>这里简单列下对信号量的实现，可以简单的考虑如下：</p>
<ul>
<li>信号量需要维护一个队列，用户唤醒/记住等待的队列</li>
<li>由于在MP系统下面，因此需要自旋锁</li>
<li>尽量解决sleep/wakeup对系统带来的额外负担</li>
</ul>
<p>简单demo如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></div><div class="line">    <span class="keyword">lock_t</span> lock;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">proc_t</span>* head;</div><div class="line">    <span class="keyword">proc_t</span>* tail;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema_t</span>;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sema</span><span class="params">(<span class="keyword">sema_t</span>* sp, <span class="keyword">int</span> cnt)</span></span></div><div class="line">&#123;</div><div class="line">    initlock(&amp;sp-&gt;lock);</div><div class="line">    sp-&gt;head = sp-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    sp-&gt;count = cnt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">sema_t</span>* sp)</span></span></div><div class="line">&#123;</div><div class="line">    lock(&amp;sp-&gt;lock);</div><div class="line">    sp-&gt;count --;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(sp-&gt;count &lt; <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(sp-&gt;head == <span class="literal">NULL</span>)</div><div class="line">            sp-&gt;head = u.u_procp;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            sp-&gt;tail-&gt;p_next = u.u_procp;</div><div class="line">        </div><div class="line">        u.u_procp-&gt;p_next = <span class="literal">NULL</span>;</div><div class="line">        sp-&gt;tail = u.u_procp;</div><div class="line"></div><div class="line">        unlock(&amp; sp-&gt;lock);</div><div class="line"></div><div class="line">        swtch();</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    unlock(&amp; sp-&gt;lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，为了避免一个休眠的进程拥有spin lock，我们在<code>swtch()*</code>要先unlock，然后进行swtch();<br>swtch()本身会进行一个上下文切换；当进程被唤醒的时候，他会从上一次中断的地方继续执行。</p>
<p>可以注意的事，虽然信号量使用了自旋锁，但他用自旋锁保护的仅仅是队列，而不是大的资源。而整个保护的临界区是非常小的，可以任务不用担心进程睡眠等复杂的问题。</p>
<p>v的实现也类似，但有一些注意条件，这里不详述。</p>
<p>最后，我们在考虑用信号量来满足<code>长期互斥</code>的需求。其实很简单，只要让相关要保护的资源和一个信号量挂钩起来就可以了。而且此时，不需要主动sleep和wakeup，因为信号量本身默认支持此类操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，一个MP的kernel的同步机制，最重要的两个原语，一个是自旋锁，一个是信号量；<br>自旋锁是一切的基础，可以提供解决短期的互斥。而信号量的实现是基于自旋锁，但他和系统合成之后，支持进程挂起等更强大的支持。</p>
<p>上面说明的只是操作系统层面的最基本的锁机制。事实上，我们在考究真正锁实现或者锁应用的时候，会发现他们远比想象中的负责，个人认为，主要有两个原因：</p>
<ul>
<li>其一，锁和死锁的问题总是如影随形，而整个kernel的运行环境又是比较复杂的，抢占，中断，上下文切换等，对锁的使用都是要小心翼翼，比如spin lock就有N个内核的版本等，要真正理解必须对整个linux的运行机制有较深的认识；</li>
<li>其二，在MP的系统，锁的性能直接影响着整个内核的性能，因此对锁的优化和研究可以任务是无所不用其极，比如引入了RCU，seq-LOCK等，单单一个spin lock，就有N个版本的实现和考虑。</li>
</ul>
<p>对于一个非内核的开发者，对锁的掌握，最好做到能够了解现有linux提供的锁支持，以及用户态情况下pthread库的实现。这个也是下面会具体再讨论的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>书籍: 现代体系结构上的UNIX系统（修订版）</li>
<li><a href="http://irl.cs.ucla.edu/~yingdi/web/paperreading/smp_locking.pdf`" target="_blank" rel="external">Locking in OS kernels for SMP Systems</a></li>
<li>维基百科: <a href="http://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99" target="_blank" rel="external">信号量</a></li>
<li><a href="http://locklessinc.com/articles/locks/" target="_blank" rel="external">Spinlocks and Read-Write Locks</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-rcu/index.html" target="_blank" rel="external">Linux 2.6内核中新的锁机制</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/12/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>