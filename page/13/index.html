<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/13/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-weekly-of-20160529" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/29/weekly-of-20160529/">weekly of 20160529</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/29/weekly-of-20160529/" class="article-date">
  <time datetime="2016-05-29T15:01:29.000Z" itemprop="datePublished">2016-05-29</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="新鲜事"><a href="#新鲜事" class="headerlink" title="新鲜事"></a>新鲜事</h2><ul>
<li><p><a href="http://tech.adroll.com/blog/data/2016/05/24/traildb-open-sourced.html" target="_blank" rel="external">Announcing TrailDB - An Efficient Library for Storing and Processing Event Data</a> : 关于event data数据存储的另外一个思路</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=11787152" target="_blank" rel="external">Same-site Cookies</a> : 新引入的”same-site”机制，通过次申明可以让浏览器在做跨越请求的时候，不携带目标域名的cookie，这个机制可以有效的解决CSRF的问题, 可以多看看<a href="https://news.ycombinator.com/item?id=11787152" target="_blank" rel="external">hacker news</a>上面讨论</p>
</li>
</ul>
<h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><ul>
<li><p><a href="http://techblog.netflix.com/2016/05/application-data-caching-using-ssds.html" target="_blank" rel="external">Application data caching using SSDs</a> : Netflix的文章，介绍如何支持全球的在线业务, 包括<a href="http://techblog.netflix.com/2016/03/global-cloud-active-active-and-beyond.html" target="_blank" rel="external">Global Cloud - Active-Active and Beyond</a></p>
</li>
<li><p><a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> : 关于浮点计算的说明，都是英文，先mark，需要找个中文快速理解下</p>
</li>
<li><p><a href="https://blog.benjojo.co.uk/post/ssh-port-fluxing-with-totp" target="_blank" rel="external">TOTP SSH port fluxing</a> : <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" target="_blank" rel="external">TOTP</a>(Time-based One-time Password Algorithm)类似于我们的ssh token,  不过作者是利用动态token作为port的前缀, 类似的技术可以参看<a href="https://en.wikipedia.org/wiki/Port_knocking" target="_blank" rel="external">Port knocking</a></p>
</li>
<li><p><a href="http://weibo.com/ttarticle/p/show?id=2309403978986932807291" target="_blank" rel="external">用最少的机器支撑万亿级访问，微博6年Redis优化历程</a> : 微博的redis落地实践，对一些常见的问题的处理方案&amp;思路</p>
</li>
<li><p><a href="http://xiezhenye.com/2013/02/%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E8%BF%90%E8%A1%8C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84-rlimit.html" target="_blank" rel="external">动态修改运行中进程的 rlimit</a> : 主要介绍了可以动态调整运行程序的rlimit参数的办法，采用系统调用<code>prlimit</code>或者trick的gdb修改, 文中的gdb代码比较恶心，可以参考这篇文章里面<a href="https://gregchapple.com/updating-ulimit-on-running-linux-process/" target="_blank" rel="external">Updating ulimit on a running Linux process</a>, gdb的强大之处</p>
</li>
</ul>
<h2 id="资料工具"><a href="#资料工具" class="headerlink" title="资料工具"></a>资料工具</h2><ul>
<li><p><a href="http://weibo.com/ttarticle/p/show?id=2309403978201981434927" target="_blank" rel="external">云舒，一个技术至上者的理想主义</a> : 听闻其名，看过其文，每一个牛逼的人都是对其信念和追求的用不停息的坚持</p>
</li>
<li><p><a href="https://eigenstate.org/notes/regex-debug" target="_blank" rel="external">Eigenstate : Regex Debugging</a> : 用于调试正则表达式，真是牛逼</p>
</li>
<li><p><a href="http://synisma.neocities.org/perf_scale_cheatsheet.pdf" target="_blank" rel="external">Software Performance &amp; Scalability: A Cheatsheet</a> : 还不错</p>
</li>
<li><p><a href="http://www.jianshu.com/p/05de8f667eea" target="_blank" rel="external">顶尖程序员不同于常人的5个区别</a> : 简单的励志文章，需要一直督促自己</p>
</li>
<li><p><a href="https://github.com/lichuang/Lua-Source-Internal" target="_blank" rel="external">lichuang/Lua-Source-Internal</a> : lua的源码剖析，比云风之前的文章还要详细，好好学习(有空真想自己写个lua的VM)</p>
</li>
<li><p><a href="http://openresty.org/posts/dynamic-tracing/" target="_blank" rel="external">动态追踪技术漫谈</a> : by 章亦春, 比较科普的文章；非凡之人，必有非凡的魄力，非凡的坚持</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-first-blog-of-Hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/first-blog-of-Hexo/">first blog of Hexo</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/21/first-blog-of-Hexo/" class="article-date">
  <time datetime="2016-05-20T17:09:12.000Z" itemprop="datePublished">2016-05-21</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前主要采用jeklly 做blog生成器，不过由于之前的VPS有问题，现在算是直接没有了；真是令人忧伤</p>
<p>这个VPS一定要坚持下去:)</p>
<p>另外，这个周末，希望能讲之前的文章都迁移过来</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-weekly-of-20160522" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/19/weekly-of-20160522/">weekly of 20160522</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/05/19/weekly-of-20160522/" class="article-date">
  <time datetime="2016-05-19T04:34:36.000Z" itemprop="datePublished">2016-05-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>about weekly : 每周个人推荐的技术文章合集</p>
</blockquote>
<h2 id="新鲜事"><a href="#新鲜事" class="headerlink" title="新鲜事"></a>新鲜事</h2><h2 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h2><ul>
<li><p><a href="https://engineering.quora.com/Applications-of-NLP-at-Quora?share=1" target="_blank" rel="external">Applications of NLP at Quora</a> : 介绍NLPJ技术在Quora的具体应用实践，包括质量检测等</p>
</li>
<li><p><a href="https://imququ.com/post/enable-alpn-asap.html" target="_blank" rel="external">为什么我们应该尽快支持 ALPN？</a> : 本文具体说明了当要支持http/2的时候，需要依赖https的协商机制(NPN or ALPN),  继而说明对openssl lib的要求情况，科普文</p>
</li>
</ul>
<h2 id="资料工具"><a href="#资料工具" class="headerlink" title="资料工具"></a>资料工具</h2><ul>
<li><p><a href="http://blog.petrzemek.net/2016/04/06/things-about-vim-i-wish-i-knew-earlier/" target="_blank" rel="external">Things About Vim I Wish I Knew Earlier</a> : 介绍vim的一些技巧和思路，我个人觉得<code>set relativenumber</code>可以好好考虑</p>
</li>
<li><p><a href="http://madusudanan.com/blog/understanding-postgres-caching-in-depth" target="_blank" rel="external">Understanding caching in Postgres - An in-depth guide</a> : mark, postgres好像越来越受重视了，本文具体介绍postgres的cache机制</p>
</li>
<li><p><a href="http://tonybai.com/2016/05/16/understanding-unikernels/" target="_blank" rel="external">理解Unikernels</a> : <code>Unikernels</code> 重新定义了对软件栈的组织方式，全新的思维方式，可以考虑和<code>docker</code>的异同之处</p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekly/">weekly</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/nginx_1_9_13/">nginx 1.9.13 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/03/30/nginx_1_9_13/" class="article-date">
  <time datetime="2016-03-30T06:17:29.000Z" itemprop="datePublished">2016-03-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*) Change: non-idempotent requests (POST, LOCK, PATCH) are no longer</div><div class="line">passed to the next server by default if a request has been sent to a</div><div class="line">backend; the &quot;non_idempotent&quot; parameter of the &quot;proxy_next_upstream&quot;</div><div class="line">directive explicitly allows retrying such requests.</div><div class="line"></div><div class="line">*) Feature: the ngx_http_perl_module can be built dynamically.</div><div class="line"></div><div class="line">*) Feature: UDP support in the stream module.</div><div class="line"></div><div class="line">*) Feature: the &quot;aio_write&quot; directive.</div><div class="line"></div><div class="line">*) Feature: now cache manager monitors number of elements in caches and</div><div class="line">tries to avoid cache keys zone overflows.</div><div class="line"></div><div class="line">*) Bugfix: &quot;task already active&quot; and &quot;second aio post&quot; alerts might</div><div class="line">appear in logs when using the &quot;sendfile&quot; and &quot;aio&quot; directives with</div><div class="line">subrequests.</div><div class="line"></div><div class="line">*) Bugfix: &quot;zero size buf in output&quot; alerts might appear in logs if</div><div class="line">caching was used and a client closed a connection prematurely.</div><div class="line"></div><div class="line">*) Bugfix: connections with clients might be closed needlessly if</div><div class="line">caching was used.</div><div class="line">Thanks to Justin Li.</div><div class="line"></div><div class="line">*) Bugfix: nginx might hog CPU if the &quot;sendfile&quot; directive was used on</div><div class="line">Linux or Solaris and a file being sent was changed during sending.</div><div class="line"></div><div class="line">*) Bugfix: connections might hang when using the &quot;sendfile&quot; and &quot;aio</div><div class="line">threads&quot; directives.</div><div class="line"></div><div class="line">*) Bugfix: in the &quot;proxy_pass&quot;, &quot;fastcgi_pass&quot;, &quot;scgi_pass&quot;, and</div><div class="line">&quot;uwsgi_pass&quot; directives when using variables.</div><div class="line">Thanks to Piotr Sikora.</div><div class="line"></div><div class="line">*) Bugfix: in the ngx_http_sub_filter_module.</div><div class="line"></div><div class="line">*) Bugfix: if an error occurred in a cached backend connection, the</div><div class="line">request was passed to the next server regardless of the</div><div class="line">proxy_next_upstream directive.</div><div class="line"></div><div class="line">*) Bugfix: &quot;CreateFile() failed&quot; errors when creating temporary files on</div><div class="line">Windows.</div></pre></td></tr></table></figure>
<p>这一期的feature和功能还是很多的，下面重点说明几个: </p>
<h2 id="upstream-重试策略"><a href="#upstream-重试策略" class="headerlink" title="upstream 重试策略"></a>upstream 重试策略</h2><p>这个问题的背景初现于<a href="https://trac.nginx.org/nginx/ticket/488#comment:4" target="_blank" rel="external">proxy_next_upstream_action to distinguish different network actions</a>, 整体意思是: 默认情况下，nginx对于upstream的重试，是不加以区别的，尤其对于一些非幂等操作的请求(PUT, LOCK, PATCH)也是如此，这样的策略对业务可能存在一定的风险, 所以需要加以控制，如下是新的<code>proxy_next_upstream</code>的说明 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* non_idempotent</div><div class="line">normally, requests with a non-idempotent method (POST, LOCK, PATCH) are not passed to the next server if a request has been sent to an upstream server (1.9.13); enabling this option explicitly allows retrying such requests</div></pre></td></tr></table></figure>
<p>也就是从<code>1.9.13</code> 版本开始，nginx默认不会重试一个已经发出去的POST请求, 需要通过<code>non_idempotent</code> 进行控制</p>
<blockquote>
<p>!!! : 这个和贴吧现有的策略不一致，迁移的时候需要注意</p>
</blockquote>
<h2 id="aio-write"><a href="#aio-write" class="headerlink" title="aio_write"></a>aio_write</h2><p>这个指令允许，我们在写文件的时候，也是一个异步的过程，之前的<code>aio</code>主要是允许读操作进行异步，具体<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#aio_write" target="_blank" rel="external">官方解释</a>如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">If aio is enabled, specifies whether it is used for writing files. Currently, this only works when using aio threads and is limited to writing temporary files with data received from proxied servers</div></pre></td></tr></table></figure>
<p>注意 : 现在异步写只是在接收proxy的返回包体使用的，其他地方并未开启</p>
<p>关于nginx的异步文件IO机制，具体可以见之前的一篇文章 : <a href="http://nginx.baidu.com/book/nginx_dev_manual/internal/io_in_linux_and_nginx.html" target="_blank" rel="external">linux和nginx下的异步文件IO管理</a></p>
<h2 id="UDP-Proxy支持"><a href="#UDP-Proxy支持" class="headerlink" title="UDP Proxy支持"></a>UDP Proxy支持</h2><p>这个版本开始，同样开始支持UDP代理了, 整个UDP代理其实和做一个TCP代理，至少理解上面不会查很多，如下是一个具体UDP代理的配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">53</span> udp;</div><div class="line">    <span class="attribute">proxy_responses</span> <span class="number">1</span>;</div><div class="line">    <span class="attribute">proxy_timeout</span> <span class="number">20s</span>;</div><div class="line">    <span class="attribute">proxy_pass</span> dns.example.com:<span class="number">53</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面可以去思考的一个问题是:   </p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/nginx_1_9_10/">nginx 1.9.10 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/30/nginx_1_9_10/" class="article-date">
  <time datetime="2016-01-30T06:17:29.000Z" itemprop="datePublished">2016-01-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">*) Security: invalid pointer dereference might occur during DNS server</div><div class="line">       response processing if the &quot;resolver&quot; directive was used, allowing an</div><div class="line">       attacker who is able to forge UDP packets from the DNS server to</div><div class="line">       cause segmentation fault in a worker process (CVE-2016-0742).</div><div class="line"></div><div class="line">*) Security: use-after-free condition might occur during CNAME response</div><div class="line">       processing if the &quot;resolver&quot; directive was used, allowing an attacker</div><div class="line">       who is able to trigger name resolution to cause segmentation fault in</div><div class="line">       a worker process, or might have potential other impact</div><div class="line">       (CVE-2016-0746).</div><div class="line"></div><div class="line">*) Security: CNAME resolution was insufficiently limited if the</div><div class="line">       &quot;resolver&quot; directive was used, allowing an attacker who is able to</div><div class="line">       trigger arbitrary name resolution to cause excessive resource</div><div class="line">       consumption in worker processes (CVE-2016-0747).</div><div class="line"></div><div class="line">*) Feature: the &quot;auto&quot; parameter of the &quot;worker_cpu_affinity&quot; directive.</div><div class="line"></div><div class="line">*) Bugfix : ...</div></pre></td></tr></table></figure>
<p>可以看到主要是几个安全问题的修复，以及一个新的feature的支持; 下面简单说明这个两个点</p>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>几个安全问题都是关于<code>resolver</code>指令，主要问题在于在解析DNS时需要对异常有更强的容错能力，风险点包括如下:</p>
<ul>
<li>DNS的服务伪造一个UDP包体可以导致nginx crash</li>
<li>其他的异常情况导致的nginx crash</li>
</ul>
<p>今天问题自己总结如下:</p>
<p>当我们使用<code>resolver</code>指令的时候，nginx需要和dns服务器进行交互，以便获取具体域名对应的IP; 整个这个交互的过程是nginx自己编码和dns服务交互,  这样存在的一个问题是一旦nginx的容错逻辑有问题，尤其是和外界的dns服务交互的时候，一旦这个DNS服务器可以恶意伪造请求的时候, 比如返回不正常的body的时候, nginx容错一旦处理有点偏颇，就会crash</p>
<p>所以这种情况一般会出现在: <code>配置了resolver指令，且对于的dns服务器不可信</code></p>
<blockquote>
<p>具体可以见 : <a href="http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html" target="_blank" rel="external">http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html</a></p>
</blockquote>
<h2 id="worker-cpu-affinity指令优化"><a href="#worker-cpu-affinity指令优化" class="headerlink" title="worker_cpu_affinity指令优化"></a>worker_cpu_affinity指令优化</h2><p>这个指令的功能比较简单，就是可以自动设置cpu的亲和性, demo如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">worker_cpu_affinity</span> auto;</div></pre></td></tr></table></figure>
<p>具体代码的实现还是比较简单的，不再赘述</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_keepalive_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/tcp_keepalive_proxy/">让nginx支持TCP长连接代理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/19/tcp_keepalive_proxy/" class="article-date">
  <time datetime="2016-01-19T06:17:30.000Z" itemprop="datePublished">2016-01-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">              -----&gt; LCS </div><div class="line">            /</div><div class="line">Client(PHP) -------&gt; LCS</div><div class="line">            \</div><div class="line">             ------&gt; LCS</div></pre></td></tr></table></figure>
<p>如上，我们客户端需要和LCS交互，正常情况下，由于PHP比较难做长链接(当然RAL后续可以做长连接的支持)，所以现在每次和LCS交互，都需要建立一次TCP连接，然后做数据传输；现在问题是，如果LCS在其他的IDC，这样client和LCS每次都得做一次跨机房的三次握手, 这样对服务稳定性等都有一定的影响</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                        -----&gt; LCS </div><div class="line">                      /</div><div class="line">Client(PHP)---&gt; Proxy -------&gt; LCS</div><div class="line">                      \</div><div class="line">                        ------&gt; LCS</div></pre></td></tr></table></figure>
<p>一个方案是如上，加上一个proxy，这个Proxy的作用是和LCS维护一个长连接，和client保持短连接，同时让Client和Proxy部署在一个IDC, Proxy和LCS可以跨IDC；此时Proxy和LCS的由于是长连接交互，不必要每次都有个跨IDC的三次握手, 但也有如下的问题:</p>
<ul>
<li>增加了一层，意味着多一层网络交互，</li>
<li>长连接的跨IDC交互有可能也避免不了跨IDC的网络异常问题</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如上，上面的proxy，其实就是我们说的nginx proxy, 现在的问题是nginx虽然支持简单的tcp proxy，但是并不支持downstream是短链接，然后upstream是长连接(upstream和downstream的长短链接必须一致), 但是我们知道nginx http模块里面是有一个keepalive模块的，所以技术上面应该问题不大的，我们要做的就是把那个东西迁移过来, 具体如下:</p>
<h3 id="关于nginx-HTTP-长连接"><a href="#关于nginx-HTTP-长连接" class="headerlink" title="关于nginx HTTP  长连接"></a>关于nginx HTTP  长连接</h3><ul>
<li>内部实现 : <a href="http://blog.csdn.net/gzh0222/article/details/8523635" target="_blank" rel="external">http://blog.csdn.net/gzh0222/article/details/8523635</a></li>
<li>大概思路 :<ul>
<li>对于一个具体的upstream，可以设置其connection pool的size</li>
<li>每次需要访问upstream的时候，先去connection pool里面查找, 如果存在，就用改连接；否则新建一个连接</li>
<li>当访问结束的时候, 不主动断开连接，而且放回到连接池; 如果连接池是满的，需要释放最老的无用的连接(LRU)</li>
</ul>
</li>
</ul>
<h3 id="配置demo"><a href="#配置demo" class="headerlink" title="配置demo"></a>配置demo</h3><p>依照http upstream keepalive module的工作原理，我们编写了一个tcp upstream keepalie模块，具体代码请见<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">ngx_stream_keepalive_module</a></p>
<p>如下是简单的配置demo</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> stream_test &#123;</div><div class="line">        <span class="comment"># 设置连接池的大小, 用法同http upstream keepalive module</span></div><div class="line">        <span class="attribute">keepalive</span> <span class="number">10</span>;</div><div class="line">        <span class="attribute">server</span> yf-forum-rdcjs1.yf01.baidu.com:<span class="number">12388</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">12345</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> stream_test;</div><div class="line">        <span class="attribute">proxy_protocol</span> <span class="literal">on</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题-amp-思路"><a href="#问题-amp-思路" class="headerlink" title="问题&amp;思路"></a>问题&amp;思路</h3><p>一旦加入一个proxy，我们其实又面临一个问题，以上图为例，就是LCS如何获取真正的client ip? </p>
<p>像http协议的代理，一般会在应用层做这个事情，比如说通过<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html" target="_blank" rel="external">ngx_http_realip_module</a> 把相关的信息放到header里面，这样是能满足业务需求的; 那tcp proxy怎么办?</p>
<p>像TCP层一下的代理，比如说<a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server" target="_blank" rel="external">LVS</a>一般会需要<a href="http://www.just4coding.com/blog/2015/11/16/toa/" target="_blank" rel="external">内核的支持</a>，以便我们正确的获取客户端的IP，感觉解决方案都是挺重的</p>
<p>一个简单的方案是<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">The PROXY protocol</a>, 这个协议原理&amp;思路非常简单，就是在协议代理，新建连接的时候，会传输具体的代理信息。比如按照上图，当<code>Proxy</code>和<code>LCS</code>建立连接的时候，他做的第一个事情是发送一个文本信息，告诉<code>LCS</code>相关的client信息，大概如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PROXY TCP4 192.168.0.1 192.168.0.11 56324 443</div></pre></td></tr></table></figure>
<p>所以此时客户端需要修改其读取逻辑，在首次连接之后，需要尝试去读取proxy的信息，如果存在，就可以做一些具体的解析</p>
<p>同时，也要求proxy做一些修改，在发送请求给后端的时候，需要额外带上这些信息，具体可以通过<a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_protocol" target="_blank" rel="external">proxy_protocol</a>这个指令控制;</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">nginx stream module官方链接</a></li>
<li><a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol具体说明文档</a> </li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/10/tcp_proxy/">关于nginx的tcp代理支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/10/tcp_proxy/" class="article-date">
  <time datetime="2016-01-10T06:17:31.000Z" itemprop="datePublished">2016-01-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP代理简述"><a href="#TCP代理简述" class="headerlink" title="TCP代理简述"></a>TCP代理简述</h2><p>所谓的TCP proxy是一个用于代理tcp协议的中间代理；比如类似我们的http代理, 我们的mysqlproxy等; tcp代理相比于其他的proxy，具有如下特征:</p>
<ul>
<li>由于TCP代理是传输层的代理，所以能支持更多的业务，无论是http, mysql, redis, websocket等应用层协议他都能代理</li>
<li>由于TCP代理是底层的协议，所以虽然能代理，但是对业务的控制能力也变弱(只能拿到传输层的信息): 比如我们不能像http代理那样，通过cookie，refer做请求的转发和控制</li>
</ul>
<p>其实，我们也可以把他理解为一个LVS, 或者公司内的BGW(他们是IP层的负载均衡代理); 但是又比他们稍微高一点</p>
<p>如下是简单的一个不同网络层的软件的示范:</p>
<table>
<thead>
<tr>
<th>网络层</th>
<th>具体软件/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td>LVS, BGW</td>
</tr>
<tr>
<td>TCP</td>
<td>haproxy, nginx</td>
</tr>
<tr>
<td>HTTP</td>
<td>nginx, haproxy</td>
</tr>
</tbody>
</table>
<h2 id="nginx的TCP代理功能简述"><a href="#nginx的TCP代理功能简述" class="headerlink" title="nginx的TCP代理功能简述"></a>nginx的TCP代理功能简述</h2><p>nginx是从1.9.0版本开始支持tcp代理, 称之为<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">stream</a>模块, 发展到现在的1.9.9版本, 已经初步具备了tcp proxy的功能了, 如下是一个简单的nginx stream配置; 可以注意到:</p>
<ul>
<li>tcp代理是一个stream模块, 要放在stream段</li>
<li>http里面的很多功能，比如access_log, realip 等都不能使用(可以思考为什么)</li>
</ul>
<p>通过下面的配置，我们就可以实现一个mysql的proxy，自动做几个db的负载均衡；图来自于<a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">nginx官方文档</a></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> db &#123;</div><div class="line">        <span class="attribute">server</span> db1:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db2:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db3:<span class="number">3306</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> db;</div><div class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">1s</span>; <span class="comment"># detect failure quickly</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>架构示意图:</p>
<p><img src="./nginx-plus-load-balancing.png" alt="nginx tcp proxy demo"></p>
<h2 id="关于nginx-tcp代理注意点"><a href="#关于nginx-tcp代理注意点" class="headerlink" title="关于nginx tcp代理注意点"></a>关于nginx tcp代理注意点</h2><p>如果你准备要写一个nginx stream模块的扩展，你会发现和之前的http差异会比较大，下面简单说几点现在写stream proxy总结的一些问题</p>
<h3 id="文档未稳定"><a href="#文档未稳定" class="headerlink" title="文档未稳定"></a>文档未稳定</h3><p>现在nginx还没文档化nginx stream扩展的具体开发模式，从源码上面查看，nginx也是一直在调整，比如1.9.0和1.9.9的module定义就有所不同，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.9.0 源码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 1.9.9 源码, 多了 postconfiguration 定义</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* postconfiguration */</span> </div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到, 连核心的module定义都有所调整, 所以这个方面估计还需要进一步观察</p>
<h3 id="调试有一定的成本"><a href="#调试有一定的成本" class="headerlink" title="调试有一定的成本"></a>调试有一定的成本</h3><p>要注意到我们现在是在写tcp proxy，所以之前用于调试的curl, access_log都不能直接使用了; 依照我现在的个人经验，推荐大家熟悉如下两个工具:</p>
<ul>
<li>nc : arbitrary TCP and UDP connections and listens<ul>
<li>作为server端，可以尝试 : nc -lk </li>
<li>作为client端，可以尝试 : echo “xxx” | nc {host} {port} 或者 nc {host} {post} (后者会保持长连接)</li>
</ul>
</li>
</ul>
<p>nc 可以让我们非常简单的去发送tcp的包体，用于作为我们测试的原始流量, 也可以非常简单的搭建一个tcp server</p>
<ul>
<li>tcpdump :<ul>
<li>命令大概如下(最基本的) : tcpdump -vvv -nn -X -i any (host 10.46.178.51 and port 12388)(condition)</li>
<li>要求对tcp的协议交互有较深的理解, 各种flag</li>
</ul>
</li>
</ul>
<p>关于nc和tcpdump, 文章的末尾给了几个链接，是非常适合系统性学习的</p>
<h3 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h3><p>由于tcp proxy的特殊性，导致其现在还不大方便有类似http模块access_log的日志(http有请求的概念，但是tcp没有); 所以tcp proxy的日志基本上都是通过error log体现的<br>贴吧线上的常规日志级别是notice, 如果我们要观察比如一个client连接，发送多少数据之类的，建议把日志级别调成<code>info</code>级别; 如下是大概的info级别的日志信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 client 127.0.0.1:45607 connected to 0.0.0.0:12345</div><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 proxy 10.46.178.51:60713 connected to 10.36.89.18:12388</div><div class="line">2016/01/10 00:32:49 [info] 9530#0: *13 client disconnected, bytes from/to client:16/0, bytes from/to upstream:0/16</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于tcpdump的:</p>
<ul>
<li><a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="external">A tcpdump Primer with Examples</a> :  tcpdump工具非常不错的说明，便于理解</li>
<li><p><a href="https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/" target="_blank" rel="external">UDP/TCP Checksum errors from tcpdump &amp; NIC Hardware Offloading</a> : 关于tcpdump的<code>incorret chksum</code>问题说明</p>
</li>
<li><p><a href="http://www.thegeekstuff.com/2012/04/nc-command-examples/" target="_blank" rel="external">8 Practical Linux Netcat NC Command Examples</a></p>
</li>
</ul>
<p>关于tcpproxy的文章:</p>
<ul>
<li><p><a href="https://www.nginx.com/resources/admin-guide/tcp-load-balancing/" target="_blank" rel="external">TCP LOAD BALANCING</a> : nginx官方blog，介绍如何具体配置nginx</p>
</li>
<li><p><a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">MySQL High Availability with NGINX Plus and Galera Cluster</a> : 一个tcp proxy的具体demo，用于做mysql的复杂均衡</p>
</li>
</ul>
<p>下一篇文章会介绍<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">tcp proxy长连接</a>的实现；已经<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol</a>的情况以及使用</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-ngx_variable_flag" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/ngx_variable_flag/">nginx variable flag说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/12/19/ngx_variable_flag/" class="article-date">
  <time datetime="2015-12-19T06:17:30.000Z" itemprop="datePublished">2015-12-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景-amp-问题"><a href="#背景-amp-问题" class="headerlink" title="背景&amp;问题"></a>背景&amp;问题</h2><p>我们在自己编写nginx扩展的时候，一般要求设置flag，在<code>src/http/ngx_http_variables.h</code>，对nginx flag有如下定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_CHANGEABLE   1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_NOCACHEABLE  2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_INDEXED      4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_NOHASH       8</span></div></pre></td></tr></table></figure>
<p>现在问题来了，这些flag的标记所为何用，什么时候我们应该用什么flag呢？了解这些flag需要对nginx的变量管理机制有个简单的了解，因为这里简单说明nginx变量的管理机制以及相关flag的含义</p>
<blockquote>
<p>其实更深的背景是一个历史问题，就是nginx lua获取不到baidu problem trace的product variable, 进一步追查得知</p>
</blockquote>
<h2 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h2><blockquote>
<p>希望以简单的推导的方式说明nginx的变量管理</p>
</blockquote>
<ol>
<li>第一步，我们需要维护一个nginx支持的variable列表，为了快速查找最好是用hash存储, 所以<code>ngx_http_core_main_conf</code>的配置大概如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_variable_s</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_str_t</span>                     name;     <span class="comment">// 变量的名称</span></div><div class="line">    ngx_http_set_variable_pt      set_handler;  <span class="comment">// 变量的设置函数</span></div><div class="line">    ngx_http_get_variable_pt      get_handler;  <span class="comment">// 变量的get函数</span></div><div class="line">    <span class="keyword">uintptr_t</span>                     data;     <span class="comment">// 传给get与set_handler的值</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                    flags;    <span class="comment">// 变量的标志</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                    index;    <span class="comment">// 如果有索引，则是变量的索引号</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>这样通过<code>ngx_http_add_variable</code>往相关的hash table里面添加variable就可以了</p>
<ol>
<li>问题稍微延伸一点，我们知道variable是和请求相关的，不同请求的variable可以是不一样的；所以对于每个request都应该要自己的variable list，而且requset 一般就关系变量的具体值，定义variable value如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span>    len:<span class="number">28</span>;     </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>    valid:<span class="number">1</span>;    <span class="comment">// 当前变量是否合法</span></div><div class="line">    <span class="keyword">unsigned</span>    no_cacheable:<span class="number">1</span>; <span class="comment">// 当前变量是否可以缓存，缓存过的变量将只会调用一次get_handler函数</span></div><div class="line">    <span class="keyword">unsigned</span>    not_found:<span class="number">1</span>;<span class="comment">// 变量是否找到</span></div><div class="line">    <span class="keyword">unsigned</span>    escape:<span class="number">1</span>;</div><div class="line"></div><div class="line">    u_char     *data;       <span class="comment">// 变量的数据</span></div><div class="line">&#125; <span class="keyword">ngx_variable_value_t</span>;</div></pre></td></tr></table></figure>
<p>这样一个最简单的variable 管理方案就OK了，大概如下:</p>
<ul>
<li>在main conf记录所有的variable, 维护一个hash table，拥有快速检索</li>
<li>对于每个request , 维护一个hash table 到value的映射，这样能查询variable的值，</li>
</ul>
<p>上面方案的问题:(<code>个人理解</code>)</p>
<ul>
<li>资源消耗大 : 如果每个request 都维护一个hash table，显然内存之类的</li>
<li>查询速度慢 : 虽然hash已经足够快了，但是依旧还是有优化的空间</li>
</ul>
<ol>
<li>那如何优化呢？ 一个简单的思路就是：对于一些变量，可以不用hash，直接用索引(index)，去查询，所以在变量添加的时候，我们可以支持用户给变量添加一个索引，这样用户查询变量的时候，可以直接用索引去查；所以可以调整为:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_array_t</span>                variables;         <span class="comment">// 索引变量的数组</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>有了索引我们添加一个变量的方式，可以调整如下:</p>
<p>a) ngx_http_add_variable 添加一个变量，往variables_keys里面添加东西<br>b) ngx_http_get_variable_index 对一个变量添加索引(index), 程序存储这个index(variables里面，索引就是数组位置)<br>c) 查询的时候，可以直接index去找；不行的话就在通过hash value</p>
<p>这样request里面存储的东西也可以调整了，也不需要维护hash，只要维护索引数组就可以了，索引数组没有，直接对conf的hash table去看variable的get/set handle，直接调用就可以, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_request_s</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_http_variable_value_t</span>        *variables; <span class="comment">//数组大小和conf的variables一样大</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如上优化，感觉挺不错的；但是nginx的开发者可能不这么认为，因为现在归纳下来，我们获取变量可以通过索引或者hash；其中hash可以理解是全部的；但可能有些场景可能索引就够了，根本不需要通过hash去查找；所以如果能够通过索引去查找的variable，而且有明确不需要通过hash去弄，那就不需要导到hash table；所以main conf调整如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_hash_t</span>                 variables_hash;     <span class="comment">// 变量的hash表</span></div><div class="line">    <span class="keyword">ngx_array_t</span>                variables;         <span class="comment">// 索引变量的数组</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>在<code>ngx_http_variables_init_vars</code>里面，我们会将variable_keys 导到 variable_hash, 对于不需要hash的variable，就不用导了；这样一个问题是通过hash就找不到这个变量了</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>依照上面，我们在梳理几个flag的含义已经作用:</p>
<ul>
<li><p>NGX_HTTP_VAR_INDEXED : 这个变量是被索引的；这个flag一般不需要手动标记，通过调用ngx_get_variable_index会自动给对应变量，添加此flag</p>
</li>
<li><p>NGX_HTTP_VAR_NOHASH : 这个类型的变量，只能通过索引获得，也就是上面第4步说的</p>
</li>
</ul>
<p>简单说明ngx_http_get_variable的代码，其大概逻辑就是尝试用索引，不行就走hash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ngx_http_get_variable(ngx_http_request_t *r, ngx_str_t *name, ngx_uint_t key)</div><div class="line">&#123;</div><div class="line">    ngx_http_variable_t        *v;</div><div class="line">    ngx_http_variable_value_t  *vv;</div><div class="line">    ngx_http_core_main_conf_t  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    // 通过hash获取变量信息</div><div class="line">    // 如果知道有索引，其实可以指通过 ngx_http_get_indexed_variable</div><div class="line">    // 这个函数通用一些，会处理所有情况，</div><div class="line">    v = ngx_hash_find(&amp;cmcf-&gt;variables_hash, key, name-&gt;data, name-&gt;len);</div><div class="line"></div><div class="line">    // 查到hash了 </div><div class="line">    if (v) &#123;</div><div class="line">        // 如果是索引，走索引的流程</div><div class="line">        if (v-&gt;flags &amp; NGX_HTTP_VAR_INDEXED) &#123;</div><div class="line">            return ngx_http_get_flushed_variable(r, v-&gt;index);</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            // 非索引，通过get/set handle获取信息</div><div class="line">            vv = ngx_palloc(r-&gt;pool, sizeof(ngx_http_variable_value_t));</div><div class="line"></div><div class="line">            if (vv &amp;&amp; v-&gt;get_handler(r, vv, v-&gt;data) == NGX_OK) &#123;</div><div class="line">                return vv;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取类似http_xx, arg_xx 之类的规则变量, 忽略</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p>大部分文档链接都说的很好，很清晰；如有兴趣，可以深看</p>
</blockquote>
<ul>
<li><a href="http://pureage.info/2014/01/20/lua-nginx-variable.html" target="_blank" rel="external">lua-nginx使用自定义变量中需要说明的一点</a></li>
<li><a href="http://osdir.com/ml/nginx-development/2010-04/msg00019.html" target="_blank" rel="external">questions about http variables: flags and no_cacheable</a></li>
<li><a href="http://tengine.taobao.org/book/chapter_07.html" target="_blank" rel="external">Tengine: 模块开发高级篇: 变量</a></li>
<li><a href="http://m.blog.csdn.net/blog/dingyujie/7106524" target="_blank" rel="external">[原]nginx脚本引擎与设计设计(三)</a></li>
<li><a href="http://blog.lifeibo.com/blog/2011/12/17/nginx-varibles.html" target="_blank" rel="external">Nginx源码分析之变量</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/nginx_1_9_9/">nginx 1.9.9 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/12/19/nginx_1_9_9/" class="article-date">
  <time datetime="2015-12-19T06:17:30.000Z" itemprop="datePublished">2015-12-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="feature说明"><a href="#feature说明" class="headerlink" title="feature说明"></a>feature说明</h2><ul>
<li>pwritev() support.</li>
<li>the “include” directive inside the “upstream” block.</li>
<li>the ngx_http_slice_module.</li>
</ul>
<h2 id="pwritev说明"><a href="#pwritev说明" class="headerlink" title="pwritev说明"></a>pwritev说明</h2><p><a href="http://linux.die.net/man/2/pwritev" target="_blank" rel="external">pwritev</a>的具体说明可以见链接；nginx在这个版本里面主要用<code>pwritev</code>替代<code>writev</code>的功能；简单的理解，可以认为是将老的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">lseek(fd, offset);</div><div class="line">writev(fd, iov);</div></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pwritev()</div></pre></td></tr></table></figure>
<p>总结的收益是:</p>
<ul>
<li>系统调用从2次改成1次，主要是性能方面的</li>
<li>pwritev() was introduced in FreeBSD 6 and Linux 2.6.30, glibc 2.10</li>
</ul>
<p>具体可以参看文档: <a href="http://blog.libtorrent.org/2012/12/principles-of-high-performance-programs/" target="_blank" rel="external">principles of high performance programs</a></p>
<h2 id="ngx-http-slice-module"><a href="#ngx-http-slice-module" class="headerlink" title="ngx_http_slice_module"></a>ngx_http_slice_module</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_slice_module.html" target="_blank" rel="external">ngx_http_slice_module</a>是新引入的一个功能模块；大概的作用是可以将一个upstream response body 切成那个小块，然后每个单独缓存; 官方原话:</p>
<blockquote>
<p>The module makes it<br>possible to split a big upstream response into smaller parts and cache them<br>independently.</p>
<p>The module supports range requests.  When a part of a file is requested,<br>only the required slice upstream requests are made.  If caching is enabled,<br>future requests will only go to upstream for missing slices.</p>
</blockquote>
<p>可以理解的应用场景:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client ---&gt; proxy(nginx) ---&gt; upstream</div></pre></td></tr></table></figure>
<ul>
<li>proxy那边会将一个big file切成小块缓存</li>
</ul>
<blockquote>
<p>todo待补充</p>
</blockquote>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-waf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/waf/">业务防攻击与WAF调研</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/05/12/waf/" class="article-date">
  <time datetime="2015-05-12T09:00:37.000Z" itemprop="datePublished">2015-05-12</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>by <a href="mailto:chenjiansen@baidu.com" target="_blank" rel="external">chenjiansen@baidu.com</a> </p>
</blockquote>
<h2 id="0x00-现有防攻击支持"><a href="#0x00-现有防攻击支持" class="headerlink" title="0x00 现有防攻击支持"></a>0x00 现有防攻击支持</h2><p>对具体的流量进行分析的话，流量攻击主要包括如下两个点:</p>
<ul>
<li>量 : 就是通过构造大量的请求，来影响服务器的服务质量</li>
<li>质 : 就是伪造特定的请求，这类请求量不需要很大，但可能对系统的安全和稳定性有较大影响</li>
</ul>
<p><code>量</code>上面的攻击其实一直是大多数接入系统会重点关注和防御的，以百度而言，大致的接入防攻击有如下:</p>
<ul>
<li>BGW : 4层四层防攻击, 支持tcp代理，清洗</li>
<li>911/BCS : 旁路式的流量检测和清洗，7层防攻击</li>
<li>BFE : 主要提供了BDS, 同样是一个全局、旁路的七层防攻击体系</li>
</ul>
<p>可以看到主要是网络层的防御；虽然他们都会支持七层的防攻击，但由于理业务线有点远，导致效果一直不是很理想</p>
<p>而<code>质</code>上面主要是只针对一些恶意伪造的请求，主要是针对系统的安全性漏洞,比如XSS攻击，SQL注入等,  这方面依我现在的了解，我们并没有做太多的事情</p>
<p>总得而言，对我们来说，不大需要关注网络层的ddos攻击，更多的是需要<code>业务的防攻击支持以及安全性保障</code></p>
<h2 id="0x01-业务防攻击现状"><a href="#0x01-业务防攻击现状" class="headerlink" title="0x01 业务防攻击现状"></a>0x01 业务防攻击现状</h2><p>现有的业务防攻击是通过nginx的扩展在接入层实现的，主要支持如下几个功能:</p>
<ul>
<li>IP黑白名单</li>
<li>HTTP 请求过滤</li>
<li>单机的分布式(ip, refer, url)支持</li>
</ul>
<blockquote>
<p>几个规则可以通过and/or运算组合成一个更强大的策略</p>
</blockquote>
<p>可以理解是拥有初步的功能支持</p>
<p>而现在防攻击主要面临的问题有:</p>
<ul>
<li>功能有限 : 包括:<ul>
<li>数据都是单机的，对于分布式的攻击，效果有限</li>
<li>action定义有限，只能简单返回异常码</li>
</ul>
</li>
<li>可用性/友好性较差 : 现在的配置都是用XML描述的，用户难以理解其规则；添加规则的学习成本之类的也很高</li>
<li>运维复杂<ul>
<li>比如iplist更新之类的需要重启nginx</li>
</ul>
</li>
<li>系统性 : 现在防攻击主要侧重在攻击上面，但其实没有建立<code>异常捕获+生产策略+线上应用</code> 的闭环，导致策略容易失效，对用户也会造成一定的误伤</li>
</ul>
<h2 id="0x02-WAF和业务防攻击"><a href="#0x02-WAF和业务防攻击" class="headerlink" title="0x02 WAF和业务防攻击"></a>0x02 WAF和业务防攻击</h2><p><a href="http://en.wikipedia.org/wiki/Application_firewall" target="_blank" rel="external">WAF</a>是业界对应用层防护的一个主要手段,这里我们主要关注软件waf，其中<a href="https://www.modsecurity.org/" target="_blank" rel="external">mod security</a>可以认为是一个事实的waf标准</p>
<p>大多数软件的WAF都会支持如下功能:</p>
<ul>
<li>HTTP Protection （HTTP防御）: HTTP协议和本地定义使用的detectsviolations策略。 </li>
<li>Real-time Blacklist Lookups（实时黑名单查询） : 利用第三方IP信誉。 </li>
<li>HTTP Denial of Service Protections（HTTP的拒绝服务保护）: 防御HTTP的洪水攻击和HTTP Dos 攻击。  </li>
<li>Common Web Attacks Protection（常见的Web攻击防护） : 检测常见的Web应用程序的安全攻击。  </li>
<li>Automation Detection（自动化检测） : 检测机器人，爬虫，扫描仪和其他表面恶意活动。  </li>
<li>Integration with AV Scanning for File Uploads（文件上传防病毒扫描） : 检测通过Web应用程序上传的恶意文件。  </li>
<li>Tracking Sensitive Data（跟踪敏感数据） : 信用卡通道的使用，并阻止泄漏。  </li>
<li>SQL注入检测/XSS攻击检测 </li>
</ul>
<p>实现层面的话，主要是通过规则的描述, 比较强依赖正则表达式, 比如如下是一个SQL注入的配置规则:</p>
<blockquote>
<p>FreeWAF源码</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">	id = 41010,</div><div class="line">	action = "SCORE",</div><div class="line">	description = "SQL Injection attempt",</div><div class="line">	opts = &#123; score = 4, transform = 'uri_decode' &#125;,</div><div class="line">	var = &#123;</div><div class="line">		operator = "REGEX",</div><div class="line">		pattern = [=[(?i:\bor\b ?(?:\d&#123;1,10&#125;|[\'\"][^=]&#123;1,10&#125;[\'\"]) ?[=&lt;&gt;]+|(?i:'\s+x?or\s+.&#123;1,20&#125;[+\-!&lt;&gt;=])|\b(?i:x?or)\b\s+(\d&#123;1,10&#125;|'[^=]&#123;1,10&#125;')|\b(?i:x?or)\b\s+(\d&#123;1,10&#125;|'[^=]&#123;1,10&#125;')\s*?[=&lt;&gt;])]=],</div><div class="line">		type = "REQUEST_ARGS",</div><div class="line">		opts = &#123; key = "all" &#125;,</div><div class="line">	&#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>如上的规则大致会将请求arg里面含有<code>or 1</code>等请求标记为危险请求(比如加上危险的权重), 一些好的waf的实现，还具有请求打分等控制, 可以实现非常复杂的逻辑控制</p>
<p><a href="http://www.scalescale.com/scaling-cloudflares-massive-waf/" target="_blank" rel="external">CloudFlare</a>多次在其blog介绍其waf的实现，但没有开放源代码。<a href="">FreeWAF</a>是我个人觉得写的相对不错的开源waf，功能强大，基本上涵盖了OWASP的CRS</p>
<p>事实上，WAF本身是非常复杂的的(有机会可以拿出来单独讨论)，尤其是其SQLi, XSS防御之类的规则学习成本也是比较高的，需要对web安全有一定的了解。但是通用的WAF都提供了一个非常不错的策略描述，执行框架。对于贴吧和业务的业务防攻击需求，其完全是可以复用的，只不过在具体的策略的关注点和侧重点有所不同</p>
<h2 id="0x03-我们的业务防攻击系统"><a href="#0x03-我们的业务防攻击系统" class="headerlink" title="0x03 我们的业务防攻击系统"></a>0x03 我们的业务防攻击系统</h2><p>需要实现的核心功能如下:</p>
<ul>
<li>支持热加载的ip黑白名单</li>
<li>支持全局存储的分布式防攻击策略</li>
<li>支持自定义的action处理</li>
</ul>
<p>其他可以考虑的功能包括(优先级较低):</p>
<ul>
<li>简单的SQL注入防御</li>
<li>XSS防护</li>
</ul>
<blockquote>
<p>安全相关的内容涉及东西较深，优先级也先降低</p>
</blockquote>
<p>大致的系统架构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">                              ┌───────────┐</div><div class="line">┌──────────────────┐          │           │</div><div class="line">│                  │          │           │</div><div class="line">│    platform      │──notice─▶│           │</div><div class="line">│                  │          │           │</div><div class="line">└───▲─────────┬────┘          │           │</div><div class="line">    │         │               │ router    │</div><div class="line">┌───┴─────────▼────┐          │           │</div><div class="line">│                  │          │           │</div><div class="line">│ strategy analysis│◀───log───│           │</div><div class="line">│                  │          │           │</div><div class="line">└──────────────────┘          │           │</div><div class="line">                              └───────────┘</div></pre></td></tr></table></figure>
<p>主要包括三个组件:</p>
<ul>
<li>router上面的waf扩展 : 负责waf的具体实现，nginx/lua的扩展耦合到router </li>
<li>策略控制平台 : 负责策略的生产，推送到线上的控制等</li>
<li>策略分析平台 : 负责对在线策略效果的分析, 反馈给策略控制平台</li>
</ul>
<h2 id="0x04-实现和风险考虑"><a href="#0x04-实现和风险考虑" class="headerlink" title="0x04 实现和风险考虑"></a>0x04 实现和风险考虑</h2><p>实现层面的话，希望用nginx/lua重写现有的防攻击策略,同时对现在的功能的不足进行加强, 带来的问题主要有:</p>
<ul>
<li>稳定性 : 采用一个分布式存储存取分布式数据(比如redis)，这样下游存储的稳定性直接影响请求的质量</li>
<li>性能/延迟影响 : 主要对每个请求的延迟和系统总体cpu的影响，大概预估如下:<ul>
<li>性能cpu占用 : 待评估</li>
<li>延迟 : 如果依赖分布式存储，得看分布式存储的性能；本身的cpu耗时控制在1ms以内</li>
</ul>
</li>
<li>迁移成本 : 由于整个策略的实现是重写的，因此我们需要保证一些老的规则能够顺利迁移到新的策略上面，可能需要提供一些脚本之类的自动生产</li>
<li>实现成本 : 规则策略的定义和实现，需要考虑性能，灵活性, nginx/lua如何方便简洁支持多产品等，不过参考了一些开源的waf实现，相信会有帮助</li>
</ul>
<blockquote>
<p>nginx/lua性能相关的配置设施会逐步完善和加强的, 相信有助于相关的性能优化</p>
</blockquote>
<p>同时我们还需要提供配套的平台来自动上层相关配置(以后策略不需要人工编辑)</p>
<h2 id="0x05-参考文档"><a href="#0x05-参考文档" class="headerlink" title="0x05 参考文档"></a>0x05 参考文档</h2><ul>
<li>公司内部的:<ul>
<li><a href="http://wiki.babel.baidu.com/twiki/pub/Ps/OP/%E9%9D%99%E6%80%81%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%85%A5bfe/%E6%B5%85%E8%B0%88http%E9%98%B2%E6%94%BB%E5%87%BB%E5%8F%8A%E8%AE%BE%E8%AE%A1_-_%E5%A4%A7%E5%92%96%E7%A7%80.pptx" target="_blank" rel="external">浅谈http防攻击及设计</a></li>
<li><a href="http://wiki.babel.baidu.com/twiki/bin/view/Ps/OP/BDS" target="_blank" rel="external">Baidu Defense Server（BDS）官方主页</a> : BFE做的旁路防攻击支持</li>
</ul>
</li>
<li><p>WAF科普</p>
<ul>
<li><a href="http://www.freebuf.com/articles/web/18084.html" target="_blank" rel="external">走进科学之WAF(Web Appllication Firewall)篇</a></li>
<li><a href="http://drops.wooyun.org/tips/968" target="_blank" rel="external">深入了解SQL注入绕过waf和过滤机制</a></li>
<li><a href="http://hebaodan.org/index.php/ModSecurity/SqlModule.html" target="_blank" rel="external">ModSecurity进阶篇-SQL注入模块分析</a> : 以及这个blog主人的文章</li>
<li><a href="http://www.freebuf.com/tools/54221.html" target="_blank" rel="external">如何打造一款可靠的WAF（Web应用防火墙）</a></li>
</ul>
</li>
<li><p>WAF实践</p>
<ul>
<li><a href="http://www.scalescale.com/scaling-cloudflares-massive-waf/" target="_blank" rel="external">Scaling CloudFlare’s Massive WAF</a></li>
<li><a href="https://www.cryptobells.com/freewaf-a-high-performance-scalable-open-web-firewall/" target="_blank" rel="external">FreeWAF: A High-Performance, Scalable, Open Web Firewall</a></li>
<li><a href="https://github.com/p0pr0ck5/FreeWAF" target="_blank" rel="external">FreeWAF: github链接</a></li>
<li><a href="https://www.52os.net/articles/nginx-install-lua-and-lua-based-waf.html" target="_blank" rel="external">nginx配置lua模块和基于lua的waf</a></li>
<li><a href="https://www.52os.net/articles/nginx-use-modsecurity-module-as-waf.html" target="_blank" rel="external">nginx配合modsecurity实现WAF功能</a></li>
</ul>
</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/12/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>