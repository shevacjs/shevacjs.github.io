<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/11/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-0225_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/25/0225_bitch_about/">生活与生存</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/25/0225_bitch_about/" class="article-date">
  <time datetime="2015-02-24T16:25:11.000Z" itemprop="datePublished">2015-02-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是大年初七凌晨，如之前所料，基本上所有的人都各奔东西，一年一次的聚散又是要匆匆而过</p>
<p>这次春节和之前差不多，基本上一半的时间都是和那些同学聚在一起，一起踢过球，喝过酒，打过牌，打过麻将，当然包括各种玩笑，谈话，还是很开心的</p>
<p>有时候会想自己为什么会更享受在家的生活，想的的一些原因包括:</p>
<ul>
<li>不需要工作了</li>
<li>因为有一群同学在，什么东西都可以吐槽</li>
<li>住在家里</li>
</ul>
<p>其实认真想想上面几个点都有一点，但其实自己有一个简单的总结，就是在这边的话，感觉自己更像在<code>生活</code>,其实之前自己对生活和生存，虽然有非常明确的语义以及其具体含义的理解，但是自己慢慢感触这个却是随着自己岁数的不断增大，现在自己的情况，更多的精力应该是让自己生存下去，让自己一直努力，让自己坚持不懈…</p>
<p>我自己希望能够在工作和<code>生活</code>中找到更好的平衡点，让自己的活的更自在一些，嗯，的确一直在调整…</p>
<p>今天看到一篇文章，大道理讲的很多，但里面有一个简单的观点，大致是说，不要太过分的欣赏和佩服自己某一刻的努力，大致的意思是世界上比你多努力的人多了去了。。。嗯，有时候后自己就会陷入这个状态，然后盲目的迷失了…</p>
<p>不再细说，今年自己要好好努力，也希望一切静好:)</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-linux_kernel_lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/06/linux_kernel_lock/">由linux锁机制想起来的</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/06/linux_kernel_lock/" class="article-date">
  <time datetime="2015-02-06T08:26:33.000Z" itemprop="datePublished">2015-02-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由linux锁机制想起来的"><a href="#由linux锁机制想起来的" class="headerlink" title="由linux锁机制想起来的"></a>由linux锁机制想起来的</h1><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>根本的目标是要实现同步机制，数据不会被打乱。</p>
<p>而在哪些情况需要同步机制呢？</p>
<ul>
<li>多处理器的情况：</li>
<li>抢占式系统 :</li>
<li>其他：</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>一般是指令自己触发的，处理也是比较简单的，主要有两种：</p>
<ul>
<li>页错误： 应该是唯一会出现的内核异常，此时会进行一些换页操作</li>
<li>其他（比如除以0，int 3）等：一般的流程是，cpu触发异常—&gt; 内核异常流程处理 —&gt; 发送信号给用户进程 –&gt; 如果用户进程不处理，就kill进程 </li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>先简单分类:</p>
<ul>
<li>I/O 中断:</li>
<li>时钟中断:</li>
<li>多处理器中断:</li>
</ul>
<p>按照处理的策略一般分为：硬中断和软中断（或者是所谓的下半部)</p>
<p>硬中断：一般是非常简单的处理逻辑<br>软中断：会拆分很多，包括softirq, tasklist, work queue, kernel thread, 具体见：<a href="https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY" target="_blank" rel="external">https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY</a></p>
<h2 id="关于抢占式内核"><a href="#关于抢占式内核" class="headerlink" title="关于抢占式内核"></a>关于抢占式内核</h2><ul>
<li><p>中断和抢占的区别</p>
<ul>
<li>中断总是存在的，响应硬件的事件</li>
<li>抢占主要是指是否执行的代码是否能被其他进程抢占</li>
</ul>
</li>
<li><p>用户态抢占和内核抢占</p>
<ul>
<li>根据被抢占的时机区分用户台态和内核态抢占</li>
<li>用户态抢占: 用户台的抢占一般比较容易，在系统调用或者中断处理完成之后返回用户态的时候判断就可以了，另外由于此时用户态的上下文保存的较为完成，直接切换到其他的进程，至少感觉实现成本不是很高</li>
<li>内核态抢占: 简单的说，如果一段代码执行在内核态，能否也被抢占，个人感觉如果支持的话，其主要成本对整个内核的一些同步机制和代码等造成的影响，下面是copy的说明</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">如果内核是不可抢占的（比如说2.4的内核），一旦切进内核态，只要代码不是主动释放CPU它就可以一直占着CPU。例外，虽不可抢占，但若此时发生中断，代码还是要交出CPU，但是中断返回之后，代码又能霸占CPU了，此为可中断但不可抢占。</div><div class="line"></div><div class="line">如果内核是可抢占的（比如2.6或之后的内核），上述情况就不会发生了。内核抢占发生在以下3种情况：</div><div class="line"></div><div class="line">1. 从中断返回内核态时，若此时可抢占，则会强制调用schedule（），尝试抢占，被中断的内核代码不一定能继续霸着CPU。</div><div class="line"></div><div class="line">2.内核变成可抢占状态，此时也会尝试抢占。</div><div class="line"></div><div class="line">3.内核代码主动调用schedule（）。</div><div class="line"></div><div class="line">虽然2.6的内核提供内核抢占，但是也提供关闭的手段。是否可抢占是由preemt_count变量控制（per-cpu），有锁这个计数就+1，释放锁就-1.为0才是可抢占。每当释放锁的时候都会检查是否为0，为0则尝试抢占。</div></pre></td></tr></table></figure>
<h2 id="关于进程上下文和中断上下文"><a href="#关于进程上下文和中断上下文" class="headerlink" title="关于进程上下文和中断上下文"></a>关于进程上下文和中断上下文</h2><p>个人感觉进程，两个上下文主要有两个含义，一个代表具体上下文关联的环境，比如寄存器之类的；另一个是一段内核代码运行的环境。而后者是更为常见和需要关注的。</p>
<p>断上下文是引申出来的概念，其主要的目标是明确一个内核代码是否能执行某些操作。比如一个内核代码能否睡眠？ 因为在中断上下文的情况下，是不允许睡眠的。。。</p>
<p>而更具体实际的差别在于，进程上下文是指一段代码代表一个进程在执行，主要有两种情况:</p>
<ul>
<li>一个系统调用导致陷入内核后的代码执行；</li>
<li>异常出发导致的异常执行</li>
</ul>
<p>而中断上下文是但一个中断发生时，其内核代码管理的环境；</p>
<p>中断上下文的要求是比较多的，包括:</p>
<ul>
<li>睡觉或者放弃cpu</li>
<li>尝试获取信号量</li>
<li>执行耗时任务</li>
<li>访问用户空间的虚拟地址 : </li>
</ul>
<p>中断处理流程中不能睡眠，具体可以见: <a href="http://www.oschina.net/question/565065_57618" target="_blank" rel="external">http://www.oschina.net/question/565065_57618</a><br>这个上面的讨论</p>
<p>具体可以见: <a href="http://www.embedu.org/Column/Column240.htm" target="_blank" rel="external">http://www.embedu.org/Column/Column240.htm</a></p>
<h2 id="各种链接哈"><a href="#各种链接哈" class="headerlink" title="各种链接哈"></a>各种链接哈</h2><ul>
<li><a href="http://hacklu.com/blog/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%AD%E6%96%AD-75/" target="_blank" rel="external">内核抢占和中断</a></li>
<li><a href="http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/" target="_blank" rel="external">http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/</a></li>
<li><a href="http://guojing.me" target="_blank" rel="external">http://guojing.me</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_close" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/tcp_close/">tcp的关闭处理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/01/tcp_close/" class="article-date">
  <time datetime="2015-02-01T15:41:49.000Z" itemprop="datePublished">2015-02-01</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>tcp的系列文章，不深究源码，偏于理解&amp;应用</p>
</blockquote>
<h2 id="状态图迁移"><a href="#状态图迁移" class="headerlink" title="状态图迁移"></a>状态图迁移</h2><p>一般tcp的关闭称为四次挥手，要求client/server端都关闭该通道的连接，他们的状态迁移图如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#这里暂不考虑同时关闭的情况</span></div><div class="line"></div><div class="line">主动关闭方                  被动关闭方</div><div class="line"></div><div class="line">ESTABLISTED                 ESTABLISED</div><div class="line">    |                           |</div><div class="line">  (send fin)                (get fin</div><div class="line">    |                       /snd ack)</div><div class="line">    |                           |</div><div class="line">    v                           v</div><div class="line">FIN_WAIT_1                  CLOSE_WAIT</div><div class="line">    |                           |</div><div class="line">  (get ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (send fin)</div><div class="line">FIN_WAIT_2                      |</div><div class="line">    |                           v</div><div class="line"> (getfin                    LAST_ACK</div><div class="line"> /send ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (get ack )</div><div class="line">TIME_WAIT                       |</div><div class="line">    |                           |</div><div class="line">  (2* MSL)                      v</div><div class="line">    |                        CLOSED</div><div class="line">    v</div><div class="line">CLOSED</div></pre></td></tr></table></figure>
<h2 id="API关系"><a href="#API关系" class="headerlink" title="API关系"></a>API关系</h2><p>关闭的函数主要有两个，如下:</p>
<ul>
<li>close : close主要是减少句柄的引用计数，如果为0，在发送fin信号，关闭这一端的连接;</li>
<li>shutdown : shutdown则是直接发送FIN信号，不考虑引用计数的问题，可以导致一些正在连接的socket直接无效了</li>
</ul>
<p>而在具体使用上面，还有一些细节，包括:</p>
<ul>
<li><p>close一般情况下是非阻塞的，但我们可以通过设置SO_LINGER的socket选项对close的行为做一些控制,使之变成非阻塞，具体包括:</p>
</li>
<li><p>shutdown可以控制关闭读或者关闭写</p>
</li>
</ul>
<p>这里面的一个经典问题的<code>客户端关闭时，如何让服务端尽量的收到数据?</code>，这个后续再详述。</p>
<h2 id="常见问题-amp-配置"><a href="#常见问题-amp-配置" class="headerlink" title="常见问题&amp;配置"></a>常见问题&amp;配置</h2><p>回到tcp的状态迁移本身，这里面说明下常见的问题：</p>
<ul>
<li>A和B交互，如果A send data后，直接close，会有上面影响？</li>
</ul>
<p>首先，我们必须非常明确&amp;理解，socket close的作用，如上，一般的就是减少引用计数，如果为0的话，就发送fin，故我们可以推测如下情况:</p>
<ol>
<li><p>A发送成功fin也接收到了ack，此时A的状态迁移到了fin_time_2; 同样可以考虑两个场景:<br> 1.1 B那边也close了socket，此时B的socekt发送ack过来，则A走正常的关闭流程，从fin_wait_2 –&gt; time_wait-&gt;close<br> 1.2 B那边由于长短链接或者协议约定的不一致，B并不关闭socket，此时B的socket已经变成了close wait; 而A只能继续处在fin_time_2的状态</p>
<p> 问题1.2属于不正常的，一般怎么处理呢?</p>
<ul>
<li>为了保证A不浪费太多时间在FIN_WAIT_2，对于FIN_WAIT_2有个(TCP_FIN_TIMEOUT，默认60s)的限制，也就是说如果A 60s后还没有接收到对方的fin，则自己会自动切到关闭(<code>or time wait:待明确</code>)状态</li>
<li>上面的FIN_WAIT_2状态超时有个细节需要关注，那就是此时的socket必须是属于孤儿状态，也就说没有任何句柄和他们关联，如果有句柄和他关联的话，就就会一直处在FIN_WAIT_2状态。之所以强调这点，是因为tcp本身是允许半关闭的，也就是说肯定有socket是持久的处在FIN_WAIT_2状态的，因为tcp需要提供一个机制来保证该状态的存在，其中最关键的一点就是要先判断一个socket是否是孤儿socket。代码demo如下:</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 假设对方不关闭close fd，分析本端的行为</span></div><div class="line"><span class="comment">//关闭句柄，假设引用计数会变成0</span></div><div class="line">close(fd);</div><div class="line"><span class="comment">// 此时，发送FIN信号，本地的socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 由于没有句柄关联，60s后，改socket将关闭 </span></div><div class="line"></div><div class="line"><span class="comment">// 同样是发送FIN信号，本地socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 但是由于有句柄关联，改状态会一直持续</span></div><div class="line">shutdown(fd, SHUT_WR);</div><div class="line"></div><div class="line"><span class="comment">//shutdow 还有SHUT_RD(关闭读,不发送信号)，SHUT_RDWR(关闭读写，类似close)</span></div></pre></td></tr></table></figure>
<pre><code>* B那边由于被动关闭，而自己也不处理，socket会处于CLOSE WAIT状态，`奇怪的是，系统并没有给close wait一个超时的时间`, 因此我们需要自己想办法清理，`一般close相关的程序就OK了`
</code></pre><h3 id="FIN-WAIT-1的超时问题"><a href="#FIN-WAIT-1的超时问题" class="headerlink" title="FIN_WAIT_1的超时问题"></a>FIN_WAIT_1的超时问题</h3><p>首先明确，如果一个socket进入FIN_WAIT_1，很大可能性是已经没有句柄关联了(shutdown？)</p>
<p>如果此时发送失败的话，会受到<code>tcp_orphan_retries</code>参数的控制（重试次数）</p>
<p>同时为了保证系统的资源有限，<code>tcp_max_orphans</code> 这个参数控制了系统可以存在的最多孤儿socket的个数</p>
<h3 id="TIME-WAIT的存在必要性问题"><a href="#TIME-WAIT的存在必要性问题" class="headerlink" title="TIME_WAIT的存在必要性问题"></a>TIME_WAIT的存在必要性问题</h3><h3 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST ACK"></a>LAST ACK</h3><h2 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h2><ul>
<li><p>TCP里面有些状态有超时，有些没有，个人理解其根本原则在于：<code>资源能否被控制住</code>，如果你的资源属于一个进程，那么就不会去限制你的超时，因为进程存在，控制进程就可以了，进程死了你也就死了；如果你已久脱离了进程的管辖，比如说孤儿状态下的FIN_WAIT_2，我们就不能让他活的太持久</p>
</li>
<li><p>可以理解对于一个状态要有超时，</p>
</li>
<li>对于孤儿的socket</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-loader_and_linker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/loader_and_linker/">linux系统下的链接&amp;加载</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/01/loader_and_linker/" class="article-date">
  <time datetime="2015-02-01T15:41:35.000Z" itemprop="datePublished">2015-02-01</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p><code>.a</code>文件，一大堆<code>.o</code>文件的组合体，对于系统库而言，一般一个<code>.o</code>文件对于一个函数<br>静态文件的链接世界上就是一大堆<code>.o</code>文件的代码的合并&amp;段合并（比如把<code>.text</code>段合并起来），组成一个新的目标文件;<br>其核心要解决的问题包括:</p>
<ul>
<li>符号重定位 ： 不同obj文件里面的地址在调整之后，需要调整对应的一些地址（函数地址，变量地址等）；解决方案是每个obj都有一个重定位段，用于记录需要重定位的地址和符号信息(<code>.rel.text</code>,<code>.rel.data</code>等 )</li>
<li>符号决策：强符号/弱符号</li>
</ul>
<p>总的来说，静态链接是比较简单，可以理解为就是简单的代码拷贝，加上基址重定位</p>
<h2 id="动态库实现"><a href="#动态库实现" class="headerlink" title="动态库实现"></a>动态库实现</h2><p>如上，静态库存在两个比较大的问题：</p>
<ul>
<li>bin文件对存储空间的浪费</li>
<li>执行时候对内存的浪费</li>
</ul>
<p>解决的思路很简单，就是让bin链接的库是动态加载的，一个简单的办法就是让上面做静态链接的过程放在程序的加载过程，也就是所谓的装载重定位(<code>-shared</code>标签)，但装载重定位存在一个问题就是，不同的bin的装载的地址不一致，导致加载进来的动态库的虚存地址也不一致，因此并不能起到节省内存的效果，如何解决呢？</p>
<p>方法就是让编译出来的so地址无关，这样无论应用程序把so装载到那个地方，所有的经常都能恭喜相同的代码段。</p>
<p>要生成地址无关的代码(<code>-fPIC</code>),解决也比较简单。由于每个so最终会主要包括两个段: text段和data段，其中text段是要共享的，data段是每个进程都会有的，而data和text的偏移量的固定的，因此所有的地址都可以先存在data段(<code>GOT表</code>)，然后访问的时候先去访问GOT表，获取真正的地址。</p>
<p>事实上，为了优化动态库的加载速度等，系统还做了一些比如延迟加载等技术，这里就不深入探讨。</p>
<h2 id="linux动态库的组织"><a href="#linux动态库的组织" class="headerlink" title="linux动态库的组织"></a>linux动态库的组织</h2><p>所谓的动态库的组织，其实就是要提供一个通用的机制方便其他elf文件加载&amp;链接，核心解决两个问题</p>
<h3 id="去哪里找"><a href="#去哪里找" class="headerlink" title="去哪里找"></a>去哪里找</h3><ol>
<li>系统路径: /lib, /usr/lib, /usr/loca/lib, 可以参看FHS规范</li>
<li>配置查找路径: 查看<code>ld.so.con</code>配置的路径</li>
<li>一些系统变量，比如LD_LIBRARY_PATH</li>
</ol>
<p>查找的规则顺序是3-&gt;2-&gt;1 </p>
<p>其他一些可以关注的点包括: LD_PRELOAD, LD_DEBUG, -rpath</p>
<h3 id="找哪个"><a href="#找哪个" class="headerlink" title="找哪个"></a>找哪个</h3><p>由于动态库可能会一直升级，基本我们找到了那个so，我们能否使用之，会不会版本太老或者太新等。为止，我们需要有相关的规范约定动态库能够被使用，具体来说，由如下三个部分沟通:</p>
<h4 id="so版本库概念"><a href="#so版本库概念" class="headerlink" title="so版本库概念"></a>so版本库概念</h4><p>具体约定每个so按照如下命名规则:</p>
<p>lib_name_.so._x_._y_._z_</p>
<ul>
<li>x : 主版本号,表示重大升级，不同主版本号可以不兼容</li>
<li>y : 次版本号，表示增量升级，新建一些接口，且会兼容老的版本</li>
<li>z : 发布版本号，一般表示库的错误的修正，不增加新的接口，兼容老版本</li>
</ul>
<p>由上，我们只要保证一个程序在查找so的时候满足如下规则即可:</p>
<ul>
<li>相同的主版本号</li>
<li>查找到次版本号高于或者等于程序需要的此版本号</li>
</ul>
<h4 id="so-name"><a href="#so-name" class="headerlink" title="so-name"></a>so-name</h4><p>so-name简单的说，就是表示一个程序要链接的so-name，so-name是可以让应用程序就记录<code>so-name</code>，而非具体的so的版本信息，故<code>so-name</code>主要定义如下:</p>
<ul>
<li>每个so-name 包括libname和主版本号信息，比如libtest.2，2是主版本</li>
<li>由于主版本不能保证指向的so能兼容所有程序，姑系统会让<code>so-name</code>指向该主版本对应的最高的此版本so,比如:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ll libtest.so.2</div><div class="line">libtest.so.2 -&gt; libtest.so.2.4.1 [2.4是最高的次版本]</div></pre></td></tr></table></figure>
<p>在ELF文件<code>.dynamic</code>段里面记录的链接库信息就是用的so-name</p>
<p>同时为了保证总能指向最新的此版本so，当so升级的时候，需要运行<code>ldconfig</code>去调整so-name对应的软连接</p>
<h4 id="符号版本机制"><a href="#符号版本机制" class="headerlink" title="符号版本机制"></a>符号版本机制</h4><p>so-name虽然能解决很大一部分问题，但是有时候，我们希望做更细粒度的控制，比如如果一个so升级了，但是其中部分函数没有修改，我们依旧希望这个部分的代码能被老版本的ELF使用，怎么做呢？很多简单，就是给每个符号加一个版本信息</p>
<p>当在linux gcc下面其实上述符号版本并没有大规模使用，gcc通报拆分so（glibc软件包提供了20多个共享库）,来达到细粒度控制so版本的目标。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>一些异类，主要是两类 最核心的so，包括:</p>
<ul>
<li>glibc :</li>
<li>ld : </li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-Distributed_systems_for_fun_and_profit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/25/Distributed_systems_for_fun_and_profit/">Distributed systems for fun and profit读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/01/25/Distributed_systems_for_fun_and_profit/" class="article-date">
  <time datetime="2015-01-25T08:26:33.000Z" itemprop="datePublished">2015-01-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>如果我们有足够的资金，我们大可以不使用什么分布式系统，把硬件弄的足够牛逼即可。</p>
<p>但是，不行。因此我们的愿景的采用商用的普通的服务器就能支持我们超大计算量，存储量的需求。</p>
<p>我们关注的是如果设计一个分布式的系统，我们的核心目标包括:</p>
<ul>
<li><p>可扩展性:</p>
</li>
<li><p>性能(或者说延迟):</p>
</li>
<li><p>可用性:</p>
</li>
</ul>
<p>而我们面临的挑战是:</p>
<p>主要有两个核心的物理因素:</p>
<ul>
<li>节点的个数:</li>
<li>节点的距离(主要是交互时延) ：</li>
</ul>
<p>受到上面两个因素的影响:</p>
<ol>
<li>节点个数的增加意味着系统里面节点失效概率的增加；</li>
<li>节点个数的增加意味着节点直接的交互也会增加;</li>
<li>而节点地理位置的间隔也意味着交互交互延迟的增加</li>
</ol>
<p>另外还有一个所谓的<code>智能性</code>，因为</p>
<p>如何做？</p>
<p>抽象&amp;建模</p>
<p>对于数据如何存储在分布式节点上面，两个核心的办法,包括:</p>
<ol>
<li>分片 : 可以将每一个节点上面的数据量减少；</li>
<li>复制<ul>
<li>优点: 冗余的话可以发挥多个节点的计算能力</li>
<li>优点: 冗余的话可以提高系统的容错性</li>
<li>缺点: 复制要求着数据拷贝，也就是意味着我们必须遵循一个特定的数据一致性模型（强一致，弱一致)?</li>
</ul>
</li>
</ol>
<h2 id="抽象和建模"><a href="#抽象和建模" class="headerlink" title="抽象和建模"></a>抽象和建模</h2><h3 id="系统条件和结果抽象"><a href="#系统条件和结果抽象" class="headerlink" title="系统条件和结果抽象"></a>系统条件和结果抽象</h3><p>系统模型，一个分布式系统意味着有如下特征:</p>
<ul>
<li>并行的计算和存储</li>
<li>节点直接通过网络交互</li>
<li>没有共享内存和全局时钟</li>
</ul>
<p>而我们在建立一个系统模型的时候，其实就是抽象和简化整个系统的特征，对于一个分布式系统，我们主要关心:</p>
<ul>
<li>节点拥有什么样的能力，他们什么时候会挂掉？<ul>
<li>一般只是crash</li>
<li>不考虑节点欺骗的情况，比如拜占庭问题 </li>
</ul>
</li>
<li>节点直接的交互状态是怎么样的？<ul>
<li>消息是否会丢弃：</li>
<li>是否会发生网络分区的情况</li>
</ul>
</li>
<li>系统的属性，比如消息发送的时序性<ul>
<li>同步系统:</li>
<li>异步系统: 消息的分发和处理都是无序的</li>
</ul>
</li>
</ul>
<p>基于如上三个核心属性的抽象，再引入一个结果的抽象： <code>一致性要求</code></p>
<h3 id="两个基本理论"><a href="#两个基本理论" class="headerlink" title="两个基本理论"></a>两个基本理论</h3><p>第一个是 FLP理论， 跳过<br>第二个是 CAP理论, 这个大家可能听到的比较多，具体为:</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><ul>
<li><p>强一致性</p>
</li>
<li><p>弱一致性</p>
<ul>
<li>基于client控制的一致性支持</li>
<li>最终一致性</li>
</ul>
</li>
<li><p><a href="http://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="external">CAP理论</a></p>
</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-distribute_store_system" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/10/distribute_store_system/">分布式存储系统总结</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/01/10/distribute_store_system/" class="article-date">
  <time datetime="2015-01-10T08:20:03.000Z" itemprop="datePublished">2015-01-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>分布式存储系统VS单机存储: 存储在多个机器!!!</p>
<p>引发的问题:</p>
<p>原来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client --&gt; store system</div></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client ___&gt; st1</div><div class="line">        \_&gt; st2</div><div class="line">        \_&gt; st3</div></pre></td></tr></table></figure>
<ol>
<li>存储的分布式: 哪种策略做分布式(client-&gt;st的策略)：负载均衡，支持扩展性;</li>
<li>容错性: st1,st2…容易出现异常，系统需要具有容错的能力;</li>
<li>事务性的支持: 传统单机的事务保证如果在分布式系统给予支持;</li>
</ol>
<h2 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h2><p>根据具体的存储数据模式，对整个系统的设计也相差很大，下面是一个简单的划分:</p>
<ol>
<li>分布式文件系统:</li>
<li>分布式键值系统：</li>
<li>分布式表格系统:</li>
<li>分布式数据库:</li>
</ol>
<p>个人理解，上面四个系统的功能逐渐复杂，系统设计也是依次复杂;</p>
<h2 id="核心协议"><a href="#核心协议" class="headerlink" title="核心协议"></a>核心协议</h2><blockquote>
<p>个人理解</p>
</blockquote>
<p>核心协议拥有抽象分布式系统常见的问题，并且提供一个通用的解决方案，这里面主要说到两个比较重要的协议</p>
<p>### </p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-rsync_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/30/rsync_bitch_about/">由rsync命令引发的</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/30/rsync_bitch_about/" class="article-date">
  <time datetime="2014-12-29T16:57:41.000Z" itemprop="datePublished">2014-12-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在鼓捣静态集群，而rsync是我们用于同步不同机器之间文件的一个最为传统的方式，因此认真研究了一遍，到现在总得有两个收获：</p>
<ul>
<li>rsync的算法</li>
<li>对常见命令的使用感概</li>
</ul>
<h2 id="rsync算法"><a href="#rsync算法" class="headerlink" title="rsync算法"></a>rsync算法</h2><p>先简单说下rsync的算法吧，这个其实在很多blog都有，这边我简单描述下，不过希望是以推敲的方式导出:</p>
<p>假设我们现在要同步两个文件src(机器 FROM )和dst(机器 TO)，他们在不同的机器上面，现在rsync算法核心要解决的问题是:</p>
<blockquote>
<p>在src和dst文件相似的情况下，尽量少的带宽来同步问题</p>
</blockquote>
<p>基于这个目标，算法的核心思路其实就是在src尽量发现dst已经存在的内容（这样就不需要传输了呗）</p>
<p>因此最好有个算法能够把dst的摘要传输到src这边；然后src能够比对dst哪些是已经存在的，哪些是不存在的；基于此在TO机器上面生成目标问题；故简单算法如下:</p>
<ol>
<li>TO机器上面，对dst文件算相关摘要，然后发给FROM机器</li>
<li>FROM机器根据摘要，分析出dst哪些部分是和src一致的，哪些是不一致的；不一致的需要全部传输，一直的只要发送标记就可以了, 算好之后，生成一个新的文件信息，发给TO机器</li>
<li>TO机器跟进新的文件信息，构建新的目标问题</li>
</ol>
<p>这个是核心思路，剩余两个问题：</p>
<ul>
<li>摘要的计算： 一般需要分段&amp;hash校验</li>
<li>src如何快速和dst的摘要做对比，同样需要注意：<ol>
<li>src这边的匹配，需要支持快速的从(k1,k2,…kn) –&gt; (k2,k3,…k(n+1)) ：这样才支持src这边一个一个比对</li>
<li>dst过来的时候，最好对摘要（很多摘要）算相关的hash，这样的话，src可以快速知道摘要是否在dst存在;</li>
</ol>
</li>
</ul>
<p>对于前者，我们需要引入一个一个类似<code>rolling hash</code>的特定hash算法；对于后者，我们一般在hash是一个方式，其他的快速排序好的查找也是一个方式；</p>
<h2 id="对常用命令的感慨"><a href="#对常用命令的感慨" class="headerlink" title="对常用命令的感慨"></a>对常用命令的感慨</h2><ul>
<li>很多命令了解仅限于表面</li>
<li>对常用的命令没有做很好的系统归纳和梳理</li>
</ul>
<p>尤其是后者，争取找个时间弄个和linux命令相关的总结</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://coolshell.cn/articles/7425.html" target="_blank" rel="external">http://coolshell.cn/articles/7425.html</a> : 对rolling sum说明的有点问题</li>
<li><a href="http://rsync.samba.org/tech_report/tech_report.html" target="_blank" rel="external">http://rsync.samba.org/tech_report/tech_report.html</a> 作者是算法说明</li>
<li><a href="http://en.wikipedia.org/wiki/Rsync#Algorithm" target="_blank" rel="external">http://en.wikipedia.org/wiki/Rsync#Algorithm</a> 维基百科的说明，一直都很专业</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-linux_lock_impl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/linux_lock_impl/">linux 常见锁说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/27/linux_lock_impl/" class="article-date">
  <time datetime="2014-12-27T07:02:14.000Z" itemprop="datePublished">2014-12-27</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前一次的文章<a href="http://shevacjs.com/lock/2014/12/13/lock/">锁机制概述</a>，大致简单说明了MP系统下面锁的基本原理。这里，再简单说明下在2.6内核体系下面，linux支持的锁，包括内核态和用户态(pthread系列的)。</p>
<h2 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是最基本的锁支持，在linux内核下，自旋锁的API有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irqsave</span><span class="params">(<span class="keyword">spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></div></pre></td></tr></table></figure>
<p>其中<code>irqsave</code>和<code>bh</code>都是处理和中断有关的，因为在中断等上下文一旦处理不好就可能导致死锁。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量可以任务是提供一个支持睡醒的锁支持，</p>
<h3 id="基于性能优化的衍生锁"><a href="#基于性能优化的衍生锁" class="headerlink" title="基于性能优化的衍生锁"></a>基于性能优化的衍生锁</h3><p>这里主要介绍两种, 他们都是针对读写锁的优化，一般都是只试用在一般的场景，这简单说明他们的设计思路。</p>
<ul>
<li>Seq Lock :</li>
</ul>
<p>seq lock考虑的场景是读多写少。因此在正常读取的时候，如果加上spinlock的收益是非常低的，故其采取如下策略:</p>
<ul>
<li>允许多个读者同时访问数据，同时只允许一个写者在更新数据；</li>
<li>核心指导思想是，通过一个flag来标记要保护的区段的数据是否被更新过，读者可以冲入的读，但需要通过flag来判别是否数据被更新过，如果是，读者需要重新读取新的数据，故读，写者分工如下:<ul>
<li>读者：读取之后，判断flag，以决定是否需要重新读取</li>
<li>写者：在修改数据的时候需要更新flag</li>
</ul>
</li>
</ul>
<p>如下是简单的示意图：其中读者需要判断<code>((count_pre != count_post) &amp;&amp; (count_pre % 2 == 0))</code>来决定数据是否被更新/正在被更新</p>
<p><img src="seqlock_demo.png" alt="seqlock_demo"></p>
<ul>
<li>Rcu Lock</li>
</ul>
<p>RCU也是对读写锁的一个优化，适用的场景也是读多写少，但是有其独特的应用场景，先考虑seqlock存在的问题：</p>
<ul>
<li>seq-lock可以认为是写优先的，读需要重复频繁的读来确认数据没有被更新；</li>
<li>seq-lock保护的数据一般是要求不能含有指针的，因为写者很容易直接更新指针的内容，demo如下:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">char</span>* info;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// sql-lock reader</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    data copy_data = curr_data;</div><div class="line">&#125; <span class="keyword">while</span>(no change)</div><div class="line"></div><div class="line"><span class="comment">// do something with copy data</span></div><div class="line"></div><div class="line">f(copy_data)</div></pre></td></tr></table></figure>
<p>这个里面的copy data其实是可能存在问题的,其对应的info等内容是会被修改的，而这个情况又是内核里面最最常见的场景，需要有更好的解决方案，RCU就是要提供这种支持的，RCU的特性包括：</p>
<ul>
<li>RCU是读者优先的，读者不需要任何互斥也不需要任何锁，直接读取就OK；</li>
<li>写者的核心指导思想是(Read-Copy Update), 写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。</li>
</ul>
<p>思路是比较简单的，但是实现上面还是比较复杂的，这里就不详述，具体可以参考推荐的RCU文章;</p>
<h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><h2 id="锁的资源消耗"><a href="#锁的资源消耗" class="headerlink" title="锁的资源消耗"></a>锁的资源消耗</h2><h2 id="遗留问题-amp-思考"><a href="#遗留问题-amp-思考" class="headerlink" title="遗留问题&amp;思考"></a>遗留问题&amp;思考</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><ul>
<li>seqlock,rcu等的维基百科，都有非常系统的介绍</li>
<li><a href="http://blog.sina.com.cn/s/blog_5210e67e0100935d.html" target="_blank" rel="external">Linux 内核的同步机制，第4部分顺序锁（seqlock</a></li>
<li><a href="http://www.verydemo.com/cj.jsp?c=34&amp;u=linuxseqlockamprcu-qian-xi-duo-xian-cheng-zhi-shun-xu-suo" target="_blank" rel="external">linux seqlock &amp; rcu 浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/" target="_blank" rel="external">Linux 2.6内核中新的锁机制–RCU</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-lockfree/" target="_blank" rel="external">透过 Linux 内核看无锁编程</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-1226_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/1226_bitch_about/">1227吐槽</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/27/1226_bitch_about/" class="article-date">
  <time datetime="2014-12-26T17:01:06.000Z" itemprop="datePublished">2014-12-27</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是2014-12-27凌晨1点左右，又是半夜，发现睡前吐槽是个好习惯。</p>
<p>明天就是周六了，早上可以好好睡一觉的吧，这是我现在能想到最开心的事情了。</p>
<p>这周忙的要死，基本上每天一到公司，就像陀螺一直在转一样，还有一些乱七八糟的事情，但很多事情走没有预想中的顺利，唉，都不知怎么办，只能自己一个一个搞，希望自己能坚持下去。</p>
<ul>
<li>周一周二忘了干嘛了。。。</li>
<li>周三：上午CBG-BIT技术培训，交流ksarch规划，讨论静态集群事情，讨论运维的事情</li>
<li>周四：上午server端RD例会，下午思考明年规划，然后3个小时讨论明年规划</li>
<li>周五：上午例会，静态文件处理，下午静态集群交流，CDN沟通，运维跟进，报警跟进</li>
</ul>
<p>今天周五也不是那么太平，一直在跟一个客户端的问题，20：30左右的时候才搞完，然后跑去球场的时候都快20：50了，踢了差不多40分钟的球，意兴阑珊的回来，才发现肚子好饿。最讨厌的就是，小区门口基本上没有一个可以吃饭的地方，尤其是供一个人吃饭的地方，弄的我现在特讨厌周末吃饭，选择困难啊。</p>
<p>这两天得花个时间写自己工作上面的年度总结，其实自己心里默想了，唉，失多得少，悲大于喜，也不知作何言。</p>
<p>当然也有开心的事情，晚上六点多的时候，我妈电话我了，我妹生了个女儿，不过我还不知道如何称呼之:)</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-an_problem_about_so_copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/23/an_problem_about_so_copy/">一个so不能copy引发的问题&amp;思考</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2014/12/23/an_problem_about_so_copy/" class="article-date">
  <time datetime="2014-12-22T17:23:09.000Z" itemprop="datePublished">2014-12-23</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>问题的背景其实比较简单，也很常见，就是如果一个bin文件，通过<code>dlopen</code>的方式打开so，继续连接的时候；在程序进行升级的时候，如果bin文件还在执行，不能简单的copy，一般是需要用mv之类的方法，否则很容易出core。</p>
<p>这是为什么呢？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先比较cp命令和mv命令的区别，大致如下：</p>
<ul>
<li>cp –&gt; open(O_WRONLY | O_TRUNC) : 原来文件的inode不变，修改内容</li>
<li>mv –&gt; unlink | create ：删除原来文件, inode 失效</li>
</ul>
<p>总而言之，<code>最大的区别是inode的节点的变化</code>。那这为什么会导致程序出core呢？</p>
<p>这个推敲过程比较复杂，这里就简单说明概括性的结论,而且结论还不一定对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>下面分析仅仅使用于linux</p>
</blockquote>
<ul>
<li><p>为什么可以被copy？<br>  linux下面的文件被加载到内存执行，一般就两个情况，一个是exe/bin文件，一个是so文件。理论上，或者理想的话，一个文件如果被加载到内存，且程序在被执行过程，这个时候对他的原始文件的修改，是应该不被允许的。而事实上，是怎么样的呢？</p>
<ul>
<li>对bin文件：的确系统提供了保护机制，但是系统监控的最要是以inode节点为依据的。也就是说，如果你对同一个inode节点做变更的话，是不被允许的（也就是会发生TEXT BUSY)之类的错误；但是你如果先unlink，在copy一个同样名字的bin文件过来，就是可以的（这也就是linux可以热升级bin文件的缘故）。</li>
<li>对动态加载的so文件，系统是通过mmap映射文件加载进来的，早期的linux支持DENYWRITE的选项，后来废弃了（man手册上面说明是因为会导致dos攻击，为什么？）。因此理论上我们是可以随便把一个内容cp到一个正在运行的so上面的。</li>
</ul>
</li>
<li><p>copy发生了什么?<br>  明确了so可以被copy后，让我们看为什么copy之后会发生core呢？理论上你的东西都已经跑到内存里面了，我随便改改文件应该没什么影响啊？根据<code>深入理解LINUX内核</code>上面对mmap的说明，大概猜测如下：</p>
<ul>
<li>linux是有页高速缓存的，用于缓存文件的内容；</li>
<li>mmap做内存文件映射的时候，其实并没有开辟什么新的内存空间，而是直接指向了页高速缓存的区域；</li>
<li><p>当外部程序对文件进行修改的时候，页高速缓存就会失效；下一次主程序读取的时候，就会重新从磁盘文件里面加载最小的文件内容；(这个通过程序的验证，可以通过写个mmap的程序读取会动态发生内容改变的程序);</p>
<p>总的来说，通过mmap获取的内存区域，在文件发生内容变化的时候，其内存地址对于的内容也会发生改变</p>
</li>
</ul>
</li>
<li><p>程序为什么会core呢？</p>
<p>  有了上面的基础，整个原因就比较清晰了；因为一个so里面被加载之后，总是需要做地址重定向的；在copy发生后，我们只是简单的更改了内容，当没有重定向地址，这样就导致了此时在访问次共享内存的时候，很多地址都是无效的，那肯定容易出core啊</p>
</li>
</ul>
<h2 id="跟进"><a href="#跟进" class="headerlink" title="跟进"></a>跟进</h2><ul>
<li>页高速缓存的机制</li>
<li>linux常见命令对应的操作系统调用情况</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://unix.stackexchange.com/questions/74142/why-does-a-software-package-run-just-fine-even-when-it-is-being-upgraded?lq=1" target="_blank" rel="external">Why does a software package run just fine even when it is being upgraded?</a></li>
<li><a href="http://unix.stackexchange.com/questions/74165/how-to-upgrade-shared-library-without-crash" target="_blank" rel="external">How to upgrade shared library without crash?</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_622a99700100pjv3.html" target="_blank" rel="external">linux下So覆盖导致coredump问题的分析</a></li>
<li><a href="http://www.piao2010.com/%E4%B8%BA%E4%BD%95cp%E8%A6%86%E7%9B%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93so%E4%BC%9A%E5%AF%BC%E8%87%B4coredump" target="_blank" rel="external">为何cp覆盖进程的动态库(so)会导致coredump</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/10/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>