<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/11/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-nginx_https_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/nginx_https_proxy/">nginx与https -- 正向代理支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/25/nginx_https_proxy/" class="article-date">
  <time datetime="2015-04-25T07:34:36.000Z" itemprop="datePublished">2015-04-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，nginx的对于http(s)反向代理的支持一直不错，但对正向代理(正向VS反向代理区别，见<a href="http://z00w00.blog.51cto.com/515114/1031287" target="_blank" rel="external">图解正向代理、反向代理、透明代理</a>)的支持如何呢？</p>
<p>对于http正向代理, nginx很早就支持了，具体如何配置nginx的正向代理可以见:<a href="http://rhomobi.com/topics/94" target="_blank" rel="external">Nginx配置正向http代理</a></p>
<p>而对于https的正向代理，nginx是从1.5.6版本，才开始逐渐支持, 现在看来其实是比较晚的版本，可以理解要支持https正向代理还是需要一些成本的。本文主要简单介绍下nginx要支持https需要支持的运行机制以及具体如何配置nginx才能支持https。代码层面的实现，暂不赘述。</p>
<p>希望通过这篇文件让大家了解如何配置nginx的https正向代理，以及对https协议有个简单的了解。</p>
<h2 id="要怎么做"><a href="#要怎么做" class="headerlink" title="要怎么做"></a>要怎么做</h2><p>如上，如果支持了https，就是要在和upstream交互的过程中支持https协议，如下是TLS协议的示意图，总的来说就是会多一些HTTPS握手的流程，因此nginx在具体实现上面就是需要支持HTTPS握手，以及此方面的相关配置：</p>
<p><img src="/images/ssl-handshake.png" alt="ssl-handshake.png"></p>
<p>就是要实现一个完整的<code>client-hello</code>, <code>client key change</code>等(如果做https反向代理，主要做的事情是<code>server hello</code>等)，好在openssl库其实此类都有完整的支持，nginx只需要根据自己的框架套进去就可以了。</p>
<p>同样，nginx对正向代理的支持，也就体现在对client这边行为的控制。</p>
<h2 id="nginx支持哪些"><a href="#nginx支持哪些" class="headerlink" title="nginx支持哪些"></a>nginx支持哪些</h2><p>通过上面的分析，nginx具体在支持请求https的时候，主要是包括如下几个方面的控制:</p>
<h4 id="对server的验证和识别"><a href="#对server的验证和识别" class="headerlink" title="对server的验证和识别"></a>对server的验证和识别</h4><p>传统情况下，我们对server的失败是通过浏览器内部以及相关配置的CA去做的，现在如果让nginx去连接https服务器，而且我们也希望做相关的身份验证的话, 就得配置相关的CA以及证书链之类的，具体包括:</p>
<ul>
<li>proxy_ssl_verify : 是否验证服务端</li>
<li>proxy_ssl_crl : 配置验证服务端的CRL(吊销证书列表)</li>
<li>proxy_ssl_trusted_certificate : 配置验证服务端的CA列表</li>
<li>proxy_ssl_verify_depth : 配置验证证书链的深度</li>
</ul>
<h4 id="对client的标识"><a href="#对client的标识" class="headerlink" title="对client的标识"></a>对client的标识</h4><p>有些情况下，server端还会有对client端进行身份验证的需求（比如vpn登陆），因此nginx还支持配置client端的证书信息，具体包括:</p>
<ul>
<li>proxy_ssl_certificate : 指定client公钥文件的地址</li>
<li>proxy_ssl_certificate_key : 指定client密钥文件地址</li>
<li>proxy_ssl_ciphers : 指定可以采用的加密算法列表</li>
<li>proxy_ssl_protocols : 指定要采用的HTTPS(TLS协议)</li>
<li>proxy_ssl_name : 指定用于要访问和SNI里面传送的域名，默认用的是proxy_pass的URL域名</li>
<li>proxy_ssl_password_file : 指定密钥文件（待明确!）</li>
</ul>
<h4 id="其他性能-优化相关的"><a href="#其他性能-优化相关的" class="headerlink" title="其他性能/优化相关的"></a>其他性能/优化相关的</h4><ul>
<li>proxy_ssl_server_name : 是否启用SNI机制</li>
<li>proxy_ssl_session_reuse : 是否复用ssl session</li>
</ul>
<p>其中<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="external">SNI机制</a>，可以简单理解是允许在发送https请求加个类似http协议里面的host域，这样允许一个IP和PORT同时支持多个域名</p>
<p>而SSL Session机制则允许减少<code>TLS握手的次数</code>, 包括sesseion tickets和session identifier; 启用这个的话，nginx内部会用<code>SSL_session_reused</code>尝试复用，具体https的性能优化和内部策略，后面一篇文章(nginx的https反向代理支持)再细说。</p>
<h2 id="配置demo"><a href="#配置demo" class="headerlink" title="配置demo"></a>配置demo</h2><p>如下是nginx正向代理的配置的demo（开启服务端检测)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">location</span> / &#123;</div><div class="line">    <span class="attribute">proxy_ssl_verify</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">proxy_ssl_trusted_certificate</span> /home/users/chenjiansen/nginx_ssl/root_ca.pem;</div><div class="line">    <span class="attribute">proxy_ssl_verify_depth</span> <span class="number">9</span>;</div><div class="line">    <span class="attribute">proxy_pass</span> https://<span class="variable">$http_host</span><span class="variable">$request_uri</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> <span class="string">"user-agent"</span> <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTM</span></div><div class="line">L, like Gecko) Chrome/42.0.2311.90 Safari/537.36';</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用如下命令可以尝试验证https代理的可用性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">"cq01-rdqa-dev028.xxxxx.com:8300"</span> -H<span class="string">"Host:www.baidu.com"</span></div></pre></td></tr></table></figure>
<h2 id="部署建议"><a href="#部署建议" class="headerlink" title="部署建议"></a>部署建议</h2><p>现在我们具体生产部署的时候，一般是调用一些第三方的支付接口，建议如下:</p>
<ul>
<li>开启服务端验证机制, 避免中间人攻击</li>
<li>根证书的配置尽量最少原则的, 不要配置太多无用的根证书。比如，我们如果明确就是用一个location访问<code>https://www.baidu.com</code>，而百度域的根证书是<code>VeriSign Class 3 Public Primary Certification Authority - G5</code> ，这样的话，我们的CA列表只要有这个根证书就可以了</li>
</ul>
<p>而一些其他的业务需求，对安全性等要求不是很高的话，可以按需调整。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://support.microsoft.com/en-us/kb/823503/zh-cn" target="_blank" rel="external">导入和导出证书以便能够在多台计算机上使用</a>, MAC系统更简单，在<code>钥匙串</code>里面直接点击导出即可</li>
<li><p><a href="http://nginx.com/resources/admin-guide/nginx-tcp-ssl-upstreams/" target="_blank" rel="external">Securing TCP Traffic to Upstream Servers</a></p>
</li>
<li><p><a href="http://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html" target="_blank" rel="external">Speeding up SSL: enabling session reuse</a></p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-anti_censorship" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/anti_censorship/">翻墙杂谈</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/05/anti_censorship/" class="article-date">
  <time datetime="2015-04-05T11:01:40.000Z" itemprop="datePublished">2015-04-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-缘由"><a href="#1-缘由" class="headerlink" title="1. 缘由"></a>1. 缘由</h2><p>HC上面的一篇文件<a href="http://sites.inka.de/~W1011/devel/tcp-tcp.html" target="_blank" rel="external">Why TCP Over TCP Is A Bad Idea</a>，顺便梳理下之前零碎的几个知识点, 主要是一些代理，穿透的网络协议的乱七八糟的东西，这里主要说翻墙的一些手段和办法, 以此来说明网路穿透的一些相关机制。</p>
<h2 id="2-一些基础"><a href="#2-一些基础" class="headerlink" title="2. 一些基础"></a>2. 一些基础</h2><p>要翻墙前提是得有个VPS，可以自己去购买或者之类的，据同事反馈<a href="http://www.linode.name/" target="_blank" rel="external">linode</a>是不错的选择。有了VPS的话，现在问题就是如何利用VPS进行翻墙?</p>
<p>如下是简单的网络架构:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client ----(GFW) ---&gt; VPS -----&gt; foreign website</div></pre></td></tr></table></figure>
<p>因此我们需要达到的功能其实可以简化成如下两个步骤:</p>
<ul>
<li>找个一个协议能够连上VPS</li>
<li>让VPS上面的具体软件转发请求并且透传回来</li>
</ul>
<h3 id="2-1-连接VPS的方法"><a href="#2-1-连接VPS的方法" class="headerlink" title="2.1 连接VPS的方法"></a>2.1 连接VPS的方法</h3><blockquote>
<p>PS本部分都是自己理解，全凭自己猜测</p>
</blockquote>
<p>连接vps不仅仅是能ping到这个机器，一般是指能够安全加密的和改VPS交互，总结起来大概可以统称为<a href="http://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">隧道协议</a>, 而隧道协议可以根据协议所工作的ISO层，有如下几类:</p>
<h5 id="2-1-1-VPN协议"><a href="#2-1-1-VPN协议" class="headerlink" title="2.1.1 VPN协议"></a>2.1.1 VPN协议</h5><p>用于传统支持VPN的相关协议，一般是工作在网络层以下（含），具体包括:</p>
<ul>
<li>PPTP/L2TP : 都是基于PPP协议的二层隧道协议, 工作在数据链路层</li>
<li>IPsec/AppleTalk : 三层隧道协议,工作在网络层</li>
</ul>
<h5 id="2-1-2-会话层协议"><a href="#2-1-2-会话层协议" class="headerlink" title="2.1.2 会话层协议"></a>2.1.2 会话层协议</h5><p>这方面的代表主要是<a href="http://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="external">SOCKS协议</a>, 也是我们常见的SOCKS代理实现的协议</p>
<h5 id="2-1-3-应用层协议"><a href="#2-1-3-应用层协议" class="headerlink" title="2.1.3 应用层协议"></a>2.1.3 应用层协议</h5><p>具体的包括SSH隧道，一个通过SSH协议建立起来的连接隧道</p>
<h3 id="2-2-请求转发"><a href="#2-2-请求转发" class="headerlink" title="2.2 请求转发"></a>2.2 请求转发</h3><p>一旦你连接上了一个具体的服务器，要做请求转发相对来说就比较容易了，而且此事一般是代理软件帮你完成的，同样跟进理解到服务器的协议的不同，代理软件也做着不同层次的支持，以我了解到的, 包括:</p>
<ul>
<li>ip层的请求转发，此策略常见于配置VPN服务器的需求，比如如果搭建一个PPTP的服务器，一般需要通过如下方法进行转发:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo sed -i <span class="string">'s/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g'</span> /etc/sysctl.conf</div><div class="line">sudo sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员</span></div><div class="line">sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</div></pre></td></tr></table></figure>
<ul>
<li><p>数据层的转发，主要是SOCKS代理服务器，Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）</p>
</li>
<li><p>应用层的转发，举个例子通过nginx配置正向代理之类的, 用处感觉比较少</p>
</li>
</ul>
<h2 id="3-具体应用"><a href="#3-具体应用" class="headerlink" title="3. 具体应用"></a>3. 具体应用</h2><p>有了上面的基础，我们就可以根据自己的需求创建具体的翻墙策略，这里主要介绍两个，其一是PPTP代理，其二是SSH隧道</p>
<h3 id="3-1-PPTP代理"><a href="#3-1-PPTP代理" class="headerlink" title="3.1 PPTP代理"></a>3.1 PPTP代理</h3><p>PPTP代理的一个优点是快，缺点个人感觉有两个:</p>
<ul>
<li>通用性不强：其对网关有一定的要求，一些路由器之类的不一定支持(比如我们家的TPLINK的某一型号路由器)</li>
<li>可控性或者自由度不够: 由于PPTP工作较为底层，这也就意味着，如果你一旦启用他，整个PC某人情况下都会走代理，但是大多是时候，我们可能指希望某类应用或者协议（比如HTTP)走代理。如果要达到此目标，还需要额外的控制</li>
</ul>
<p>具体如何配置，这里也不赘述，具体可以参看链接: <a href="http://blog.fens.me/ubuntu-vpn-pptp/" target="_blank" rel="external">在Ubuntu上安装PPTP VPN服务</a></p>
<h3 id="3-2-ssh隧道"><a href="#3-2-ssh隧道" class="headerlink" title="3.2 ssh隧道"></a>3.2 ssh隧道</h3><p>如上，SSH隧道是通过ssh协议构建的一个应用层隧道，因此其可以灵活控制。而大多是SSH客户端支持SOCKS代理，也就是通过建立一个动态的SSH转发，其自动启动一个SOCKS代理，这样浏览器等就可以很方便的使用类似SOCKS代理的方式通信了</p>
<p>ssh命令启动一个动态SSH隧道的命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -NTf -D 9000 &lt;ssh server&gt;</div></pre></td></tr></table></figure>
<p>具体可以参考<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战 SSH 端口转发</a></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><p>上面主要介绍了我们如何控制我们机器的网络交互通道来达到翻墙的目标。而对于最常见的HTTP代理，浏览器那边其实也做了一些支持，主要是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="external">代理自动配置</a>，改方案核心思路和上述一样（都是要找代理服务器的啊），但是具体实现层面的话，可以理解是浏览器主动托管了网络交互那层，因此对用户而言，只要配置合理的PAC就可以了, 还是相关不错的</p>
<p>其他的还有很多方案，具体可以参看wiki百科的<a href="http://zh.wikipedia.org/wiki/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="external">突破网络审查</a></p>
<h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h2><p>首先，建议对几个协议，大家可以具体<a href="http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" target="_blank" rel="external">维基百科</a>之</p>
<ul>
<li><a href="http://www.vpninstructions.com/whats-the-difference-between-pptp-l2tp-openvpn-and-socks-when-talking-about-vpns/" target="_blank" rel="external">What’s the difference between PPTP, L2TP, OpenVPN, and SOCKS when talking about VPNs?</a> : 介绍了PPTP,SOCKS等几个协议的异同点</li>
</ul>
<p>ssh相关的:</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战SSH端口转发</a></li>
<li><a href="http://www.iokay.net/it-technology/ssh-proxy" target="_blank" rel="external">利用SSH代理爬墙</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-io_in_linux_and_nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/io_in_linux_and_nginx/">linux和nginx下的异步文件IO管理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/05/io_in_linux_and_nginx/" class="article-date">
  <time datetime="2015-04-05T06:17:28.000Z" itemprop="datePublished">2015-04-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx在其最近发布的<a href="http://nginx.org/en/CHANGES" target="_blank" rel="external">1.7.11版本增加了thread pool</a>的feature, 其引入的<a href="http://nginx.org/en/docs/ngx_core_module.html#thread_pool" target="_blank" rel="external">thread_pool</a>主要是能真正意义的保证读写文件的非阻塞以及异步。为什么需要主动添加<code>thread pool</code>这个机制来支持异步非阻塞的文件读写呢？这里简单说下linux的文件IO管理和以及nginx的thread poo机制的必要性，最后说下nginx thread pool的大致实现机制。</p>
<p>其实关于linux和nginx的IO管理，已经有非常详细的说明文档，具体包括如下:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
</ul>
<p>这里只是针对上面介绍内容的一个简单总结和概述</p>
<h3 id="linux下的异步IO支持"><a href="#linux下的异步IO支持" class="headerlink" title="linux下的异步IO支持"></a>linux下的异步IO支持</h3><p>linux下主要有如下两个方式的异步IO支持，分别如下:</p>
<h4 id="glibc-异步IO支持"><a href="#glibc-异步IO支持" class="headerlink" title="glibc 异步IO支持"></a>glibc 异步IO支持</h4><p>这个是glibc提供的一系列函数，包括<code>aio_read</code>, <code>aio_suspend</code>等(‘man aio_read’查看具体用法), 其核心特点是使用较为方便，但是在实现层面的话，其实是在用户层通过多线程实现的，并非真正意义上面的异步IO，因此其性能相对于真正意义上面的异步IO要慢一些。</p>
<h4 id="native-AIO支持"><a href="#native-AIO支持" class="headerlink" title="native AIO支持"></a>native AIO支持</h4><p>其实linux本身已经提供了对异步io的支持[2.5版本开始]，也就是<code>io_submit</code>, <code>io_setup</code>之类的函数，但是glibc并没有对这类函数进行封装，因此如果要使用的话，可以通过:<br>1) syscall直接调用操作系统API<br>2) <a href="http://lse.sourceforge.net/io/aio.html" target="_blank" rel="external">libaio</a> : 一个轻量级的封装库</p>
<p>来使用。</p>
<p>由于直接是操作系统的支持，因此此类函数的性能相对比与glibc的aio性能上面有较大的提升，但同时也面临着如下两个比较大的问题，导致其应用范围大大受限:</p>
<ul>
<li>使用AIO必须打开<code>IO_DIRECT</code> flag，同时要求读写的的大小和偏移要以区块的方式对齐</li>
<li>启用AIO同时会关闭<code>sendfile</code>，也就意味着此时会丧失了零拷贝的特征；如果继续使用sendfile, 意味着读可能会阻塞</li>
</ul>
<p>总之，在现有的linux体系下，对文件的异步读写，没有完美的简单的解决方案。</p>
<h3 id="nginx对异步IO的支持"><a href="#nginx对异步IO的支持" class="headerlink" title="nginx对异步IO的支持"></a>nginx对异步IO的支持</h3><p>nginx和异步IO相关的主要指令有:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">syntax : aio on | off | thread ;</div><div class="line"></div><div class="line">是否启动aio，如果是指定其关联的thread pool name </div><div class="line"></div><div class="line">syntax : directio size | off ;</div><div class="line"></div><div class="line">是否启用directio; 或者在大于size之后才启用directio</div><div class="line"></div><div class="line">syntax : sendfile on | off  ;</div><div class="line"></div><div class="line">是否启用sendfile </div><div class="line"></div><div class="line">## 加上最新的thread pool</div><div class="line"></div><div class="line">syntax : thread_pool name threads=number [max_queue=number];</div><div class="line"></div><div class="line">创建一个thread pool</div></pre></td></tr></table></figure>
<p>具体可以参看<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#aio" target="_blank" rel="external">nginx官方说明文档</a></p>
<p>基于如上的总结，当<code>aio</code>, <code>directio</code>, <code>sendfile</code>都开启的时候(如果有off的情况，判断较为简单，不在赘述)，整个nginx对文件的读取策略如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                     _  use aio   _</div><div class="line">                   /                \</div><div class="line">                 yes            has thread pool</div><div class="line">                /                      \</div><div class="line">directio &gt; size                        support asyn &amp; noblock IO</div><div class="line">                \                      /</div><div class="line">                 no             has thread pool</div><div class="line">                   \                 /</div><div class="line">                    \_ use sendfile /</div></pre></td></tr></table></figure>
<h3 id="nginx的thread-pool机制"><a href="#nginx的thread-pool机制" class="headerlink" title="nginx的thread pool机制"></a>nginx的thread pool机制</h3><p>本来想详细介绍nginx thread pool的实现机制，但是发现可以展开讨论的内容不多。这里就做个系统性的总结。</p>
<p>由于linux系统对异步IO的支持有着或多或少的局限性，如果nginx要保证其整个worker进程异步非阻塞的模型有一定的难度，因为在读取文件的时候可以存在着阻塞的情况。</p>
<p>为此nginx的解决方案是引入thread pool, 用户可以创建特定个数的thread pool，每个thread pool可以指定其具体的OS线程数。现在thread pool的核心作用就是托管一些可能存在阻塞的IO操作（包括普通的read, sendfile）, 当有此类操作的时候，nginx会根据用户的配置把任务递送给线程池，尽量不阻塞worker进程。</p>
<p>具体到thread pool的实现，没有特别的地方(不过我也没看的特别细)，通过<code>pthread lib</code>维护一堆线程, 用户可以提交具体的task给线程池，让其消费。</p>
<p>其主要作用可能是会提高那些存在高IO读取的webserver的并发支持数。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://cnodejs.org/topic/4f16442ccae1f4aa270010a7" target="_blank" rel="external">linux AIO(异步IO)那点事儿</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></li>
<li><a href="http://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux" target="_blank" rel="external">Difference between POSIX AIO and libaio on Linux?</a></li>
</ul>
<p>lenky关于AIO的系列文章:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2184" target="_blank" rel="external">nginx对Linux native AIO机制的应用(配置篇)</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2186" target="_blank" rel="external">nginx对Linux native AIO机制的应用（实现篇）</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-log_rotation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/log_rotation/">nginx日志切分方案说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/07/log_rotation/" class="article-date">
  <time datetime="2015-03-07T07:34:36.000Z" itemprop="datePublished">2015-03-07</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx的日志切分问题一直是运维nginx时需要重点关注的。本文将简单说明下nginx支持的两种日志切分方式。</p>
<h3 id="定时任务切分"><a href="#定时任务切分" class="headerlink" title="定时任务切分"></a>定时任务切分</h3><p>所谓的定时任务切分，是指通过定时任务（比如<code>crontab</code>)，发送信号给nginx，让其重新打开文件。该方法也是nginx官网上面比较推荐的,<a href="http:http://wiki.nginx.org/LogRotation" target="_blank" rel="external">原文</a>说明比较清楚，这里在说明下：</p>
<p>发送<code>USR1</code> 信号会让nginx主动重新打开日志文件，故操作如下：</p>
<pre><code>$ mv access.log access.log.0
$ kill -USR1 `cat master.nginx.pid`
$ sleep 1
$ gzip access.log.0    # do something with access.log.0
</code></pre><p>总结 ：优点是思路较为简单，但效果明显，而且对error_log 同样适用；缺点是有外部依赖（比如 <code>crontab</code>)</p>
<h3 id="自切分"><a href="#自切分" class="headerlink" title="自切分"></a>自切分</h3><p>自切分是指让nginx自身实现日志切分功能，不依赖crontab等东西。 其主要原理是依赖access_log的强大功能—- 可以用变量定义请求的log路径。</p>
<p>nginx的acess_log 功能非常强大，其完整指令说明如下，这里主要说明定义日志路径的功能；关于syslog还有gzip, buffer等特性，后续再说明。</p>
<p>access_log指令:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	Syntax:	access_log path [format [buffer=size [flush=time]] [if=condition]];</div><div class="line">			   access_log path format gzip[=level] [buffer=size] [flush=time] [if=condition];</div><div class="line">			   access_log syslog:server=address[,parameter=value] [format [if=condition]];</div><div class="line">			   access_log off;</div><div class="line">	Default:	access_log logs/access.log combined;</div><div class="line">	Context:	http, server, location, if in location, limit_except</div><div class="line">    </div><div class="line">```	</div><div class="line">    </div><div class="line">注意path部分是支持nignx变量的，这也就意味这我们只要通过配置正确的nginx变量，就可以实现小时等级别的日志自动拆分了。</div><div class="line"></div><div class="line">一个简单的问题就出现了，假设nginx要实现这个机制，那岂不是每打印一个请求log就得打开文件，写日志，关闭文件？ 这样显然效率太差了，为了解决这个问题，nginx又引入了一个机制，叫做 open_file_cache，简单的说，这个东西的功能就是会缓存打开的文件，只有满足一定条件的时候才会重新去check当前fd对应的文件是否合法，是否需要重新打开。 open file cache的指令如下：</div><div class="line"></div><div class="line">```nginx</div><div class="line"></div><div class="line">	Syntax:	 open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</div><div class="line">				open_log_file_cache off;</div><div class="line">	Default:	 open_log_file_cache off;</div><div class="line">	Context:	 http, server, location</div></pre></td></tr></table></figure>
<p>open_log_file_cache 里面几个参数的含义为：</p>
<ul>
<li><strong>max</strong> : 设置缓存中描述符的最大数量；如果缓存被占满，最近最少使用（LRU）的描述符将被关闭。</li>
<li><strong>inactive</strong> : 设置缓存文件描述符在多长时间内没有被访问就关闭； 默认为10秒。</li>
<li><strong>min_use</strong>s : 设置在inactive参数指定的时间里， 最少访问多少次才能使文件描述符保留在缓存中；默认为1。</li>
<li><strong>valid</strong> :设置一段用于检查超时后文件是否仍以同样名字存在的时间； 默认为60秒。</li>
<li><strong>off</strong> :禁用缓存。</li>
</ul>
<p>综上，要让nginx自切分，需要两个步骤，其一，配置合理的access_log;其二，开启open_log_file_cache提升性能； 下面是用实现小时级别日志切分的配置demo</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#提取nginx变量</div><div class="line">if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)T(\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)")</div><div class="line">&#123;</div><div class="line">	set $year $1; </div><div class="line">	set $month $2; </div><div class="line">	set $day $3; </div><div class="line">	set $hour $4; </div><div class="line">	set $minutes $5; </div><div class="line">	set $seconds $6; </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#配置access_log ；以  hour 为界</div><div class="line">access_log  logs/access.log.$year$month$day$hour;                                                                         </div><div class="line"></div><div class="line">#配置open_log_file_cache</div><div class="line">open_log_file_cache max=10 inactive=60s valid=1m min_uses=2;</div></pre></td></tr></table></figure>
<p><strong>总结</strong> : 自切分可一定程度上面满足日志切分的需求；但是对性能会有一定的影响； 另外，并不支持error_log的切分，个人更推荐产品线采用方式一的方法切。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>本文主要阐述了nignx日志切分的方案，希望能够帮助大家提升对nginx的理解。另外nginx的日志管理，还是很多值得学习，注意的点，包括syslog支持，gzip支持（想想protobuf）。后续会再为介绍。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-mixed_content_control" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/mixed_content_control/">关于https嵌套http iframe的问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/mixed_content_control/" class="article-date">
  <time datetime="2015-03-06T03:13:44.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>主要是https 和 http页面嵌套，引用的一些具体规则？哪些是允许的，哪些是不允许的？</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一般地，我们主要规范https页面上面对http请求的场景。http页面可以嵌入https一般浏览器不会太care</p>
<p>浏览器把https嵌入的外部资源分成两大类，如下:</p>
<ul>
<li>Mixed Passive Content (a.k.a. Mixed Display Content) : 被动页面嵌入内容，此类的资源不会对已有的https主页面产生修改，更新之类的操作，具体包括:  images, audio, and video loads. </li>
<li>Mixed Active Content (a.k.a. Mixed Script Content) : 主动页面嵌入内容，此类的资源可能会影响原来的页面的展现和内容，具体包括: JavaScript, CSS, objects, xhr requests, iframes, and fonts</li>
</ul>
<blockquote>
<p>PS: 不同浏览器对MPC和MAC的分类不一定一致，比如说iframe在chrome下面属于MPC,而在ie/firefox属于MAC</p>
</blockquote>
<p>一般的浏览器如果发现一个资源属于MAC，就会blocking此类请求</p>
<p>故，综上，在IE浏览器下面一个https页面嵌入http请求会直接被block</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.mozilla.org/tanvi/2013/04/10/mixed-content-blocking-enabled-in-firefox-23/" target="_blank" rel="external">Mixed Content Blocking Enabled in Firefox 23!</a></li>
<li><a href="http://www.tinywebgallery.com/blog/iframe-do-not-mix-http-and-https" target="_blank" rel="external">Why you should not mix http and https when using iframes</a></li>
<li><a href="http://lison.sinaapp.com/?p=317" target="_blank" rel="external">HTTPS和HTTP相互间IFRAME的浏览器限制及安全提示</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-about_https" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/about_https/">https 概述</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/about_https/" class="article-date">
  <time datetime="2015-03-06T03:13:34.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>个人学习目标:</p>
<ol>
<li>了解https的核心以及几个常见的概念</li>
<li>了解https的大致交流流程</li>
<li>明确https的性能关键点&amp;优化点</li>
<li>了解https在具体实践过程的常见问题以及解决方案</li>
</ol>
<p>几点总结 :</p>
<ul>
<li>关于加密解密都是非常细致的一个处理过程，有非常多的细节需要关注，但尽量会把协议本身</li>
<li>多用一些图示和衍生的demo展示来加深对https的理解</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p>整个交换过程可以大致分为两个阶段:</p>
<ol>
<li><p>TLS握手: 协商此次交互的用于加密的对称密钥，这个过程颇为复杂，等下会详解，核心思想是通过非对称密钥和双方的随机数生成一个密钥</p>
</li>
<li><p>具体内容交互: 此时双方都用上一步生成的对称密钥，加密要交互的内容，进行通信</p>
</li>
</ol>
<h2 id="TLS握手流程"><a href="#TLS握手流程" class="headerlink" title="TLS握手流程"></a>TLS握手流程</h2><p>如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client                                  server</div><div class="line"></div><div class="line">ClientHello             --------&gt;</div><div class="line">        </div><div class="line">                                        ServerHello </div><div class="line">                                        ServerCertificate</div><div class="line">                        &lt;--------       ServerKeyExchange</div><div class="line">                                        CertificateRequest</div><div class="line">                                        ServerHelloDone</div><div class="line"></div><div class="line">ClientCertificate</div><div class="line">ClientKeyExchange</div><div class="line">Certificate Verify      --------&gt;</div><div class="line">Change the Cipher Spce</div><div class="line">Client Finish Message</div><div class="line"></div><div class="line">                                        Change Cipher Spec</div><div class="line">                        &lt;--------       Server Finish Message</div><div class="line"></div><div class="line">&lt;--------------    Application Data  ----------------------&gt;</div></pre></td></tr></table></figure>
<p>总结:</p>
<ul>
<li>client&amp;server加起来一共两个RTT的过程</li>
<li>协商出来的密钥大致是: 2 * client ranodw + server random </li>
<li>整个交互过程还是明文的，不过生成的密钥是使用非对称加密算法加密的</li>
</ul>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p>几个关键的性能点</p>
<h3 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h3><p>如上，如果每次交互都需要重新进行TLS握手，需要浪费两个RTT，这个是不大希望的，我们可以引入如下两个机制，使得在进行TLS握手的时候，就需要一个RTT，包括:</p>
<ul>
<li>会话标识符(Session Identifier) :</li>
<li>会话记录单(Session Ticket) :</li>
</ul>
<h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><p>在进行TLS握手的时候，一般地，我们要求client端去严重证书的合法性，一个重要的判断是证书的有效时间的问题，主要有如下两个方法:</p>
<ul>
<li>证书撤销名单(CRL, Certificate Revocation List)</li>
<li>在线证书状态协议(OCSP, Online Certificate Status Protocol)</li>
</ul>
<p>如上是具体的协议，而浏览器在具体工作的时候，不同的浏览器行为也不一致，比如:</p>
<ul>
<li>某些浏览器会使用自己的更新机制推送更新CRL名单</li>
<li>某些浏览器只会针对扩展证书(EV证书)进行实时的OCSP和CRL检查</li>
</ul>
<p>这些情况很复杂。对整个系统设计来说，可以引人一个叫做<code>OCSP封套</code>的优化措施: 服务器可以在证书链里面包含证书颁发机构的OCSP响应，让浏览器跳过在线查询。把查询OCSP操作转移到服务器可以让服务器缓存签名的OCSP响应。当然OCSP响应也包含一系列问题，包括:</p>
<ul>
<li>OCSP的包体大小(400 ~ 4000)可能会导致TCP窗口拥塞</li>
<li>只能包括一个OCSP响应，导致浏览器对其他的证书仍然需要发送OCSP响应</li>
</ul>
<h2 id="应用及问题"><a href="#应用及问题" class="headerlink" title="应用及问题"></a>应用及问题</h2><h3 id="第三方cdn服务商的https支持"><a href="#第三方cdn服务商的https支持" class="headerlink" title="第三方cdn服务商的https支持"></a>第三方cdn服务商的https支持</h3><p>对于CloudFlare这样的云服务提供商，要给第三方做cdn的加速支持，如果此时主站点的域名是通过https提供服务，这就要求cdn缓存的静态文件也是需要走https，由于cdn是第三方的(CloudFlare)，主站显然不大可能把https的私钥放在服务商那边，对于此类场景要怎么办?</p>
<p>CloundFlare在<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="external">Keyless SSL: The Nitty Gritty Technical Details</a> 介绍了一个所谓的<code>Keyless SSL</code>机制，核心的思路就是： 正常情况下, 整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。</p>
<h3 id="nginx对SSL的支持"><a href="#nginx对SSL的支持" class="headerlink" title="nginx对SSL的支持"></a>nginx对SSL的支持</h3><p>如上ssl/tls相对于普通的http1.0/1.1协议复杂很多，因此整个nginx的SSL的指令和变量也是非常负责的，详情可以参看</p>
<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#example" target="_blank" rel="external">Module ngx_http_ssl_module</a></li>
<li><a href="http://nginx.org/cn/docs/http/configuring_https_servers.html#optimization`" target="_blank" rel="external">Nginx: 配置HTTPS服务器</a></li>
</ul>
<h2 id="推荐了解的名词"><a href="#推荐了解的名词" class="headerlink" title="推荐了解的名词"></a>推荐了解的名词</h2><ul>
<li>数字签名&amp;数字证书 : <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></li>
</ul>
<h2 id="参考-amp-推荐文章"><a href="#参考-amp-推荐文章" class="headerlink" title="参考&amp;推荐文章"></a>参考&amp;推荐文章</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html" target="_blank" rel="external">HTTPS的七个误解（译文）</a></li>
</ul>
<h2 id="todo-for-me"><a href="#todo-for-me" class="headerlink" title="todo for me"></a>todo for me</h2><ol>
<li>nginx搭建一个完整的https服务</li>
<li>对tls恢复方式的进一步了解(session identifier &amp; session ticket)</li>
<li>用http watch观看https的交互</li>
</ol>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-web_browser_and_protocol" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/06/web_browser_and_protocol/">从浏览器角度看web交互</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/03/06/web_browser_and_protocol/" class="article-date">
  <time datetime="2015-03-06T03:13:24.000Z" itemprop="datePublished">2015-03-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>web浏览器已经成为我们获取信息最重要的工具之一，我们也不仅仅把web浏览器当成简单的http内容获取+页面渲染的功能，而是希望在web上面构建越来越多的应用，比如实时会议之类的，这里简单说明下从web浏览器角度，分析他应该和现在支持的web交互功能</p>
<h2 id="浏览器要干嘛"><a href="#浏览器要干嘛" class="headerlink" title="浏览器要干嘛"></a>浏览器要干嘛</h2><p>浏览器终归到底是一个client，负责和server交互，如果不考虑本地渲染的复杂功能，我们对浏览器的考差点就是他如何支持一个交互的</p>
<p>一个交互可以划分如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client api ---&gt; protocol support ---&gt; server</div></pre></td></tr></table></figure>
<p>可见，浏览器主要关心两个大点：</p>
<ul>
<li>client api : 浏览器需要提供标准的api，有个规范的标准便于在不同平台上面的迁移</li>
<li>protocol : 其实就是对具体api的实现，比如用http交互等</li>
</ul>
<p>上面就是一个宏观上面的分析，下面说明具体的实现和现状</p>
<h2 id="Client-API-html5-以及js"><a href="#Client-API-html5-以及js" class="headerlink" title="Client API : html5 以及js"></a>Client API : html5 以及js</h2><p>HTML语言充当了client api一个最重要的角色，用于描述浏览器的行为，当然还包括javascript, css等</p>
<p>新的HTML5规范还增加了新的API规范，其实就是对之前html的补充，包括:</p>
<h2 id="Protocols-http-websocket"><a href="#Protocols-http-websocket" class="headerlink" title="Protocols : http, websocket"></a>Protocols : http, websocket</h2><p>protocol就是浏览器要实现的协议，当然http协议是最核心的，也是必须要实现的；但是，随着client api的增加，对于新的api可能就需要实现特定的协议(比如websocket)，因此，现如今，浏览器支持的协议是越来越多，下面是一个简单分类:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>(现在)依赖协议</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ajax(XmlHttpRequest)</td>
<td>http</td>
<td>-</td>
</tr>
<tr>
<td>Server-Sent Event</td>
<td>http</td>
<td>服务器以text/event-stream内容响应</td>
</tr>
<tr>
<td>websocket</td>
<td>http + websocket</td>
<td>http发起连接,ws具体交互</td>
</tr>
<tr>
<td>webrtc</td>
<td>udp+ice+srtp等</td>
<td>基于udp构建</td>
</tr>
</tbody>
</table>
<p>因此浏览器的协议支持图大致如下:</p>
<p><img src="./browser_protocol_support.png" alt="Alt text"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>其一:</p>
<p>api可以理解为是对具体功能的描述，而协议是对具体实现的描述，两者并不是强耦合的，比如说websocket的api，其描述的就是对一个双向的，自由格式的内容交互的支持。其现在的底层实现是基于websocket 协议的，但是http 2协议显然也能满足这个功能，也是可以用了实现这个协议的。</p>
<p>其二:</p>
<p>下图描绘几个api和server交互的场景</p>
<p><img src="./ajax_vs_websocket.png" alt="Alt text"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>web性能权威指南</li>
<li>web之困:现代web应用安全指南 </li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-0225_bitch_about" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/25/0225_bitch_about/">生活与生存</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/25/0225_bitch_about/" class="article-date">
  <time datetime="2015-02-24T16:25:11.000Z" itemprop="datePublished">2015-02-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在是大年初七凌晨，如之前所料，基本上所有的人都各奔东西，一年一次的聚散又是要匆匆而过</p>
<p>这次春节和之前差不多，基本上一半的时间都是和那些同学聚在一起，一起踢过球，喝过酒，打过牌，打过麻将，当然包括各种玩笑，谈话，还是很开心的</p>
<p>有时候会想自己为什么会更享受在家的生活，想的的一些原因包括:</p>
<ul>
<li>不需要工作了</li>
<li>因为有一群同学在，什么东西都可以吐槽</li>
<li>住在家里</li>
</ul>
<p>其实认真想想上面几个点都有一点，但其实自己有一个简单的总结，就是在这边的话，感觉自己更像在<code>生活</code>,其实之前自己对生活和生存，虽然有非常明确的语义以及其具体含义的理解，但是自己慢慢感触这个却是随着自己岁数的不断增大，现在自己的情况，更多的精力应该是让自己生存下去，让自己一直努力，让自己坚持不懈…</p>
<p>我自己希望能够在工作和<code>生活</code>中找到更好的平衡点，让自己的活的更自在一些，嗯，的确一直在调整…</p>
<p>今天看到一篇文章，大道理讲的很多，但里面有一个简单的观点，大致是说，不要太过分的欣赏和佩服自己某一刻的努力，大致的意思是世界上比你多努力的人多了去了。。。嗯，有时候后自己就会陷入这个状态，然后盲目的迷失了…</p>
<p>不再细说，今年自己要好好努力，也希望一切静好:)</p>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-linux_kernel_lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/06/linux_kernel_lock/">由linux锁机制想起来的</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/06/linux_kernel_lock/" class="article-date">
  <time datetime="2015-02-06T08:26:33.000Z" itemprop="datePublished">2015-02-06</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由linux锁机制想起来的"><a href="#由linux锁机制想起来的" class="headerlink" title="由linux锁机制想起来的"></a>由linux锁机制想起来的</h1><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>根本的目标是要实现同步机制，数据不会被打乱。</p>
<p>而在哪些情况需要同步机制呢？</p>
<ul>
<li>多处理器的情况：</li>
<li>抢占式系统 :</li>
<li>其他：</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>一般是指令自己触发的，处理也是比较简单的，主要有两种：</p>
<ul>
<li>页错误： 应该是唯一会出现的内核异常，此时会进行一些换页操作</li>
<li>其他（比如除以0，int 3）等：一般的流程是，cpu触发异常—&gt; 内核异常流程处理 —&gt; 发送信号给用户进程 –&gt; 如果用户进程不处理，就kill进程 </li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>先简单分类:</p>
<ul>
<li>I/O 中断:</li>
<li>时钟中断:</li>
<li>多处理器中断:</li>
</ul>
<p>按照处理的策略一般分为：硬中断和软中断（或者是所谓的下半部)</p>
<p>硬中断：一般是非常简单的处理逻辑<br>软中断：会拆分很多，包括softirq, tasklist, work queue, kernel thread, 具体见：<a href="https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY" target="_blank" rel="external">https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CDQQFjAE&amp;url=http%3A%2F%2Fwww.cs.columbia.edu%2F~nahum%2Fw6998%2Flectures%2Finterrupts.ppt&amp;ei=XeyCVOLRJYbbmAXk4oLQBw&amp;usg=AFQjCNFzeobtg_hltZtuHHKYJqQgl_eZ7w&amp;sig2=C2Lz_RP3Fyp48kXC4hygSA&amp;bvm=bv.80642063,d.dGY</a></p>
<h2 id="关于抢占式内核"><a href="#关于抢占式内核" class="headerlink" title="关于抢占式内核"></a>关于抢占式内核</h2><ul>
<li><p>中断和抢占的区别</p>
<ul>
<li>中断总是存在的，响应硬件的事件</li>
<li>抢占主要是指是否执行的代码是否能被其他进程抢占</li>
</ul>
</li>
<li><p>用户态抢占和内核抢占</p>
<ul>
<li>根据被抢占的时机区分用户台态和内核态抢占</li>
<li>用户态抢占: 用户台的抢占一般比较容易，在系统调用或者中断处理完成之后返回用户态的时候判断就可以了，另外由于此时用户态的上下文保存的较为完成，直接切换到其他的进程，至少感觉实现成本不是很高</li>
<li>内核态抢占: 简单的说，如果一段代码执行在内核态，能否也被抢占，个人感觉如果支持的话，其主要成本对整个内核的一些同步机制和代码等造成的影响，下面是copy的说明</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">如果内核是不可抢占的（比如说2.4的内核），一旦切进内核态，只要代码不是主动释放CPU它就可以一直占着CPU。例外，虽不可抢占，但若此时发生中断，代码还是要交出CPU，但是中断返回之后，代码又能霸占CPU了，此为可中断但不可抢占。</div><div class="line"></div><div class="line">如果内核是可抢占的（比如2.6或之后的内核），上述情况就不会发生了。内核抢占发生在以下3种情况：</div><div class="line"></div><div class="line">1. 从中断返回内核态时，若此时可抢占，则会强制调用schedule（），尝试抢占，被中断的内核代码不一定能继续霸着CPU。</div><div class="line"></div><div class="line">2.内核变成可抢占状态，此时也会尝试抢占。</div><div class="line"></div><div class="line">3.内核代码主动调用schedule（）。</div><div class="line"></div><div class="line">虽然2.6的内核提供内核抢占，但是也提供关闭的手段。是否可抢占是由preemt_count变量控制（per-cpu），有锁这个计数就+1，释放锁就-1.为0才是可抢占。每当释放锁的时候都会检查是否为0，为0则尝试抢占。</div></pre></td></tr></table></figure>
<h2 id="关于进程上下文和中断上下文"><a href="#关于进程上下文和中断上下文" class="headerlink" title="关于进程上下文和中断上下文"></a>关于进程上下文和中断上下文</h2><p>个人感觉进程，两个上下文主要有两个含义，一个代表具体上下文关联的环境，比如寄存器之类的；另一个是一段内核代码运行的环境。而后者是更为常见和需要关注的。</p>
<p>断上下文是引申出来的概念，其主要的目标是明确一个内核代码是否能执行某些操作。比如一个内核代码能否睡眠？ 因为在中断上下文的情况下，是不允许睡眠的。。。</p>
<p>而更具体实际的差别在于，进程上下文是指一段代码代表一个进程在执行，主要有两种情况:</p>
<ul>
<li>一个系统调用导致陷入内核后的代码执行；</li>
<li>异常出发导致的异常执行</li>
</ul>
<p>而中断上下文是但一个中断发生时，其内核代码管理的环境；</p>
<p>中断上下文的要求是比较多的，包括:</p>
<ul>
<li>睡觉或者放弃cpu</li>
<li>尝试获取信号量</li>
<li>执行耗时任务</li>
<li>访问用户空间的虚拟地址 : </li>
</ul>
<p>中断处理流程中不能睡眠，具体可以见: <a href="http://www.oschina.net/question/565065_57618" target="_blank" rel="external">http://www.oschina.net/question/565065_57618</a><br>这个上面的讨论</p>
<p>具体可以见: <a href="http://www.embedu.org/Column/Column240.htm" target="_blank" rel="external">http://www.embedu.org/Column/Column240.htm</a></p>
<h2 id="各种链接哈"><a href="#各种链接哈" class="headerlink" title="各种链接哈"></a>各种链接哈</h2><ul>
<li><a href="http://hacklu.com/blog/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%AD%E6%96%AD-75/" target="_blank" rel="external">内核抢占和中断</a></li>
<li><a href="http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/" target="_blank" rel="external">http://wenx05124561.blog.163.com/blog/static/1240008052011717113840215/</a></li>
<li><a href="http://guojing.me" target="_blank" rel="external">http://guojing.me</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_502c8cc401012pxj.html</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_close" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/01/tcp_close/">tcp的关闭处理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/02/01/tcp_close/" class="article-date">
  <time datetime="2015-02-01T15:41:49.000Z" itemprop="datePublished">2015-02-01</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>tcp的系列文章，不深究源码，偏于理解&amp;应用</p>
</blockquote>
<h2 id="状态图迁移"><a href="#状态图迁移" class="headerlink" title="状态图迁移"></a>状态图迁移</h2><p>一般tcp的关闭称为四次挥手，要求client/server端都关闭该通道的连接，他们的状态迁移图如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#这里暂不考虑同时关闭的情况</span></div><div class="line"></div><div class="line">主动关闭方                  被动关闭方</div><div class="line"></div><div class="line">ESTABLISTED                 ESTABLISED</div><div class="line">    |                           |</div><div class="line">  (send fin)                (get fin</div><div class="line">    |                       /snd ack)</div><div class="line">    |                           |</div><div class="line">    v                           v</div><div class="line">FIN_WAIT_1                  CLOSE_WAIT</div><div class="line">    |                           |</div><div class="line">  (get ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (send fin)</div><div class="line">FIN_WAIT_2                      |</div><div class="line">    |                           v</div><div class="line"> (getfin                    LAST_ACK</div><div class="line"> /send ack)                     |</div><div class="line">    |                           |</div><div class="line">    v                       (get ack )</div><div class="line">TIME_WAIT                       |</div><div class="line">    |                           |</div><div class="line">  (2* MSL)                      v</div><div class="line">    |                        CLOSED</div><div class="line">    v</div><div class="line">CLOSED</div></pre></td></tr></table></figure>
<h2 id="API关系"><a href="#API关系" class="headerlink" title="API关系"></a>API关系</h2><p>关闭的函数主要有两个，如下:</p>
<ul>
<li>close : close主要是减少句柄的引用计数，如果为0，在发送fin信号，关闭这一端的连接;</li>
<li>shutdown : shutdown则是直接发送FIN信号，不考虑引用计数的问题，可以导致一些正在连接的socket直接无效了</li>
</ul>
<p>而在具体使用上面，还有一些细节，包括:</p>
<ul>
<li><p>close一般情况下是非阻塞的，但我们可以通过设置SO_LINGER的socket选项对close的行为做一些控制,使之变成非阻塞，具体包括:</p>
</li>
<li><p>shutdown可以控制关闭读或者关闭写</p>
</li>
</ul>
<p>这里面的一个经典问题的<code>客户端关闭时，如何让服务端尽量的收到数据?</code>，这个后续再详述。</p>
<h2 id="常见问题-amp-配置"><a href="#常见问题-amp-配置" class="headerlink" title="常见问题&amp;配置"></a>常见问题&amp;配置</h2><p>回到tcp的状态迁移本身，这里面说明下常见的问题：</p>
<ul>
<li>A和B交互，如果A send data后，直接close，会有上面影响？</li>
</ul>
<p>首先，我们必须非常明确&amp;理解，socket close的作用，如上，一般的就是减少引用计数，如果为0的话，就发送fin，故我们可以推测如下情况:</p>
<ol>
<li><p>A发送成功fin也接收到了ack，此时A的状态迁移到了fin_time_2; 同样可以考虑两个场景:<br> 1.1 B那边也close了socket，此时B的socekt发送ack过来，则A走正常的关闭流程，从fin_wait_2 –&gt; time_wait-&gt;close<br> 1.2 B那边由于长短链接或者协议约定的不一致，B并不关闭socket，此时B的socket已经变成了close wait; 而A只能继续处在fin_time_2的状态</p>
<p> 问题1.2属于不正常的，一般怎么处理呢?</p>
<ul>
<li>为了保证A不浪费太多时间在FIN_WAIT_2，对于FIN_WAIT_2有个(TCP_FIN_TIMEOUT，默认60s)的限制，也就是说如果A 60s后还没有接收到对方的fin，则自己会自动切到关闭(<code>or time wait:待明确</code>)状态</li>
<li>上面的FIN_WAIT_2状态超时有个细节需要关注，那就是此时的socket必须是属于孤儿状态，也就说没有任何句柄和他们关联，如果有句柄和他关联的话，就就会一直处在FIN_WAIT_2状态。之所以强调这点，是因为tcp本身是允许半关闭的，也就是说肯定有socket是持久的处在FIN_WAIT_2状态的，因为tcp需要提供一个机制来保证该状态的存在，其中最关键的一点就是要先判断一个socket是否是孤儿socket。代码demo如下:</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 假设对方不关闭close fd，分析本端的行为</span></div><div class="line"><span class="comment">//关闭句柄，假设引用计数会变成0</span></div><div class="line">close(fd);</div><div class="line"><span class="comment">// 此时，发送FIN信号，本地的socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 由于没有句柄关联，60s后，改socket将关闭 </span></div><div class="line"></div><div class="line"><span class="comment">// 同样是发送FIN信号，本地socket状态变成FIN_WAIT_2</span></div><div class="line"><span class="comment">// 但是由于有句柄关联，改状态会一直持续</span></div><div class="line">shutdown(fd, SHUT_WR);</div><div class="line"></div><div class="line"><span class="comment">//shutdow 还有SHUT_RD(关闭读,不发送信号)，SHUT_RDWR(关闭读写，类似close)</span></div></pre></td></tr></table></figure>
<pre><code>* B那边由于被动关闭，而自己也不处理，socket会处于CLOSE WAIT状态，`奇怪的是，系统并没有给close wait一个超时的时间`, 因此我们需要自己想办法清理，`一般close相关的程序就OK了`
</code></pre><h3 id="FIN-WAIT-1的超时问题"><a href="#FIN-WAIT-1的超时问题" class="headerlink" title="FIN_WAIT_1的超时问题"></a>FIN_WAIT_1的超时问题</h3><p>首先明确，如果一个socket进入FIN_WAIT_1，很大可能性是已经没有句柄关联了(shutdown？)</p>
<p>如果此时发送失败的话，会受到<code>tcp_orphan_retries</code>参数的控制（重试次数）</p>
<p>同时为了保证系统的资源有限，<code>tcp_max_orphans</code> 这个参数控制了系统可以存在的最多孤儿socket的个数</p>
<h3 id="TIME-WAIT的存在必要性问题"><a href="#TIME-WAIT的存在必要性问题" class="headerlink" title="TIME_WAIT的存在必要性问题"></a>TIME_WAIT的存在必要性问题</h3><h3 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST ACK"></a>LAST ACK</h3><h2 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h2><ul>
<li><p>TCP里面有些状态有超时，有些没有，个人理解其根本原则在于：<code>资源能否被控制住</code>，如果你的资源属于一个进程，那么就不会去限制你的超时，因为进程存在，控制进程就可以了，进程死了你也就死了；如果你已久脱离了进程的管辖，比如说孤儿状态下的FIN_WAIT_2，我们就不能让他活的太持久</p>
</li>
<li><p>可以理解对于一个状态要有超时，</p>
</li>
<li>对于孤儿的socket</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/10/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>