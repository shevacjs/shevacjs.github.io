<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="all about IT tech, football">
<meta property="og:type" content="website">
<meta property="og:title" content="shevacjs home">
<meta property="og:url" content="http://shevacjs.com/page/11/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="all about IT tech, football">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shevacjs home">
<meta name="twitter:description" content="all about IT tech, football">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-nginx_1_9_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/30/nginx_1_9_10/">nginx 1.9.10 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/30/nginx_1_9_10/" class="article-date">
  <time datetime="2016-01-30T06:17:29.000Z" itemprop="datePublished">2016-01-30</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">*) Security: invalid pointer dereference might occur during DNS server</div><div class="line">       response processing if the &quot;resolver&quot; directive was used, allowing an</div><div class="line">       attacker who is able to forge UDP packets from the DNS server to</div><div class="line">       cause segmentation fault in a worker process (CVE-2016-0742).</div><div class="line"></div><div class="line">*) Security: use-after-free condition might occur during CNAME response</div><div class="line">       processing if the &quot;resolver&quot; directive was used, allowing an attacker</div><div class="line">       who is able to trigger name resolution to cause segmentation fault in</div><div class="line">       a worker process, or might have potential other impact</div><div class="line">       (CVE-2016-0746).</div><div class="line"></div><div class="line">*) Security: CNAME resolution was insufficiently limited if the</div><div class="line">       &quot;resolver&quot; directive was used, allowing an attacker who is able to</div><div class="line">       trigger arbitrary name resolution to cause excessive resource</div><div class="line">       consumption in worker processes (CVE-2016-0747).</div><div class="line"></div><div class="line">*) Feature: the &quot;auto&quot; parameter of the &quot;worker_cpu_affinity&quot; directive.</div><div class="line"></div><div class="line">*) Bugfix : ...</div></pre></td></tr></table></figure>
<p>可以看到主要是几个安全问题的修复，以及一个新的feature的支持; 下面简单说明这个两个点</p>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>几个安全问题都是关于<code>resolver</code>指令，主要问题在于在解析DNS时需要对异常有更强的容错能力，风险点包括如下:</p>
<ul>
<li>DNS的服务伪造一个UDP包体可以导致nginx crash</li>
<li>其他的异常情况导致的nginx crash</li>
</ul>
<p>今天问题自己总结如下:</p>
<p>当我们使用<code>resolver</code>指令的时候，nginx需要和dns服务器进行交互，以便获取具体域名对应的IP; 整个这个交互的过程是nginx自己编码和dns服务交互,  这样存在的一个问题是一旦nginx的容错逻辑有问题，尤其是和外界的dns服务交互的时候，一旦这个DNS服务器可以恶意伪造请求的时候, 比如返回不正常的body的时候, nginx容错一旦处理有点偏颇，就会crash</p>
<p>所以这种情况一般会出现在: <code>配置了resolver指令，且对于的dns服务器不可信</code></p>
<blockquote>
<p>具体可以见 : <a href="http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html" target="_blank" rel="external">http://mailman.nginx.org/pipermail/nginx/2016-January/049700.html</a></p>
</blockquote>
<h2 id="worker-cpu-affinity指令优化"><a href="#worker-cpu-affinity指令优化" class="headerlink" title="worker_cpu_affinity指令优化"></a>worker_cpu_affinity指令优化</h2><p>这个指令的功能比较简单，就是可以自动设置cpu的亲和性, demo如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">worker_cpu_affinity</span> auto;</div></pre></td></tr></table></figure>
<p>具体代码的实现还是比较简单的，不再赘述</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_keepalive_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/tcp_keepalive_proxy/">让nginx支持TCP长连接代理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/19/tcp_keepalive_proxy/" class="article-date">
  <time datetime="2016-01-19T06:17:30.000Z" itemprop="datePublished">2016-01-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">              -----&gt; LCS </div><div class="line">            /</div><div class="line">Client(PHP) -------&gt; LCS</div><div class="line">            \</div><div class="line">             ------&gt; LCS</div></pre></td></tr></table></figure>
<p>如上，我们客户端需要和LCS交互，正常情况下，由于PHP比较难做长链接(当然RAL后续可以做长连接的支持)，所以现在每次和LCS交互，都需要建立一次TCP连接，然后做数据传输；现在问题是，如果LCS在其他的IDC，这样client和LCS每次都得做一次跨机房的三次握手, 这样对服务稳定性等都有一定的影响</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                        -----&gt; LCS </div><div class="line">                      /</div><div class="line">Client(PHP)---&gt; Proxy -------&gt; LCS</div><div class="line">                      \</div><div class="line">                        ------&gt; LCS</div></pre></td></tr></table></figure>
<p>一个方案是如上，加上一个proxy，这个Proxy的作用是和LCS维护一个长连接，和client保持短连接，同时让Client和Proxy部署在一个IDC, Proxy和LCS可以跨IDC；此时Proxy和LCS的由于是长连接交互，不必要每次都有个跨IDC的三次握手, 但也有如下的问题:</p>
<ul>
<li>增加了一层，意味着多一层网络交互，</li>
<li>长连接的跨IDC交互有可能也避免不了跨IDC的网络异常问题</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>如上，上面的proxy，其实就是我们说的nginx proxy, 现在的问题是nginx虽然支持简单的tcp proxy，但是并不支持downstream是短链接，然后upstream是长连接(upstream和downstream的长短链接必须一致), 但是我们知道nginx http模块里面是有一个keepalive模块的，所以技术上面应该问题不大的，我们要做的就是把那个东西迁移过来, 具体如下:</p>
<h3 id="关于nginx-HTTP-长连接"><a href="#关于nginx-HTTP-长连接" class="headerlink" title="关于nginx HTTP  长连接"></a>关于nginx HTTP  长连接</h3><ul>
<li>内部实现 : <a href="http://blog.csdn.net/gzh0222/article/details/8523635" target="_blank" rel="external">http://blog.csdn.net/gzh0222/article/details/8523635</a></li>
<li>大概思路 :<ul>
<li>对于一个具体的upstream，可以设置其connection pool的size</li>
<li>每次需要访问upstream的时候，先去connection pool里面查找, 如果存在，就用改连接；否则新建一个连接</li>
<li>当访问结束的时候, 不主动断开连接，而且放回到连接池; 如果连接池是满的，需要释放最老的无用的连接(LRU)</li>
</ul>
</li>
</ul>
<h3 id="配置demo"><a href="#配置demo" class="headerlink" title="配置demo"></a>配置demo</h3><p>依照http upstream keepalive module的工作原理，我们编写了一个tcp upstream keepalie模块，具体代码请见<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">ngx_stream_keepalive_module</a></p>
<p>如下是简单的配置demo</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> stream_test &#123;</div><div class="line">        <span class="comment"># 设置连接池的大小, 用法同http upstream keepalive module</span></div><div class="line">        <span class="attribute">keepalive</span> <span class="number">10</span>;</div><div class="line">        <span class="attribute">server</span> yf-forum-rdcjs1.yf01.baidu.com:<span class="number">12388</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">12345</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> stream_test;</div><div class="line">        <span class="attribute">proxy_protocol</span> <span class="literal">on</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="问题-amp-思路"><a href="#问题-amp-思路" class="headerlink" title="问题&amp;思路"></a>问题&amp;思路</h3><p>一旦加入一个proxy，我们其实又面临一个问题，以上图为例，就是LCS如何获取真正的client ip? </p>
<p>像http协议的代理，一般会在应用层做这个事情，比如说通过<a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html" target="_blank" rel="external">ngx_http_realip_module</a> 把相关的信息放到header里面，这样是能满足业务需求的; 那tcp proxy怎么办?</p>
<p>像TCP层一下的代理，比如说<a href="https://en.wikipedia.org/wiki/Linux_Virtual_Server" target="_blank" rel="external">LVS</a>一般会需要<a href="http://www.just4coding.com/blog/2015/11/16/toa/" target="_blank" rel="external">内核的支持</a>，以便我们正确的获取客户端的IP，感觉解决方案都是挺重的</p>
<p>一个简单的方案是<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">The PROXY protocol</a>, 这个协议原理&amp;思路非常简单，就是在协议代理，新建连接的时候，会传输具体的代理信息。比如按照上图，当<code>Proxy</code>和<code>LCS</code>建立连接的时候，他做的第一个事情是发送一个文本信息，告诉<code>LCS</code>相关的client信息，大概如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PROXY TCP4 192.168.0.1 192.168.0.11 56324 443</div></pre></td></tr></table></figure>
<p>所以此时客户端需要修改其读取逻辑，在首次连接之后，需要尝试去读取proxy的信息，如果存在，就可以做一些具体的解析</p>
<p>同时，也要求proxy做一些修改，在发送请求给后端的时候，需要额外带上这些信息，具体可以通过<a href="http://nginx.org/en/docs/stream/ngx_stream_proxy_module.html#proxy_protocol" target="_blank" rel="external">proxy_protocol</a>这个指令控制;</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">nginx stream module官方链接</a></li>
<li><a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol具体说明文档</a> </li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-tcp_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/10/tcp_proxy/">关于nginx的tcp代理支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/01/10/tcp_proxy/" class="article-date">
  <time datetime="2016-01-10T06:17:31.000Z" itemprop="datePublished">2016-01-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP代理简述"><a href="#TCP代理简述" class="headerlink" title="TCP代理简述"></a>TCP代理简述</h2><p>所谓的TCP proxy是一个用于代理tcp协议的中间代理；比如类似我们的http代理, 我们的mysqlproxy等; tcp代理相比于其他的proxy，具有如下特征:</p>
<ul>
<li>由于TCP代理是传输层的代理，所以能支持更多的业务，无论是http, mysql, redis, websocket等应用层协议他都能代理</li>
<li>由于TCP代理是底层的协议，所以虽然能代理，但是对业务的控制能力也变弱(只能拿到传输层的信息): 比如我们不能像http代理那样，通过cookie，refer做请求的转发和控制</li>
</ul>
<p>其实，我们也可以把他理解为一个LVS, 或者公司内的BGW(他们是IP层的负载均衡代理); 但是又比他们稍微高一点</p>
<p>如下是简单的一个不同网络层的软件的示范:</p>
<table>
<thead>
<tr>
<th>网络层</th>
<th>具体软件/技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP</td>
<td>LVS, BGW</td>
</tr>
<tr>
<td>TCP</td>
<td>haproxy, nginx</td>
</tr>
<tr>
<td>HTTP</td>
<td>nginx, haproxy</td>
</tr>
</tbody>
</table>
<h2 id="nginx的TCP代理功能简述"><a href="#nginx的TCP代理功能简述" class="headerlink" title="nginx的TCP代理功能简述"></a>nginx的TCP代理功能简述</h2><p>nginx是从1.9.0版本开始支持tcp代理, 称之为<a href="http://nginx.org/en/docs/stream/ngx_stream_core_module.html" target="_blank" rel="external">stream</a>模块, 发展到现在的1.9.9版本, 已经初步具备了tcp proxy的功能了, 如下是一个简单的nginx stream配置; 可以注意到:</p>
<ul>
<li>tcp代理是一个stream模块, 要放在stream段</li>
<li>http里面的很多功能，比如access_log, realip 等都不能使用(可以思考为什么)</li>
</ul>
<p>通过下面的配置，我们就可以实现一个mysql的proxy，自动做几个db的负载均衡；图来自于<a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">nginx官方文档</a></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">stream</span> &#123;</div><div class="line">    <span class="attribute">upstream</span> db &#123;</div><div class="line">        <span class="attribute">server</span> db1:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db2:<span class="number">3306</span>;</div><div class="line">        <span class="attribute">server</span> db3:<span class="number">3306</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</div><div class="line">        <span class="attribute">proxy_pass</span> db;</div><div class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">1s</span>; <span class="comment"># detect failure quickly</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>架构示意图:</p>
<p><img src="./nginx-plus-load-balancing.png" alt="nginx tcp proxy demo"></p>
<h2 id="关于nginx-tcp代理注意点"><a href="#关于nginx-tcp代理注意点" class="headerlink" title="关于nginx tcp代理注意点"></a>关于nginx tcp代理注意点</h2><p>如果你准备要写一个nginx stream模块的扩展，你会发现和之前的http差异会比较大，下面简单说几点现在写stream proxy总结的一些问题</p>
<h3 id="文档未稳定"><a href="#文档未稳定" class="headerlink" title="文档未稳定"></a>文档未稳定</h3><p>现在nginx还没文档化nginx stream扩展的具体开发模式，从源码上面查看，nginx也是一直在调整，比如1.9.0和1.9.9的module定义就有所不同，如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.9.0 源码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 1.9.9 源码, 多了 postconfiguration 定义</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_stream_module_t</span>  ngx_stream_upstream_hash_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* postconfiguration */</span> </div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    ngx_stream_upstream_hash_create_conf,  <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到, 连核心的module定义都有所调整, 所以这个方面估计还需要进一步观察</p>
<h3 id="调试有一定的成本"><a href="#调试有一定的成本" class="headerlink" title="调试有一定的成本"></a>调试有一定的成本</h3><p>要注意到我们现在是在写tcp proxy，所以之前用于调试的curl, access_log都不能直接使用了; 依照我现在的个人经验，推荐大家熟悉如下两个工具:</p>
<ul>
<li>nc : arbitrary TCP and UDP connections and listens<ul>
<li>作为server端，可以尝试 : nc -lk </li>
<li>作为client端，可以尝试 : echo “xxx” | nc {host} {port} 或者 nc {host} {post} (后者会保持长连接)</li>
</ul>
</li>
</ul>
<p>nc 可以让我们非常简单的去发送tcp的包体，用于作为我们测试的原始流量, 也可以非常简单的搭建一个tcp server</p>
<ul>
<li>tcpdump :<ul>
<li>命令大概如下(最基本的) : tcpdump -vvv -nn -X -i any (host 10.46.178.51 and port 12388)(condition)</li>
<li>要求对tcp的协议交互有较深的理解, 各种flag</li>
</ul>
</li>
</ul>
<p>关于nc和tcpdump, 文章的末尾给了几个链接，是非常适合系统性学习的</p>
<h3 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h3><p>由于tcp proxy的特殊性，导致其现在还不大方便有类似http模块access_log的日志(http有请求的概念，但是tcp没有); 所以tcp proxy的日志基本上都是通过error log体现的<br>贴吧线上的常规日志级别是notice, 如果我们要观察比如一个client连接，发送多少数据之类的，建议把日志级别调成<code>info</code>级别; 如下是大概的info级别的日志信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 client 127.0.0.1:45607 connected to 0.0.0.0:12345</div><div class="line">2016/01/10 00:32:17 [info] 9530#0: *13 proxy 10.46.178.51:60713 connected to 10.36.89.18:12388</div><div class="line">2016/01/10 00:32:49 [info] 9530#0: *13 client disconnected, bytes from/to client:16/0, bytes from/to upstream:0/16</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于tcpdump的:</p>
<ul>
<li><a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="external">A tcpdump Primer with Examples</a> :  tcpdump工具非常不错的说明，便于理解</li>
<li><p><a href="https://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/" target="_blank" rel="external">UDP/TCP Checksum errors from tcpdump &amp; NIC Hardware Offloading</a> : 关于tcpdump的<code>incorret chksum</code>问题说明</p>
</li>
<li><p><a href="http://www.thegeekstuff.com/2012/04/nc-command-examples/" target="_blank" rel="external">8 Practical Linux Netcat NC Command Examples</a></p>
</li>
</ul>
<p>关于tcpproxy的文章:</p>
<ul>
<li><p><a href="https://www.nginx.com/resources/admin-guide/tcp-load-balancing/" target="_blank" rel="external">TCP LOAD BALANCING</a> : nginx官方blog，介绍如何具体配置nginx</p>
</li>
<li><p><a href="https://www.nginx.com/blog/mysql-high-availability-with-nginx-plus-and-galera-cluster/" target="_blank" rel="external">MySQL High Availability with NGINX Plus and Galera Cluster</a> : 一个tcp proxy的具体demo，用于做mysql的复杂均衡</p>
</li>
</ul>
<p>下一篇文章会介绍<a href="http://gitlab.baidu.com/nginx/ngx_stream_keepalive_module/tree/master" target="_blank" rel="external">tcp proxy长连接</a>的实现；已经<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank" rel="external">proxy protocol</a>的情况以及使用</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-nginx_1_9_9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/nginx_1_9_9/">nginx 1.9.9 特性说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/12/19/nginx_1_9_9/" class="article-date">
  <time datetime="2015-12-19T06:17:30.000Z" itemprop="datePublished">2015-12-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="feature说明"><a href="#feature说明" class="headerlink" title="feature说明"></a>feature说明</h2><ul>
<li>pwritev() support.</li>
<li>the “include” directive inside the “upstream” block.</li>
<li>the ngx_http_slice_module.</li>
</ul>
<h2 id="pwritev说明"><a href="#pwritev说明" class="headerlink" title="pwritev说明"></a>pwritev说明</h2><p><a href="http://linux.die.net/man/2/pwritev" target="_blank" rel="external">pwritev</a>的具体说明可以见链接；nginx在这个版本里面主要用<code>pwritev</code>替代<code>writev</code>的功能；简单的理解，可以认为是将老的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">lseek(fd, offset);</div><div class="line">writev(fd, iov);</div></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pwritev()</div></pre></td></tr></table></figure>
<p>总结的收益是:</p>
<ul>
<li>系统调用从2次改成1次，主要是性能方面的</li>
<li>pwritev() was introduced in FreeBSD 6 and Linux 2.6.30, glibc 2.10</li>
</ul>
<p>具体可以参看文档: <a href="http://blog.libtorrent.org/2012/12/principles-of-high-performance-programs/" target="_blank" rel="external">principles of high performance programs</a></p>
<h2 id="ngx-http-slice-module"><a href="#ngx-http-slice-module" class="headerlink" title="ngx_http_slice_module"></a>ngx_http_slice_module</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_slice_module.html" target="_blank" rel="external">ngx_http_slice_module</a>是新引入的一个功能模块；大概的作用是可以将一个upstream response body 切成那个小块，然后每个单独缓存; 官方原话:</p>
<blockquote>
<p>The module makes it<br>possible to split a big upstream response into smaller parts and cache them<br>independently.</p>
<p>The module supports range requests.  When a part of a file is requested,<br>only the required slice upstream requests are made.  If caching is enabled,<br>future requests will only go to upstream for missing slices.</p>
</blockquote>
<p>可以理解的应用场景:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client ---&gt; proxy(nginx) ---&gt; upstream</div></pre></td></tr></table></figure>
<ul>
<li>proxy那边会将一个big file切成小块缓存</li>
</ul>
<blockquote>
<p>todo待补充</p>
</blockquote>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-ngx_variable_flag" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/ngx_variable_flag/">nginx variable flag说明</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/12/19/ngx_variable_flag/" class="article-date">
  <time datetime="2015-12-19T06:17:30.000Z" itemprop="datePublished">2015-12-19</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景-amp-问题"><a href="#背景-amp-问题" class="headerlink" title="背景&amp;问题"></a>背景&amp;问题</h2><p>我们在自己编写nginx扩展的时候，一般要求设置flag，在<code>src/http/ngx_http_variables.h</code>，对nginx flag有如下定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_CHANGEABLE   1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_NOCACHEABLE  2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_INDEXED      4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HTTP_VAR_NOHASH       8</span></div></pre></td></tr></table></figure>
<p>现在问题来了，这些flag的标记所为何用，什么时候我们应该用什么flag呢？了解这些flag需要对nginx的变量管理机制有个简单的了解，因为这里简单说明nginx变量的管理机制以及相关flag的含义</p>
<blockquote>
<p>其实更深的背景是一个历史问题，就是nginx lua获取不到baidu problem trace的product variable, 进一步追查得知</p>
</blockquote>
<h2 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h2><blockquote>
<p>希望以简单的推导的方式说明nginx的变量管理</p>
</blockquote>
<ol>
<li>第一步，我们需要维护一个nginx支持的variable列表，为了快速查找最好是用hash存储, 所以<code>ngx_http_core_main_conf</code>的配置大概如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_variable_s</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_str_t</span>                     name;     <span class="comment">// 变量的名称</span></div><div class="line">    ngx_http_set_variable_pt      set_handler;  <span class="comment">// 变量的设置函数</span></div><div class="line">    ngx_http_get_variable_pt      get_handler;  <span class="comment">// 变量的get函数</span></div><div class="line">    <span class="keyword">uintptr_t</span>                     data;     <span class="comment">// 传给get与set_handler的值</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                    flags;    <span class="comment">// 变量的标志</span></div><div class="line">    <span class="keyword">ngx_uint_t</span>                    index;    <span class="comment">// 如果有索引，则是变量的索引号</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>这样通过<code>ngx_http_add_variable</code>往相关的hash table里面添加variable就可以了</p>
<ol>
<li>问题稍微延伸一点，我们知道variable是和请求相关的，不同请求的variable可以是不一样的；所以对于每个request都应该要自己的variable list，而且requset 一般就关系变量的具体值，定义variable value如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">unsigned</span>    len:<span class="number">28</span>;     </div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span>    valid:<span class="number">1</span>;    <span class="comment">// 当前变量是否合法</span></div><div class="line">    <span class="keyword">unsigned</span>    no_cacheable:<span class="number">1</span>; <span class="comment">// 当前变量是否可以缓存，缓存过的变量将只会调用一次get_handler函数</span></div><div class="line">    <span class="keyword">unsigned</span>    not_found:<span class="number">1</span>;<span class="comment">// 变量是否找到</span></div><div class="line">    <span class="keyword">unsigned</span>    escape:<span class="number">1</span>;</div><div class="line"></div><div class="line">    u_char     *data;       <span class="comment">// 变量的数据</span></div><div class="line">&#125; <span class="keyword">ngx_variable_value_t</span>;</div></pre></td></tr></table></figure>
<p>这样一个最简单的variable 管理方案就OK了，大概如下:</p>
<ul>
<li>在main conf记录所有的variable, 维护一个hash table，拥有快速检索</li>
<li>对于每个request , 维护一个hash table 到value的映射，这样能查询variable的值，</li>
</ul>
<p>上面方案的问题:(<code>个人理解</code>)</p>
<ul>
<li>资源消耗大 : 如果每个request 都维护一个hash table，显然内存之类的</li>
<li>查询速度慢 : 虽然hash已经足够快了，但是依旧还是有优化的空间</li>
</ul>
<ol>
<li>那如何优化呢？ 一个简单的思路就是：对于一些变量，可以不用hash，直接用索引(index)，去查询，所以在变量添加的时候，我们可以支持用户给变量添加一个索引，这样用户查询变量的时候，可以直接用索引去查；所以可以调整为:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_array_t</span>                variables;         <span class="comment">// 索引变量的数组</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>有了索引我们添加一个变量的方式，可以调整如下:</p>
<p>a) ngx_http_add_variable 添加一个变量，往variables_keys里面添加东西<br>b) ngx_http_get_variable_index 对一个变量添加索引(index), 程序存储这个index(variables里面，索引就是数组位置)<br>c) 查询的时候，可以直接index去找；不行的话就在通过hash value</p>
<p>这样request里面存储的东西也可以调整了，也不需要维护hash，只要维护索引数组就可以了，索引数组没有，直接对conf的hash table去看variable的get/set handle，直接调用就可以, 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_request_s</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_http_variable_value_t</span>        *variables; <span class="comment">//数组大小和conf的variables一样大</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如上优化，感觉挺不错的；但是nginx的开发者可能不这么认为，因为现在归纳下来，我们获取变量可以通过索引或者hash；其中hash可以理解是全部的；但可能有些场景可能索引就够了，根本不需要通过hash去查找；所以如果能够通过索引去查找的variable，而且有明确不需要通过hash去弄，那就不需要导到hash table；所以main conf调整如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">ngx_hash_t</span>                 variables_hash;     <span class="comment">// 变量的hash表</span></div><div class="line">    <span class="keyword">ngx_array_t</span>                variables;         <span class="comment">// 索引变量的数组</span></div><div class="line">    <span class="keyword">ngx_hash_keys_arrays_t</span>    *variables_keys;       <span class="comment">// 变量的hash数组</span></div><div class="line">&#125; <span class="keyword">ngx_http_core_main_conf_t</span>;</div></pre></td></tr></table></figure>
<p>在<code>ngx_http_variables_init_vars</code>里面，我们会将variable_keys 导到 variable_hash, 对于不需要hash的variable，就不用导了；这样一个问题是通过hash就找不到这个变量了</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>依照上面，我们在梳理几个flag的含义已经作用:</p>
<ul>
<li><p>NGX_HTTP_VAR_INDEXED : 这个变量是被索引的；这个flag一般不需要手动标记，通过调用ngx_get_variable_index会自动给对应变量，添加此flag</p>
</li>
<li><p>NGX_HTTP_VAR_NOHASH : 这个类型的变量，只能通过索引获得，也就是上面第4步说的</p>
</li>
</ul>
<p>简单说明ngx_http_get_variable的代码，其大概逻辑就是尝试用索引，不行就走hash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ngx_http_get_variable(ngx_http_request_t *r, ngx_str_t *name, ngx_uint_t key)</div><div class="line">&#123;</div><div class="line">    ngx_http_variable_t        *v;</div><div class="line">    ngx_http_variable_value_t  *vv;</div><div class="line">    ngx_http_core_main_conf_t  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    // 通过hash获取变量信息</div><div class="line">    // 如果知道有索引，其实可以指通过 ngx_http_get_indexed_variable</div><div class="line">    // 这个函数通用一些，会处理所有情况，</div><div class="line">    v = ngx_hash_find(&amp;cmcf-&gt;variables_hash, key, name-&gt;data, name-&gt;len);</div><div class="line"></div><div class="line">    // 查到hash了 </div><div class="line">    if (v) &#123;</div><div class="line">        // 如果是索引，走索引的流程</div><div class="line">        if (v-&gt;flags &amp; NGX_HTTP_VAR_INDEXED) &#123;</div><div class="line">            return ngx_http_get_flushed_variable(r, v-&gt;index);</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            // 非索引，通过get/set handle获取信息</div><div class="line">            vv = ngx_palloc(r-&gt;pool, sizeof(ngx_http_variable_value_t));</div><div class="line"></div><div class="line">            if (vv &amp;&amp; v-&gt;get_handler(r, vv, v-&gt;data) == NGX_OK) &#123;</div><div class="line">                return vv;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 获取类似http_xx, arg_xx 之类的规则变量, 忽略</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p>大部分文档链接都说的很好，很清晰；如有兴趣，可以深看</p>
</blockquote>
<ul>
<li><a href="http://pureage.info/2014/01/20/lua-nginx-variable.html" target="_blank" rel="external">lua-nginx使用自定义变量中需要说明的一点</a></li>
<li><a href="http://osdir.com/ml/nginx-development/2010-04/msg00019.html" target="_blank" rel="external">questions about http variables: flags and no_cacheable</a></li>
<li><a href="http://tengine.taobao.org/book/chapter_07.html" target="_blank" rel="external">Tengine: 模块开发高级篇: 变量</a></li>
<li><a href="http://m.blog.csdn.net/blog/dingyujie/7106524" target="_blank" rel="external">[原]nginx脚本引擎与设计设计(三)</a></li>
<li><a href="http://blog.lifeibo.com/blog/2011/12/17/nginx-varibles.html" target="_blank" rel="external">Nginx源码分析之变量</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-waf" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/12/waf/">业务防攻击与WAF调研</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/05/12/waf/" class="article-date">
  <time datetime="2015-05-12T09:00:37.000Z" itemprop="datePublished">2015-05-12</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>by <a href="mailto:chenjiansen@baidu.com" target="_blank" rel="external">chenjiansen@baidu.com</a> </p>
</blockquote>
<h2 id="0x00-现有防攻击支持"><a href="#0x00-现有防攻击支持" class="headerlink" title="0x00 现有防攻击支持"></a>0x00 现有防攻击支持</h2><p>对具体的流量进行分析的话，流量攻击主要包括如下两个点:</p>
<ul>
<li>量 : 就是通过构造大量的请求，来影响服务器的服务质量</li>
<li>质 : 就是伪造特定的请求，这类请求量不需要很大，但可能对系统的安全和稳定性有较大影响</li>
</ul>
<p><code>量</code>上面的攻击其实一直是大多数接入系统会重点关注和防御的，以百度而言，大致的接入防攻击有如下:</p>
<ul>
<li>BGW : 4层四层防攻击, 支持tcp代理，清洗</li>
<li>911/BCS : 旁路式的流量检测和清洗，7层防攻击</li>
<li>BFE : 主要提供了BDS, 同样是一个全局、旁路的七层防攻击体系</li>
</ul>
<p>可以看到主要是网络层的防御；虽然他们都会支持七层的防攻击，但由于理业务线有点远，导致效果一直不是很理想</p>
<p>而<code>质</code>上面主要是只针对一些恶意伪造的请求，主要是针对系统的安全性漏洞,比如XSS攻击，SQL注入等,  这方面依我现在的了解，我们并没有做太多的事情</p>
<p>总得而言，对我们来说，不大需要关注网络层的ddos攻击，更多的是需要<code>业务的防攻击支持以及安全性保障</code></p>
<h2 id="0x01-业务防攻击现状"><a href="#0x01-业务防攻击现状" class="headerlink" title="0x01 业务防攻击现状"></a>0x01 业务防攻击现状</h2><p>现有的业务防攻击是通过nginx的扩展在接入层实现的，主要支持如下几个功能:</p>
<ul>
<li>IP黑白名单</li>
<li>HTTP 请求过滤</li>
<li>单机的分布式(ip, refer, url)支持</li>
</ul>
<blockquote>
<p>几个规则可以通过and/or运算组合成一个更强大的策略</p>
</blockquote>
<p>可以理解是拥有初步的功能支持</p>
<p>而现在防攻击主要面临的问题有:</p>
<ul>
<li>功能有限 : 包括:<ul>
<li>数据都是单机的，对于分布式的攻击，效果有限</li>
<li>action定义有限，只能简单返回异常码</li>
</ul>
</li>
<li>可用性/友好性较差 : 现在的配置都是用XML描述的，用户难以理解其规则；添加规则的学习成本之类的也很高</li>
<li>运维复杂<ul>
<li>比如iplist更新之类的需要重启nginx</li>
</ul>
</li>
<li>系统性 : 现在防攻击主要侧重在攻击上面，但其实没有建立<code>异常捕获+生产策略+线上应用</code> 的闭环，导致策略容易失效，对用户也会造成一定的误伤</li>
</ul>
<h2 id="0x02-WAF和业务防攻击"><a href="#0x02-WAF和业务防攻击" class="headerlink" title="0x02 WAF和业务防攻击"></a>0x02 WAF和业务防攻击</h2><p><a href="http://en.wikipedia.org/wiki/Application_firewall" target="_blank" rel="external">WAF</a>是业界对应用层防护的一个主要手段,这里我们主要关注软件waf，其中<a href="https://www.modsecurity.org/" target="_blank" rel="external">mod security</a>可以认为是一个事实的waf标准</p>
<p>大多数软件的WAF都会支持如下功能:</p>
<ul>
<li>HTTP Protection （HTTP防御）: HTTP协议和本地定义使用的detectsviolations策略。 </li>
<li>Real-time Blacklist Lookups（实时黑名单查询） : 利用第三方IP信誉。 </li>
<li>HTTP Denial of Service Protections（HTTP的拒绝服务保护）: 防御HTTP的洪水攻击和HTTP Dos 攻击。  </li>
<li>Common Web Attacks Protection（常见的Web攻击防护） : 检测常见的Web应用程序的安全攻击。  </li>
<li>Automation Detection（自动化检测） : 检测机器人，爬虫，扫描仪和其他表面恶意活动。  </li>
<li>Integration with AV Scanning for File Uploads（文件上传防病毒扫描） : 检测通过Web应用程序上传的恶意文件。  </li>
<li>Tracking Sensitive Data（跟踪敏感数据） : 信用卡通道的使用，并阻止泄漏。  </li>
<li>SQL注入检测/XSS攻击检测 </li>
</ul>
<p>实现层面的话，主要是通过规则的描述, 比较强依赖正则表达式, 比如如下是一个SQL注入的配置规则:</p>
<blockquote>
<p>FreeWAF源码</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">	id = 41010,</div><div class="line">	action = "SCORE",</div><div class="line">	description = "SQL Injection attempt",</div><div class="line">	opts = &#123; score = 4, transform = 'uri_decode' &#125;,</div><div class="line">	var = &#123;</div><div class="line">		operator = "REGEX",</div><div class="line">		pattern = [=[(?i:\bor\b ?(?:\d&#123;1,10&#125;|[\'\"][^=]&#123;1,10&#125;[\'\"]) ?[=&lt;&gt;]+|(?i:'\s+x?or\s+.&#123;1,20&#125;[+\-!&lt;&gt;=])|\b(?i:x?or)\b\s+(\d&#123;1,10&#125;|'[^=]&#123;1,10&#125;')|\b(?i:x?or)\b\s+(\d&#123;1,10&#125;|'[^=]&#123;1,10&#125;')\s*?[=&lt;&gt;])]=],</div><div class="line">		type = "REQUEST_ARGS",</div><div class="line">		opts = &#123; key = "all" &#125;,</div><div class="line">	&#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>如上的规则大致会将请求arg里面含有<code>or 1</code>等请求标记为危险请求(比如加上危险的权重), 一些好的waf的实现，还具有请求打分等控制, 可以实现非常复杂的逻辑控制</p>
<p><a href="http://www.scalescale.com/scaling-cloudflares-massive-waf/" target="_blank" rel="external">CloudFlare</a>多次在其blog介绍其waf的实现，但没有开放源代码。<a href="">FreeWAF</a>是我个人觉得写的相对不错的开源waf，功能强大，基本上涵盖了OWASP的CRS</p>
<p>事实上，WAF本身是非常复杂的的(有机会可以拿出来单独讨论)，尤其是其SQLi, XSS防御之类的规则学习成本也是比较高的，需要对web安全有一定的了解。但是通用的WAF都提供了一个非常不错的策略描述，执行框架。对于贴吧和业务的业务防攻击需求，其完全是可以复用的，只不过在具体的策略的关注点和侧重点有所不同</p>
<h2 id="0x03-我们的业务防攻击系统"><a href="#0x03-我们的业务防攻击系统" class="headerlink" title="0x03 我们的业务防攻击系统"></a>0x03 我们的业务防攻击系统</h2><p>需要实现的核心功能如下:</p>
<ul>
<li>支持热加载的ip黑白名单</li>
<li>支持全局存储的分布式防攻击策略</li>
<li>支持自定义的action处理</li>
</ul>
<p>其他可以考虑的功能包括(优先级较低):</p>
<ul>
<li>简单的SQL注入防御</li>
<li>XSS防护</li>
</ul>
<blockquote>
<p>安全相关的内容涉及东西较深，优先级也先降低</p>
</blockquote>
<p>大致的系统架构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">                              ┌───────────┐</div><div class="line">┌──────────────────┐          │           │</div><div class="line">│                  │          │           │</div><div class="line">│    platform      │──notice─▶│           │</div><div class="line">│                  │          │           │</div><div class="line">└───▲─────────┬────┘          │           │</div><div class="line">    │         │               │ router    │</div><div class="line">┌───┴─────────▼────┐          │           │</div><div class="line">│                  │          │           │</div><div class="line">│ strategy analysis│◀───log───│           │</div><div class="line">│                  │          │           │</div><div class="line">└──────────────────┘          │           │</div><div class="line">                              └───────────┘</div></pre></td></tr></table></figure>
<p>主要包括三个组件:</p>
<ul>
<li>router上面的waf扩展 : 负责waf的具体实现，nginx/lua的扩展耦合到router </li>
<li>策略控制平台 : 负责策略的生产，推送到线上的控制等</li>
<li>策略分析平台 : 负责对在线策略效果的分析, 反馈给策略控制平台</li>
</ul>
<h2 id="0x04-实现和风险考虑"><a href="#0x04-实现和风险考虑" class="headerlink" title="0x04 实现和风险考虑"></a>0x04 实现和风险考虑</h2><p>实现层面的话，希望用nginx/lua重写现有的防攻击策略,同时对现在的功能的不足进行加强, 带来的问题主要有:</p>
<ul>
<li>稳定性 : 采用一个分布式存储存取分布式数据(比如redis)，这样下游存储的稳定性直接影响请求的质量</li>
<li>性能/延迟影响 : 主要对每个请求的延迟和系统总体cpu的影响，大概预估如下:<ul>
<li>性能cpu占用 : 待评估</li>
<li>延迟 : 如果依赖分布式存储，得看分布式存储的性能；本身的cpu耗时控制在1ms以内</li>
</ul>
</li>
<li>迁移成本 : 由于整个策略的实现是重写的，因此我们需要保证一些老的规则能够顺利迁移到新的策略上面，可能需要提供一些脚本之类的自动生产</li>
<li>实现成本 : 规则策略的定义和实现，需要考虑性能，灵活性, nginx/lua如何方便简洁支持多产品等，不过参考了一些开源的waf实现，相信会有帮助</li>
</ul>
<blockquote>
<p>nginx/lua性能相关的配置设施会逐步完善和加强的, 相信有助于相关的性能优化</p>
</blockquote>
<p>同时我们还需要提供配套的平台来自动上层相关配置(以后策略不需要人工编辑)</p>
<h2 id="0x05-参考文档"><a href="#0x05-参考文档" class="headerlink" title="0x05 参考文档"></a>0x05 参考文档</h2><ul>
<li>公司内部的:<ul>
<li><a href="http://wiki.babel.baidu.com/twiki/pub/Ps/OP/%E9%9D%99%E6%80%81%E9%9B%86%E7%BE%A4%E6%8E%A5%E5%85%A5bfe/%E6%B5%85%E8%B0%88http%E9%98%B2%E6%94%BB%E5%87%BB%E5%8F%8A%E8%AE%BE%E8%AE%A1_-_%E5%A4%A7%E5%92%96%E7%A7%80.pptx" target="_blank" rel="external">浅谈http防攻击及设计</a></li>
<li><a href="http://wiki.babel.baidu.com/twiki/bin/view/Ps/OP/BDS" target="_blank" rel="external">Baidu Defense Server（BDS）官方主页</a> : BFE做的旁路防攻击支持</li>
</ul>
</li>
<li><p>WAF科普</p>
<ul>
<li><a href="http://www.freebuf.com/articles/web/18084.html" target="_blank" rel="external">走进科学之WAF(Web Appllication Firewall)篇</a></li>
<li><a href="http://drops.wooyun.org/tips/968" target="_blank" rel="external">深入了解SQL注入绕过waf和过滤机制</a></li>
<li><a href="http://hebaodan.org/index.php/ModSecurity/SqlModule.html" target="_blank" rel="external">ModSecurity进阶篇-SQL注入模块分析</a> : 以及这个blog主人的文章</li>
<li><a href="http://www.freebuf.com/tools/54221.html" target="_blank" rel="external">如何打造一款可靠的WAF（Web应用防火墙）</a></li>
</ul>
</li>
<li><p>WAF实践</p>
<ul>
<li><a href="http://www.scalescale.com/scaling-cloudflares-massive-waf/" target="_blank" rel="external">Scaling CloudFlare’s Massive WAF</a></li>
<li><a href="https://www.cryptobells.com/freewaf-a-high-performance-scalable-open-web-firewall/" target="_blank" rel="external">FreeWAF: A High-Performance, Scalable, Open Web Firewall</a></li>
<li><a href="https://github.com/p0pr0ck5/FreeWAF" target="_blank" rel="external">FreeWAF: github链接</a></li>
<li><a href="https://www.52os.net/articles/nginx-install-lua-and-lua-based-waf.html" target="_blank" rel="external">nginx配置lua模块和基于lua的waf</a></li>
<li><a href="https://www.52os.net/articles/nginx-use-modsecurity-module-as-waf.html" target="_blank" rel="external">nginx配合modsecurity实现WAF功能</a></li>
</ul>
</li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-hotcode_analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/10/hotcode_analysis/">nginx扩展/lua的性能剖析支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/05/10/hotcode_analysis/" class="article-date">
  <time datetime="2015-05-09T18:27:32.000Z" itemprop="datePublished">2015-05-10</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>by <a href="mailto:chenjiansen@baidu.com" target="_blank" rel="external">chenjiansen@baidu.com</a></p>
</blockquote>
<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>nginx的扩展和nginx lua在贴吧有了越来越多的应用，但是对于整个nginx相关组件的性能测试一直没有完善的支持。除了常规的流量压测，cpu利用率的分析等。我们还需要对nginx的具体性能瓶颈进一步分析，<code>发现具体的代码热点</code>，以便进一步的性能优化。</p>
<p>简而言之，我们需要达到如下目标:</p>
<ul>
<li>对于C扩展，我们能够明确其代码热点</li>
<li>对于nginx lua代码，我们同样也能明确其lua代码热点</li>
</ul>
<p>这里主要介绍nginx扩展/lua的性能剖析的现状支持，以及贴吧短期内的落地实践规划</p>
<h2 id="0x01-性能剖析工具"><a href="#0x01-性能剖析工具" class="headerlink" title="0x01 性能剖析工具"></a>0x01 性能剖析工具</h2><h3 id="C-C-程序的热点分析"><a href="#C-C-程序的热点分析" class="headerlink" title="C/C++ 程序的热点分析"></a>C/C++ 程序的热点分析</h3><p>首先简单看下现在linux工具链对代码热点发现的支持</p>
<p><a href="http://zh.wikipedia.org/wiki/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" target="_blank" rel="external">维基百科</a>上面对性能剖析工具有个简单的介绍, 由于是需要做热代码的发现，因此很少有静态代码分析的办法，一般都是运行时的剖析，具体可以分为:</p>
<ul>
<li>逻辑注入的性能分析：一把是指在编译链接的时候，链上相关的lib(其实也有运行时的代码注入，暂不考虑)，这些lib会在函数执行的时候自动做一些统计和分析，比较典型的是<a href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="external">gprof</a></li>
<li>非逻辑注入的性能分析：此类分析一般没有对具体的应用程序进行修改，更多是一种旁路异步的观察方式，而根据数据获取方式的不同一般区分为:<ul>
<li>基于事件的性能分析: 是指为特定事件增加回调,记录事件发生次数</li>
<li>基于采样的性能分析: 构造以一定周期重复的触发器用来采样<br>现在的一般性能剖析工具都是这两则的结合，比如说perf, perf的sampling的机制是基于对事件的统计（比如1000个cpu周期(事件)采样一次)，故其实没太大的区分，最为常见的工具包括<a href="">perf</a>, <a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">systemtap</a>,<br>其中perf和systemtap下面会进一步介绍</li>
</ul>
</li>
</ul>
<h3 id="解释型语言的热点分析"><a href="#解释型语言的热点分析" class="headerlink" title="解释型语言的热点分析"></a>解释型语言的热点分析</h3><p>上面剖析出来的更多是C/C++代码层面的函数热点，但如果是一个解释型的脚本语言，要找出脚本的代码热点，上面的方法并不靠谱，还需要进一步的支持。其主要原因是一般解释型语言的实现大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">vm_execute</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//fetch code</span></div><div class="line">        <span class="keyword">switch</span>(op) &#123;</div><div class="line">            <span class="keyword">case</span> BYTECODE_A: <span class="comment">//do somthing a</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BTYECODE_B: <span class="comment">//do something b</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在执行的时候会发现大部分热点是在<code>vm_execute</code>里面，我们看不到代码级别的热点，故没有太多参考意义。</p>
<p>java，php, nodejs, lua等都面临此类问题，那他们是如何解决的，大致如下:</p>
<ul>
<li><p>语言/扩展层面提供具体的解决方案 : 比如php的xprofile，其<a href="http://blog.csdn.net/yzongyu/article/details/8457209" target="_blank" rel="external">机制</a>大体类似</p>
</li>
<li><p>语言层面提供部分支持，再通过外部工具进行剖析 : 也是语言层面的支持，但和上述不同的是，并不是提供具体是profile的支持，而是一些机制的支持,再和一些外部工具结合(比如perf record)，产生性能剖析的结果，比较常见的包括:</p>
<ul>
<li>JVM的JVMTI机制，提供提供给性能分析器的hook，可以抓到像函数调用、类加载、卸载、线程的进入及离开等事件, 具体可以见<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jpda2/" target="_blank" rel="external">深入 Java 调试体系，第 2 部分: JVMTI 和 Agent 实现</a></li>
<li>luajit的<code>LUAJIT_USE_PERFTOOLS</code> option，具体可以看下文 </li>
</ul>
</li>
<li><p>语言层面不提供任何支持 : 比如lua，此时只能依赖外部工具了，现在比较常见的是systemtap，下面会详细介绍systemtap如何进行lua源码级别的性能剖析</p>
</li>
</ul>
<h2 id="0x02-lua源码的性能剖析"><a href="#0x02-lua源码的性能剖析" class="headerlink" title="0x02 lua源码的性能剖析"></a>0x02 lua源码的性能剖析</h2><p>联系到我们的具体需求，我们主要是考虑现有的工具如果快速支持nginx/lua的性能剖析，从两个最为常见的工具入手: systemtap和perf tools，看下他们对这个的支持情况</p>
<h3 id="基于systemtap的性能分析"><a href="#基于systemtap的性能分析" class="headerlink" title="基于systemtap的性能分析"></a>基于systemtap的性能分析</h3><p><a href="https://github.com/agentzh" target="_blank" rel="external">agentzh</a>在git的<a href="https://github.com/openresty/nginx-systemtap-toolkit" target="_blank" rel="external">openresty/nginx-systemtap-toolkit</a>就已经提供了对lua/luajit的源码级别的热点发现，那他是如何实现的呢？</p>
<p>简单介绍下systemtap一些核心特性,包括:</p>
<ul>
<li>systemtap支持多样的probe, 包括kernel/user space function调用，离开等事件</li>
<li>systemtap支持读取特定进程的内存信息，同时支持加载特定的符号信息</li>
<li>systamtap支持类C语法的指针操作</li>
</ul>
<p>依照如上特性，systemtap对lua源码的栈帧的采集策略大概如下:</p>
<blockquote>
<p>perl脚本，来自ngx-sample-lua-bt : <a href="https://github.com/openresty/nginx-systemtap-toolkit/blob/master/ngx-sample-lua-bt" target="_blank" rel="external">https://github.com/openresty/nginx-systemtap-toolkit/blob/master/ngx-sample-lua-bt</a></p>
</blockquote>
<ol>
<li>通过probe, 获取VM的指针</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 监测lua_pcall函数，存储VM的指针</div><div class="line">probe process(<span class="string">"$lua_path"</span>).function(<span class="string">"lua_resume"</span>),</div><div class="line">      process(<span class="string">"$lua_path"</span>).function(<span class="string">"lua_pcall"</span>)</div><div class="line">&#123;</div><div class="line">    my_pid = pid()</div><div class="line">    <span class="keyword">if</span> ($condition) &#123;</div><div class="line">        lua_states[my_pid] = \$L</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>通过VM的指针，依照语言特性，获取栈帧</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 依照语言特性, 获取栈帧 --&gt; 强语言依赖</div><div class="line">function lua_getstack(L, level) &#123;</div><div class="line">    <span class="regexp">/* code from function lj_debug_frame in LuaJIT 2.0 */</span></div><div class="line">    /* TValue *frame, *nextframe, *bot; *<span class="regexp">/</span></div><div class="line">    bot = tvref(\&amp;$L-&gt;stack)  /<span class="regexp">/ TValue *</span></div><div class="line">    found_frame = 0</div><div class="line">    for (nextframe = frame = $L-&gt;base - $sizeof_TValue; frame &gt; bot; ) &#123;</div><div class="line">        /* Traverse frames backwards *<span class="regexp">/</span></div><div class="line">        if (frame_gc(frame) == L) &#123;</div><div class="line">            /<span class="regexp">/dd("Skip dummy frames. See lj_meta_call")</span></div><div class="line">            level++</div><div class="line">        &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<ol>
<li>通过<code>timer probe</code>进行频繁的采样和存储</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">probe timer.profile &#123;</div><div class="line">    my_pid = pid()</div><div class="line">    <span class="keyword">if</span> ($condition) &#123;</div><div class="line">        L = lua_states[my_pid]</div><div class="line">        // 采样 &amp;&amp; 存储</div></pre></td></tr></table></figure>
<p>大概的原理就是通过systemtap定时器和进程侵入的特性，直接读取nginx进程的地址空间内容，又依照对nginx lua/luajit的内存布局理解(通过review lua/luajit的源码)，直接打印出栈布局。 这要求systemtap脚本对lua/luajit的代码非常熟悉，而且一旦程序有相关升级之类的，可能就有兼容性问题 </p>
<p>总结下来，如下:</p>
<ul>
<li>优点: 功能强大，同时支持lua/luajit</li>
<li>缺点: systemtap在线上安装成本颇高，后续维护也是问题</li>
</ul>
<h3 id="基于perf-record的性能分析"><a href="#基于perf-record的性能分析" class="headerlink" title="基于perf record的性能分析"></a>基于perf record的性能分析</h3><p>考虑到systemtap落地和维护的成本，我们在考虑能不能用<code>perf record</code>做一个简单的支持。答案是肯定的!</p>
<p>在2009年，perf events增加了对<a href="https://lkml.org/lkml/2009/6/8/499" target="_blank" rel="external">jit symbol的支持</a>, 总的来说一个JIT的VM只要做如下的支持就可以了:</p>
<ul>
<li>应用程序需要导出<code>/tmp/perf-PID.map</code>的文件, 文件以文本格式存储内存地址，大小以及符号名称 </li>
</ul>
<p>其中<a href="http://www.brendangregg.com/blog/2014-06-12/java-flame-graphs.html" target="_blank" rel="external">jave</a>和<a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="external">nodejs</a>先后依据此特性增加了对perf tool的支持</p>
<p>那luajit呢？是否有这个方面的支持？查阅了luajit的官网上面的文档，并没有涉及此方面的讨论，连Makefile里面的feature也没有提及到这一点。不过直接grep源码，还是有惊喜的，如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[chenjiansen@cq01-rdqa-dev028.cq01.baidu.com LuaJIT-2.0.3]$ grep <span class="string">"perftool"</span> * -r -i -n</div><div class="line">src/lj_trace.c:85:<span class="comment">#ifdef LUAJIT_USE_PERFTOOLS</span></div><div class="line">src/lj_trace.c:96:static void perftools_addtrace(GCtrace *T)<span class="string">""</span></div></pre></td></tr></table></figure>
<p>简单的说，主要开启<code>LUAJIT_USE_PERFTOOLS</code>宏，应该就能自动导出<code>/tmp/perf-{PDI}</code>文件</p>
<p>重新编译luajit，执行nginx/lua，可以看到的确有相关文件导出，如下:</p>
<blockquote>
<p>luajit在每次jit的时候，会导出此符号文件，但这些不一定的应用程序的热点, 只是lua vm的热点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[forum@db-forum-phpfr01.db01.baidu.com ~]$ cat /tmp/perf-23998.map </div><div class="line">bffff55 a4 TRACE_1::/home/work/nginx_inner/lua/tieba/lua_script/service_status/setServiceStatus.lua:89</div><div class="line">bffff2a 24 TRACE_2::/home/work/nginx_inner/lua/tieba/lua_script/service_status/setServiceStatus.lua:90</div><div class="line">bfffe96 8d TRACE_3::/home/work/nginx_inner/lua/tieba/lua_script/util/http_instruct_util.lua:47</div><div class="line">bfffd40 14f TRACE_4::/home/work/nginx_inner/lua/tieba/lua_script/rewrite/ngx_rewrite_server_degradation.lua:1</div></pre></td></tr></table></figure>
<p>用<code>perf report</code>就可以看到如下的结果:</p>
<p><img src="perf_report_sample.png" alt="perf_report_demo"></p>
<p>总结下来，如下:</p>
<ul>
<li>优点: 使用起来简单方便，无需太多的额外操作</li>
<li>缺点: 灵活性有限，仅支持luajit</li>
</ul>
<h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3><p>如上采样统计分析的结果，一般就是各种栈帧的采集，需要一些工具做进一步的分析总结，比如说用<code>perf report</code>进行分析</p>
<p>而<a href="http://www.brendangregg.com/blog/index.html" target="_blank" rel="external">Brendan Gregg</a>的<a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">火焰图</a> 则给这些数据做一个可视化的展现，通过简单的<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">脚本</a>能快速生成相应的<code>.svg</code> 文件，通过浏览器可以清晰的看到具体的热点</p>
<p>如下是一个火焰图的<a href="http://db-forum-phpfr01.db01.baidu.com:8200/svg//nginx_runtime_jit.svg" target="_blank" rel="external">demo</a>:</p>
<p><img src="http://db-forum-phpfr01.db01.baidu.com:8200/svg//nginx_runtime_jit.svg" alt="flame_demo"></p>
<p>可以清楚的看到热点在<code>test.lua:7</code>这个地方</p>
<h2 id="0x03-后续计划"><a href="#0x03-后续计划" class="headerlink" title="0x03 后续计划"></a>0x03 后续计划</h2><blockquote>
<p>短期内的贴吧落地实践</p>
</blockquote>
<p>主要采用<code>perf record + luajit</code>的机制, 为了满足此需求，现实的nginx会调整如下:</p>
<ul>
<li>nginx lua全部迁移nginx luajit : 之前有些case问题，这方面会重新review，争取全部迁移过去</li>
<li>所有线下的luajit编译时候开启<code>LUAJIT_USE_PERFTOOLS</code>选项(由于不会自动删除过期文件，且reload的时候会重新生成/temp/perf-*文件，线上暂不开启)</li>
<li>在上线流程的时候，性能测试报告，必须附上火焰图的链接</li>
</ul>
<p>如下两个图的router和inrouter的性能分析图(可以看到inrouter的的DNA扩展占用了3%的无效cpu)</p>
<blockquote>
<p>使用http_load 压测（可以沟通不同的URL), runtime nginx用nginx lua简单mock了</p>
</blockquote>
<ul>
<li>router的火焰图(<a href="http://db-forum-phpfr01.db01.baidu.com:8200/svg//router_jit.svg" target="_blank" rel="external">点此</a>新窗口打开)</li>
</ul>
<p><img src="http://db-forum-phpfr01.db01.baidu.com:8200/svg//router_jit.svg" alt="router_flame"></p>
<ul>
<li>inrouter的火焰图(<a href="http://db-forum-phpfr01.db01.baidu.com:8200/svg//inner_jit.svg" target="_blank" rel="external">点此</a>新窗口打开)<br><img src="http://db-forum-phpfr01.db01.baidu.com:8200/svg//inner_jit.svg" alt="inrouter_flame"></li>
</ul>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>上面讨论略去一些无关的细节，比如说<code>perf</code>在后续的版本也支持了<a href="https://gnu.wildebeest.org/blog/mjw/2012/05/24/pull-user-space-probe-instrumentation/" target="_blank" rel="external">function probe</a>的功能, 一些结论也是猜测，可能有比较多的错误之处，欢迎指出</p>
<p>最后附上一些参考资料: </p>
<ul>
<li>perf的一些资料<ul>
<li><a href="http://www.brendangregg.com/perf.html#FlameGraphs" target="_blank" rel="external">perf Examples</a> : 具体介绍了perf record的优缺点以及具体的解决方案</li>
<li><a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="external">Perf Tutorial</a> : perf的非常不错入门介绍，介绍简单的使用和内部机制</li>
<li><a href="http://files.cnblogs.com/files/jiayy/Perf%E5%9C%A8Linux%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8_v3.pdf" target="_blank" rel="external">Perf在Linux性能评估中的应用</a> : 淘宝承刚的perf PDF，入门也是不错的</li>
</ul>
</li>
<li><p>systemtap的资料</p>
<ul>
<li><a href="https://sourceware.org/systemtap/wiki" target="_blank" rel="external">systemtap wiki主页</a></li>
<li><a href="http://blog.yufeng.info/archives/tag/systemtap" target="_blank" rel="external">系统技术非业余研究: systemtap的专题</a></li>
</ul>
</li>
<li><p><a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">CPU Flame Graphs</a> : CPU火焰图说明</p>
</li>
<li><a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="external">node.js Flame Graphs on Linux</a> : nodejs的火焰图</li>
<li><a href="http://www.slideshare.net/chaoslawful/cc-14971110" target="_blank" rel="external">C/C++调试、跟踪及性能分析工具综述</a></li>
<li><a href="http://www.slideshare.net/brendangregg/linux-performance-analysis-new-tools-and-old-secrets" target="_blank" rel="external">Linux Performance Analysis: New Tools and Old Secrets</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-nginx_https_proxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/25/nginx_https_proxy/">nginx与https -- 正向代理支持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/25/nginx_https_proxy/" class="article-date">
  <time datetime="2015-04-25T07:34:36.000Z" itemprop="datePublished">2015-04-25</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，nginx的对于http(s)反向代理的支持一直不错，但对正向代理(正向VS反向代理区别，见<a href="http://z00w00.blog.51cto.com/515114/1031287" target="_blank" rel="external">图解正向代理、反向代理、透明代理</a>)的支持如何呢？</p>
<p>对于http正向代理, nginx很早就支持了，具体如何配置nginx的正向代理可以见:<a href="http://rhomobi.com/topics/94" target="_blank" rel="external">Nginx配置正向http代理</a></p>
<p>而对于https的正向代理，nginx是从1.5.6版本，才开始逐渐支持, 现在看来其实是比较晚的版本，可以理解要支持https正向代理还是需要一些成本的。本文主要简单介绍下nginx要支持https需要支持的运行机制以及具体如何配置nginx才能支持https。代码层面的实现，暂不赘述。</p>
<p>希望通过这篇文件让大家了解如何配置nginx的https正向代理，以及对https协议有个简单的了解。</p>
<h2 id="要怎么做"><a href="#要怎么做" class="headerlink" title="要怎么做"></a>要怎么做</h2><p>如上，如果支持了https，就是要在和upstream交互的过程中支持https协议，如下是TLS协议的示意图，总的来说就是会多一些HTTPS握手的流程，因此nginx在具体实现上面就是需要支持HTTPS握手，以及此方面的相关配置：</p>
<p><img src="/images/ssl-handshake.png" alt="ssl-handshake.png"></p>
<p>就是要实现一个完整的<code>client-hello</code>, <code>client key change</code>等(如果做https反向代理，主要做的事情是<code>server hello</code>等)，好在openssl库其实此类都有完整的支持，nginx只需要根据自己的框架套进去就可以了。</p>
<p>同样，nginx对正向代理的支持，也就体现在对client这边行为的控制。</p>
<h2 id="nginx支持哪些"><a href="#nginx支持哪些" class="headerlink" title="nginx支持哪些"></a>nginx支持哪些</h2><p>通过上面的分析，nginx具体在支持请求https的时候，主要是包括如下几个方面的控制:</p>
<h4 id="对server的验证和识别"><a href="#对server的验证和识别" class="headerlink" title="对server的验证和识别"></a>对server的验证和识别</h4><p>传统情况下，我们对server的失败是通过浏览器内部以及相关配置的CA去做的，现在如果让nginx去连接https服务器，而且我们也希望做相关的身份验证的话, 就得配置相关的CA以及证书链之类的，具体包括:</p>
<ul>
<li>proxy_ssl_verify : 是否验证服务端</li>
<li>proxy_ssl_crl : 配置验证服务端的CRL(吊销证书列表)</li>
<li>proxy_ssl_trusted_certificate : 配置验证服务端的CA列表</li>
<li>proxy_ssl_verify_depth : 配置验证证书链的深度</li>
</ul>
<h4 id="对client的标识"><a href="#对client的标识" class="headerlink" title="对client的标识"></a>对client的标识</h4><p>有些情况下，server端还会有对client端进行身份验证的需求（比如vpn登陆），因此nginx还支持配置client端的证书信息，具体包括:</p>
<ul>
<li>proxy_ssl_certificate : 指定client公钥文件的地址</li>
<li>proxy_ssl_certificate_key : 指定client密钥文件地址</li>
<li>proxy_ssl_ciphers : 指定可以采用的加密算法列表</li>
<li>proxy_ssl_protocols : 指定要采用的HTTPS(TLS协议)</li>
<li>proxy_ssl_name : 指定用于要访问和SNI里面传送的域名，默认用的是proxy_pass的URL域名</li>
<li>proxy_ssl_password_file : 指定密钥文件（待明确!）</li>
</ul>
<h4 id="其他性能-优化相关的"><a href="#其他性能-优化相关的" class="headerlink" title="其他性能/优化相关的"></a>其他性能/优化相关的</h4><ul>
<li>proxy_ssl_server_name : 是否启用SNI机制</li>
<li>proxy_ssl_session_reuse : 是否复用ssl session</li>
</ul>
<p>其中<a href="http://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="external">SNI机制</a>，可以简单理解是允许在发送https请求加个类似http协议里面的host域，这样允许一个IP和PORT同时支持多个域名</p>
<p>而SSL Session机制则允许减少<code>TLS握手的次数</code>, 包括sesseion tickets和session identifier; 启用这个的话，nginx内部会用<code>SSL_session_reused</code>尝试复用，具体https的性能优化和内部策略，后面一篇文章(nginx的https反向代理支持)再细说。</p>
<h2 id="配置demo"><a href="#配置demo" class="headerlink" title="配置demo"></a>配置demo</h2><p>如下是nginx正向代理的配置的demo（开启服务端检测)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="attribute">location</span> / &#123;</div><div class="line">    <span class="attribute">proxy_ssl_verify</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">proxy_ssl_trusted_certificate</span> /home/users/chenjiansen/nginx_ssl/root_ca.pem;</div><div class="line">    <span class="attribute">proxy_ssl_verify_depth</span> <span class="number">9</span>;</div><div class="line">    <span class="attribute">proxy_pass</span> https://<span class="variable">$http_host</span><span class="variable">$request_uri</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</div><div class="line">    <span class="attribute">proxy_set_header</span> <span class="string">"user-agent"</span> <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTM</span></div><div class="line">L, like Gecko) Chrome/42.0.2311.90 Safari/537.36';</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用如下命令可以尝试验证https代理的可用性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">"cq01-rdqa-dev028.xxxxx.com:8300"</span> -H<span class="string">"Host:www.baidu.com"</span></div></pre></td></tr></table></figure>
<h2 id="部署建议"><a href="#部署建议" class="headerlink" title="部署建议"></a>部署建议</h2><p>现在我们具体生产部署的时候，一般是调用一些第三方的支付接口，建议如下:</p>
<ul>
<li>开启服务端验证机制, 避免中间人攻击</li>
<li>根证书的配置尽量最少原则的, 不要配置太多无用的根证书。比如，我们如果明确就是用一个location访问<code>https://www.baidu.com</code>，而百度域的根证书是<code>VeriSign Class 3 Public Primary Certification Authority - G5</code> ，这样的话，我们的CA列表只要有这个根证书就可以了</li>
</ul>
<p>而一些其他的业务需求，对安全性等要求不是很高的话，可以按需调整。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://support.microsoft.com/en-us/kb/823503/zh-cn" target="_blank" rel="external">导入和导出证书以便能够在多台计算机上使用</a>, MAC系统更简单，在<code>钥匙串</code>里面直接点击导出即可</li>
<li><p><a href="http://nginx.com/resources/admin-guide/nginx-tcp-ssl-upstreams/" target="_blank" rel="external">Securing TCP Traffic to Upstream Servers</a></p>
</li>
<li><p><a href="http://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html" target="_blank" rel="external">Speeding up SSL: enabling session reuse</a></p>
</li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <article id="post-anti_censorship" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/anti_censorship/">翻墙杂谈</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/05/anti_censorship/" class="article-date">
  <time datetime="2015-04-05T11:01:40.000Z" itemprop="datePublished">2015-04-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-缘由"><a href="#1-缘由" class="headerlink" title="1. 缘由"></a>1. 缘由</h2><p>HC上面的一篇文件<a href="http://sites.inka.de/~W1011/devel/tcp-tcp.html" target="_blank" rel="external">Why TCP Over TCP Is A Bad Idea</a>，顺便梳理下之前零碎的几个知识点, 主要是一些代理，穿透的网络协议的乱七八糟的东西，这里主要说翻墙的一些手段和办法, 以此来说明网路穿透的一些相关机制。</p>
<h2 id="2-一些基础"><a href="#2-一些基础" class="headerlink" title="2. 一些基础"></a>2. 一些基础</h2><p>要翻墙前提是得有个VPS，可以自己去购买或者之类的，据同事反馈<a href="http://www.linode.name/" target="_blank" rel="external">linode</a>是不错的选择。有了VPS的话，现在问题就是如何利用VPS进行翻墙?</p>
<p>如下是简单的网络架构:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">client ----(GFW) ---&gt; VPS -----&gt; foreign website</div></pre></td></tr></table></figure>
<p>因此我们需要达到的功能其实可以简化成如下两个步骤:</p>
<ul>
<li>找个一个协议能够连上VPS</li>
<li>让VPS上面的具体软件转发请求并且透传回来</li>
</ul>
<h3 id="2-1-连接VPS的方法"><a href="#2-1-连接VPS的方法" class="headerlink" title="2.1 连接VPS的方法"></a>2.1 连接VPS的方法</h3><blockquote>
<p>PS本部分都是自己理解，全凭自己猜测</p>
</blockquote>
<p>连接vps不仅仅是能ping到这个机器，一般是指能够安全加密的和改VPS交互，总结起来大概可以统称为<a href="http://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">隧道协议</a>, 而隧道协议可以根据协议所工作的ISO层，有如下几类:</p>
<h5 id="2-1-1-VPN协议"><a href="#2-1-1-VPN协议" class="headerlink" title="2.1.1 VPN协议"></a>2.1.1 VPN协议</h5><p>用于传统支持VPN的相关协议，一般是工作在网络层以下（含），具体包括:</p>
<ul>
<li>PPTP/L2TP : 都是基于PPP协议的二层隧道协议, 工作在数据链路层</li>
<li>IPsec/AppleTalk : 三层隧道协议,工作在网络层</li>
</ul>
<h5 id="2-1-2-会话层协议"><a href="#2-1-2-会话层协议" class="headerlink" title="2.1.2 会话层协议"></a>2.1.2 会话层协议</h5><p>这方面的代表主要是<a href="http://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="external">SOCKS协议</a>, 也是我们常见的SOCKS代理实现的协议</p>
<h5 id="2-1-3-应用层协议"><a href="#2-1-3-应用层协议" class="headerlink" title="2.1.3 应用层协议"></a>2.1.3 应用层协议</h5><p>具体的包括SSH隧道，一个通过SSH协议建立起来的连接隧道</p>
<h3 id="2-2-请求转发"><a href="#2-2-请求转发" class="headerlink" title="2.2 请求转发"></a>2.2 请求转发</h3><p>一旦你连接上了一个具体的服务器，要做请求转发相对来说就比较容易了，而且此事一般是代理软件帮你完成的，同样跟进理解到服务器的协议的不同，代理软件也做着不同层次的支持，以我了解到的, 包括:</p>
<ul>
<li>ip层的请求转发，此策略常见于配置VPN服务器的需求，比如如果搭建一个PPTP的服务器，一般需要通过如下方法进行转发:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sudo sed -i <span class="string">'s/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g'</span> /etc/sysctl.conf</div><div class="line">sudo sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员</span></div><div class="line">sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</div></pre></td></tr></table></figure>
<ul>
<li><p>数据层的转发，主要是SOCKS代理服务器，Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）</p>
</li>
<li><p>应用层的转发，举个例子通过nginx配置正向代理之类的, 用处感觉比较少</p>
</li>
</ul>
<h2 id="3-具体应用"><a href="#3-具体应用" class="headerlink" title="3. 具体应用"></a>3. 具体应用</h2><p>有了上面的基础，我们就可以根据自己的需求创建具体的翻墙策略，这里主要介绍两个，其一是PPTP代理，其二是SSH隧道</p>
<h3 id="3-1-PPTP代理"><a href="#3-1-PPTP代理" class="headerlink" title="3.1 PPTP代理"></a>3.1 PPTP代理</h3><p>PPTP代理的一个优点是快，缺点个人感觉有两个:</p>
<ul>
<li>通用性不强：其对网关有一定的要求，一些路由器之类的不一定支持(比如我们家的TPLINK的某一型号路由器)</li>
<li>可控性或者自由度不够: 由于PPTP工作较为底层，这也就意味着，如果你一旦启用他，整个PC某人情况下都会走代理，但是大多是时候，我们可能指希望某类应用或者协议（比如HTTP)走代理。如果要达到此目标，还需要额外的控制</li>
</ul>
<p>具体如何配置，这里也不赘述，具体可以参看链接: <a href="http://blog.fens.me/ubuntu-vpn-pptp/" target="_blank" rel="external">在Ubuntu上安装PPTP VPN服务</a></p>
<h3 id="3-2-ssh隧道"><a href="#3-2-ssh隧道" class="headerlink" title="3.2 ssh隧道"></a>3.2 ssh隧道</h3><p>如上，SSH隧道是通过ssh协议构建的一个应用层隧道，因此其可以灵活控制。而大多是SSH客户端支持SOCKS代理，也就是通过建立一个动态的SSH转发，其自动启动一个SOCKS代理，这样浏览器等就可以很方便的使用类似SOCKS代理的方式通信了</p>
<p>ssh命令启动一个动态SSH隧道的命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -NTf -D 9000 &lt;ssh server&gt;</div></pre></td></tr></table></figure>
<p>具体可以参考<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战 SSH 端口转发</a></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><p>上面主要介绍了我们如何控制我们机器的网络交互通道来达到翻墙的目标。而对于最常见的HTTP代理，浏览器那边其实也做了一些支持，主要是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="external">代理自动配置</a>，改方案核心思路和上述一样（都是要找代理服务器的啊），但是具体实现层面的话，可以理解是浏览器主动托管了网络交互那层，因此对用户而言，只要配置合理的PAC就可以了, 还是相关不错的</p>
<p>其他的还有很多方案，具体可以参看wiki百科的<a href="http://zh.wikipedia.org/wiki/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="external">突破网络审查</a></p>
<h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h2><p>首先，建议对几个协议，大家可以具体<a href="http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" target="_blank" rel="external">维基百科</a>之</p>
<ul>
<li><a href="http://www.vpninstructions.com/whats-the-difference-between-pptp-l2tp-openvpn-and-socks-when-talking-about-vpns/" target="_blank" rel="external">What’s the difference between PPTP, L2TP, OpenVPN, and SOCKS when talking about VPNs?</a> : 介绍了PPTP,SOCKS等几个协议的异同点</li>
</ul>
<p>ssh相关的:</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="external">SSH原理与运用（二）：远程操作与端口转发</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战SSH端口转发</a></li>
<li><a href="http://www.iokay.net/it-technology/ssh-proxy" target="_blank" rel="external">利用SSH代理爬墙</a></li>
</ul>

      
    </div>
    
    
  </div>
  
</article>








    
      <article id="post-io_in_linux_and_nginx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/05/io_in_linux_and_nginx/">linux和nginx下的异步文件IO管理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/04/05/io_in_linux_and_nginx/" class="article-date">
  <time datetime="2015-04-05T06:17:28.000Z" itemprop="datePublished">2015-04-05</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx在其最近发布的<a href="http://nginx.org/en/CHANGES" target="_blank" rel="external">1.7.11版本增加了thread pool</a>的feature, 其引入的<a href="http://nginx.org/en/docs/ngx_core_module.html#thread_pool" target="_blank" rel="external">thread_pool</a>主要是能真正意义的保证读写文件的非阻塞以及异步。为什么需要主动添加<code>thread pool</code>这个机制来支持异步非阻塞的文件读写呢？这里简单说下linux的文件IO管理和以及nginx的thread poo机制的必要性，最后说下nginx thread pool的大致实现机制。</p>
<p>其实关于linux和nginx的IO管理，已经有非常详细的说明文档，具体包括如下:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
</ul>
<p>这里只是针对上面介绍内容的一个简单总结和概述</p>
<h3 id="linux下的异步IO支持"><a href="#linux下的异步IO支持" class="headerlink" title="linux下的异步IO支持"></a>linux下的异步IO支持</h3><p>linux下主要有如下两个方式的异步IO支持，分别如下:</p>
<h4 id="glibc-异步IO支持"><a href="#glibc-异步IO支持" class="headerlink" title="glibc 异步IO支持"></a>glibc 异步IO支持</h4><p>这个是glibc提供的一系列函数，包括<code>aio_read</code>, <code>aio_suspend</code>等(‘man aio_read’查看具体用法), 其核心特点是使用较为方便，但是在实现层面的话，其实是在用户层通过多线程实现的，并非真正意义上面的异步IO，因此其性能相对于真正意义上面的异步IO要慢一些。</p>
<h4 id="native-AIO支持"><a href="#native-AIO支持" class="headerlink" title="native AIO支持"></a>native AIO支持</h4><p>其实linux本身已经提供了对异步io的支持[2.5版本开始]，也就是<code>io_submit</code>, <code>io_setup</code>之类的函数，但是glibc并没有对这类函数进行封装，因此如果要使用的话，可以通过:<br>1) syscall直接调用操作系统API<br>2) <a href="http://lse.sourceforge.net/io/aio.html" target="_blank" rel="external">libaio</a> : 一个轻量级的封装库</p>
<p>来使用。</p>
<p>由于直接是操作系统的支持，因此此类函数的性能相对比与glibc的aio性能上面有较大的提升，但同时也面临着如下两个比较大的问题，导致其应用范围大大受限:</p>
<ul>
<li>使用AIO必须打开<code>IO_DIRECT</code> flag，同时要求读写的的大小和偏移要以区块的方式对齐</li>
<li>启用AIO同时会关闭<code>sendfile</code>，也就意味着此时会丧失了零拷贝的特征；如果继续使用sendfile, 意味着读可能会阻塞</li>
</ul>
<p>总之，在现有的linux体系下，对文件的异步读写，没有完美的简单的解决方案。</p>
<h3 id="nginx对异步IO的支持"><a href="#nginx对异步IO的支持" class="headerlink" title="nginx对异步IO的支持"></a>nginx对异步IO的支持</h3><p>nginx和异步IO相关的主要指令有:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">syntax : aio on | off | thread ;</div><div class="line"></div><div class="line">是否启动aio，如果是指定其关联的thread pool name </div><div class="line"></div><div class="line">syntax : directio size | off ;</div><div class="line"></div><div class="line">是否启用directio; 或者在大于size之后才启用directio</div><div class="line"></div><div class="line">syntax : sendfile on | off  ;</div><div class="line"></div><div class="line">是否启用sendfile </div><div class="line"></div><div class="line">## 加上最新的thread pool</div><div class="line"></div><div class="line">syntax : thread_pool name threads=number [max_queue=number];</div><div class="line"></div><div class="line">创建一个thread pool</div></pre></td></tr></table></figure>
<p>具体可以参看<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#aio" target="_blank" rel="external">nginx官方说明文档</a></p>
<p>基于如上的总结，当<code>aio</code>, <code>directio</code>, <code>sendfile</code>都开启的时候(如果有off的情况，判断较为简单，不在赘述)，整个nginx对文件的读取策略如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                     _  use aio   _</div><div class="line">                   /                \</div><div class="line">                 yes            has thread pool</div><div class="line">                /                      \</div><div class="line">directio &gt; size                        support asyn &amp; noblock IO</div><div class="line">                \                      /</div><div class="line">                 no             has thread pool</div><div class="line">                   \                 /</div><div class="line">                    \_ use sendfile /</div></pre></td></tr></table></figure>
<h3 id="nginx的thread-pool机制"><a href="#nginx的thread-pool机制" class="headerlink" title="nginx的thread pool机制"></a>nginx的thread pool机制</h3><p>本来想详细介绍nginx thread pool的实现机制，但是发现可以展开讨论的内容不多。这里就做个系统性的总结。</p>
<p>由于linux系统对异步IO的支持有着或多或少的局限性，如果nginx要保证其整个worker进程异步非阻塞的模型有一定的难度，因为在读取文件的时候可以存在着阻塞的情况。</p>
<p>为此nginx的解决方案是引入thread pool, 用户可以创建特定个数的thread pool，每个thread pool可以指定其具体的OS线程数。现在thread pool的核心作用就是托管一些可能存在阻塞的IO操作（包括普通的read, sendfile）, 当有此类操作的时候，nginx会根据用户的配置把任务递送给线程池，尽量不阻塞worker进程。</p>
<p>具体到thread pool的实现，没有特别的地方(不过我也没看的特别细)，通过<code>pthread lib</code>维护一堆线程, 用户可以提交具体的task给线程池，让其消费。</p>
<p>其主要作用可能是会提高那些存在高IO读取的webserver的并发支持数。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://cnodejs.org/topic/4f16442ccae1f4aa270010a7" target="_blank" rel="external">linux AIO(异步IO)那点事儿</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></li>
<li><a href="http://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux" target="_blank" rel="external">Difference between POSIX AIO and libaio on Linux?</a></li>
</ul>
<p>lenky关于AIO的系列文章:</p>
<ul>
<li><a href="http://www.lenky.info/archives/2013/01/2165" target="_blank" rel="external">异步I/O之glibc AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2182" target="_blank" rel="external">异步I/O之native AIO篇</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2184" target="_blank" rel="external">nginx对Linux native AIO机制的应用(配置篇)</a></li>
<li><a href="http://www.lenky.info/archives/2013/01/2186" target="_blank" rel="external">nginx对Linux native AIO机制的应用（实现篇）</a></li>
</ul>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

      </footer>
    
  </div>
  
</article>








    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/10/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>