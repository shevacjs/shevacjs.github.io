<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shevacjs home</title>
  <subtitle>自强不息</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shevacjs.com/"/>
  <updated>2018-09-09T10:59:54.000Z</updated>
  <id>http://shevacjs.com/</id>
  
  <author>
    <name>shevacjs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>weekly of 20180826</title>
    <link href="http://shevacjs.com/2018/09/09/20180826/"/>
    <id>http://shevacjs.com/2018/09/09/20180826/</id>
    <published>2018-09-09T10:58:45.000Z</published>
    <updated>2018-09-09T10:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://highperfdesign.com/post/async_io_intro/" target="_blank" rel="external">Introduction to Asynchronous I/O - High Performance computing</a> : 关于异步 IO 的介绍，这个是入门篇，后续希望有更深入的分析和介绍，先 mark</p>
</li>
<li><p><a href="https://lowleveldesign.org/2018/08/15/randomness-in-net/" target="_blank" rel="external">Randomness in .NET – lowleveldesign.org</a> : 分析<code>.NET</code>环境下面伪随机数的安全性，其实只要知道内部状态，就可以快速知道后续的序列了, 另外一篇可以重点学习的文章是<a href="http://lcamtuf.coredump.cx/oldtcp/tcpseq.html" target="_blank" rel="external">Strange Attractors and TCP/IP Sequence Number Analysis</a>, 讨论”inserting a malicious packet into a TCP connection”可行性</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://hacks.mozilla.org/2018/08/dweb-building-a-resilient-web-with-webtorrent/" target="_blank" rel="external">Dweb: Building a Resilient Web with WebTorrent – Mozilla Hacks – the Web developer blog</a> : 之前讨论过<code>webTorrent</code>的情况，最近通过了解磁力链接等，对于其内部实现和机制有了进一步的了解, Maybe 是下一代互联网的趋势, 可以参考其<a href="https://webtorrent.io/faq" target="_blank" rel="external">官网</a>举例的一些应用场景，包括对等文件传输, <a href="https://peercloud.io/" target="_blank" rel="external">PeerCloud</a>“Serverless websites via WebTorrent”</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404277899594202694" target="_blank" rel="external">卫夕 | 机器知道你会点广告：写给普通人的CTR预估科普</a> : 很好的的 CTR 入门介绍，值得了解</p>
</li>
<li><p><a href="https://github.com/TellinaTool/nl2bash" target="_blank" rel="external">TellinaTool/nl2bash: Generating bash command from natural language</a> :  </p>
</li>
<li><p><a href="http://www.styluslabs.com/" target="_blank" rel="external">Stylus Labs: Writer</a> : “writer is a word processor for handwriting”, 一个面向于手写场景的编辑器, 交互和功能支持方式很有针对性，可以参考下，不知道对中文输入场景的支持如何~</p>
</li>
<li><p><a href="https://nostarch.com/seriouscrypto" target="_blank" rel="external">Serious Cryptography | No Starch Press</a> : 一本介绍密码学相关的数据，看目录还不错，先 mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ok4oCRNQ9lrgtyTrk-d6gA" target="_blank" rel="external">MacTalk: 推荐几款 Mac 上的效率利器</a> : 推荐了几个<a href="http://macshuo.com/?p=625" target="_blank" rel="external">Alfred</a>, <a href="https://www.alfredapp.com" target="_blank" rel="external">Paste</a>, <code>Magnet</code>, <a href="https://mubu.com" target="_blank" rel="external">幕布</a>等工具, 个人感觉用起来一般~</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://highperfdesign.com/post/async_io_int
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>nginx 1.15.3 版本说明</title>
    <link href="http://shevacjs.com/2018/08/30/nginx_1_15_3/"/>
    <id>http://shevacjs.com/2018/08/30/nginx_1_15_3/</id>
    <published>2018-08-30T04:15:29.000Z</published>
    <updated>2018-09-09T11:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-Feature-List"><a href="#0x00-Feature-List" class="headerlink" title="0x00 Feature List"></a>0x00 Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: now TLSv1.3 can be used with BoringSSL.</p>
</li>
<li><p>Feature: the “ssl_early_data” directive, currently available with BoringSSL.</p>
</li>
<li><p>Feature: the “keepalive_timeout” and “keepalive_requests” directives in the “upstream” block.</p>
</li>
</ul>
<p>前两者关于<code>BoringSSL</code>和 TLS 相关的优化，后者是 keepalive 特性的优化，下面分别介绍。</p>
<h2 id="0x01-UPSTREAM-KEEPALIVE"><a href="#0x01-UPSTREAM-KEEPALIVE" class="headerlink" title="0x01 UPSTREAM KEEPALIVE"></a>0x01 UPSTREAM KEEPALIVE</h2><p>关于Nginx Upstream 长连接池的机制可以参看之前的<a href="http://shevacjs.com/2016/01/19/tcp_keepalive_proxy/">让nginx支持TCP长连接代理</a>这篇文章，这次主要现在如下两个指令, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:   keepalive_timeout timeout;</div><div class="line">* Default:  keepalive_timeout 60s;</div><div class="line">* Context:  upstream</div><div class="line">&gt; This directive appeared in version 1.15.3.</div><div class="line"></div><div class="line">Sets a timeout during which an idle keepalive connection to an upstream server will stay open</div></pre></td></tr></table></figure>
<p>以及如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:    keepalive_requests number;</div><div class="line">* Default:   keepalive_requests 100;</div><div class="line">* Context:    upstream</div><div class="line">&gt; This directive appeared in version 1.15.3.</div><div class="line"></div><div class="line">After the maximum number of requests is made, the connection is closed.</div></pre></td></tr></table></figure>
<p>可以看到其主要作用是，当一个请求空闲<code>一段时间</code>(keepalive_timeout)或者处理过<code>足够多</code>(keepalive_requests)的请求, 则会关闭连接，以便重启;</p>
<p>其核心理念是希望长链接的请求能够回收重启, 原因是长连接容易造成一些边缘 case 和异常，比如<a href="https://trac.nginx.org/nginx/ticket/1170" target="_blank" rel="external">implement keepalive timeout for upstream</a> 和 <a href="https://trac.nginx.org/nginx/ticket/1484" target="_blank" rel="external">Timeouts when proxying to Apache and using Keepalive</a>, 提到的proxy server和 proxy 的竞争发送问题, Proxy server<code>time_wait</code>过多等问题; 代码修复实现相对比较简单，不再赘述。</p>
<h2 id="0x02-BoringSSL与-TLS"><a href="#0x02-BoringSSL与-TLS" class="headerlink" title="0x02 BoringSSL与 TLS"></a>0x02 BoringSSL与 TLS</h2><p>我们知道 OpenSSL是应用最为广泛的TLS协议的实现, 由于 TLS 的重要性以及 OpenSSL 实现的复杂性，其安全问题一直都存在着; 所以，业内也有提出其他的 OpenSSL 的实现方式，比如基于OpenSSL修改衍生的<a href="https://en.wikipedia.org/wiki/BoringSSL" target="_blank" rel="external">BoringSSL</a> 和 <a href="https://en.wikipedia.org/wiki/LibreSSL" target="_blank" rel="external">LibreSSL</a>, 这一类实现和 OpenSSL 基本保持接口的兼容，也就意味着宿主程序可以以较低的成本进行迁移; 还有一类是独立实现的，比如说<a href="https://bearssl.org/index.html#overview" target="_blank" rel="external">BearSSL</a> (建议可以深入了解)之类，其有自己特意的针对性目标和场景，其接口和<code>openssl</code>也不一致, 迁移成本较大。所以, Nginx从<code>1.7.4</code>开始, 开始兼容<code>BoringSSL and LibreSSL</code>, 其兼容成本也不算特别高。</p>
<p>具体编译的方法可以参考<a href="www.lidaren.com/archives/1702">Nginx替换OpenSSL为LibreSSL</a> 和 <a href="https://sometimesnaive.org/article/64" target="_blank" rel="external">Nginx 启用 BoringSSL</a>, 其核心是Nginx 编译脚本依赖的两类文件(考虑类Unix环境), 包括: </p>
<ul>
<li><code>$OPENSSL/.openssl/include/openssl/ssl.h</code>(参考auto/lib/openssl/make文件) : 头文件的依赖</li>
<li><code>$CORE_LIBS $OPENSSL/.openssl/lib/libssl.a</code>和<code>$CORE_LIBS $OPENSSL/.openssl/lib/libcrypto.a</code>(参考参考auto/lib/openssl/conf文件) : 链接库的依赖</li>
</ul>
<p>由于编译的脚本是死的，所以在准备<code>LibreSSL</code>或者<code>BoringSSL</code>的时候，保证上面两者的兼容性就可以了</p>
<p>再简单分析<code>LibreSSL/BoringSSL</code>和 OpenSSL 的一些差异点, 整体不同的TLS library的对比可以参考<a href="https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations" target="_blank" rel="external">Wiki:Comparison of TLS implementations</a>, 上面有比较详细的对比</p>
<h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><ul>
<li><p><a href="https://icmconference.org/wp-content/uploads/G12c-Bechis.pdf" target="_blank" rel="external">LibreSSL</a> : 比较系统的介绍<code>LibreSSL</code>项目初衷，目标以及如何实现(主要在代码实现方面有所取舍)的, 可以快速了解</p>
</li>
<li><p><a href="https://bearssl.org/" target="_blank" rel="external">BearSSL: Overview</a> : <code>BearSSL</code>也是一个TLS的实现, 里面保护很多比较最新的特性，比如说<code>时间无关</code>的支持, 是学习TLS的一个很好入门</p>
</li>
<li><p><a href="https://blog.cloudflare.com/make-ssl-boring-again/" target="_blank" rel="external">Make SSL boring again</a> : CloudFlare的<code>BoringSSL</code>的迁移实践和总结, 包括其优势，比如说较早的TLS1.3的支持, <code>X25519</code>的支持等, 其不足之处, 比如说<code>Slow Base64</code>(因为保证constant-time的), <code>missing OCSP</code>等，可以看出和了解BoringSSL和Openssl 的异同点</p>
</li>
<li><p><a href="https://elib.uni-stuttgart.de/bitstream/11682/9311/1/thesis.pdf" target="_blank" rel="external">Analysing and improving the crypto ecosystem of Rust</a> : 我们知道OpenSSL 现在主要的核心问题实现方面的漏洞, 其和C/C++语言的内存模型有一些关系, Rust的语言设计能很大的规避这方面的问题，这篇长 paper(一百多页) 就是介绍了如果通过Rust 构建一个更健壮的密码系统</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-Feature-List&quot;&gt;&lt;a href=&quot;#0x00-Feature-List&quot; class=&quot;headerlink&quot; title=&quot;0x00 Feature List&quot;&gt;&lt;/a&gt;0x00 Feature List&lt;/h2&gt;&lt;p&gt;主要包含如下两点: 
    
    </summary>
    
    
      <category term="nginx" scheme="http://shevacjs.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180812</title>
    <link href="http://shevacjs.com/2018/08/22/20180812/"/>
    <id>http://shevacjs.com/2018/08/22/20180812/</id>
    <published>2018-08-22T13:19:45.000Z</published>
    <updated>2018-08-22T13:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="http://www.linuxeden.com/a/34651" target="_blank" rel="external">传输层安全协议 TLS 1.3 RFC 8446 正式发布</a> : 一个 RFC 文档整整有160页~</p>
</li>
<li><p><a href="https://www.oschina.net/news/98827/github-open-sourced-glb-director" target="_blank" rel="external">重磅！GitHub 开源负载均衡组件 GLB Director</a> : Github开放的三层的负载均衡器</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651008578&amp;idx=3&amp;sn=05043b800d49bd3f4206911493a92dff" target="_blank" rel="external">后台服务出现“明显变慢”，该如何诊断？</a> :  相比而已比较干货的内容，可以通过其介绍的方式来 Review 自己对工具链以及方法论的完善度进行评估</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/796slUjYygDWh_V4-8Vstg" target="_blank" rel="external">IBM新创AI病毒：想打谁就打谁，看脸发作绝不误伤，隐蔽性极强</a> : AI赋能业务，无论攻防都面临新的机遇和挑战~</p>
</li>
<li><p><a href="https://github.com/google/xi-editor/blob/e8065a3993b80af0aadbca0e50602125d60e4e38/doc/crdt-details.md" target="_blank" rel="external">The Xi Text Engine CRDT</a> : “This document contains a detailed description of the data structures and operations Xi uses for text”</p>
</li>
<li><p><a href="https://medium.com/netflix-techblog/pseudo-localization-netflix-12fff76fbcbe" target="_blank" rel="external">Pseudo Localization @ Netflix – Netflix TechBlog – Medium</a> : 全球化一直是Netflix前进发展面临的挑战, 如何提升全球化部署的效率是一个巨大的调整；文章重点介绍了Netflix 如何解决本地化 UI 的问题, 通过配置”伪本地化”的方式，生成特定规则的假数据，以便预先和快速的发展问题, 可以参考另外一篇文章<a href="https://medium.com/netflix-techblog/localization-technologies-at-netflix-d033e7b13cf" target="_blank" rel="external">Localization Technologies at Netflix</a></p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://cacm.acm.org/magazines/2018/8/229771-traceability/fulltext" target="_blank" rel="external">Web Traceability</a> : 本文是前ACM 主席对于互联网”可追踪性”的一个讨论和想法。互联网的兴起大大改变了我们的生活方式，但是其虚拟，匿名，加密等特性也是一把双刃剑，一方面使得用户的隐私得到有些保障, 另一个方面也引发的网络犯罪等行为; 作者的思路是: 首先，可追踪性还是要支持的，不过需要引入一些附加的流程和手段，比如说我们路上可以随便看到车牌，但是真正能查到车票对应的人只有执法部门；其次，对于技术上面的实现，其设计的点和面比较多，需要跟进前者的机制再针对性的建设~</p>
</li>
<li><p><a href="https://www.instructables.com/id/Literary-Clock-Made-From-E-reader/" target="_blank" rel="external">Literary Clock Made From E-reader: 6 Steps (with Pictures)</a> : 文章介绍了如何对<code>Kindle</code>进行破解，把其改成一个时钟, 先 mark，有空研究下 kindle 的破解手段</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247492096&amp;idx=1&amp;sn=511646facbdac81165176a5e9fa11784" target="_blank" rel="external">都去炒AI和大数据了，落地的事儿谁来做？</a> : 真正的系统架构师，既要往上高瞻远瞩，更要考虑落地以及业务的困难点; 其实现在 AI 的概念和场景『感觉』上面可以解决很多问题，但是真正落地的时候其坑和问题肯定不会少，AI 工程的标准化和流程感觉需要持续探索和摸索~</p>
</li>
<li><p><a href="https://google.github.io/filament/Filament.md.html#toc1.1" target="_blank" rel="external">Filament</a> : “Physically-based rendering engine”, 先 mark，有空深入分析下~</p>
</li>
<li><p><a href="https://github.com/GetPublii/Publii" target="_blank" rel="external">GetPublii/Publii</a> :  “Publii is a desktop-based CMS for Windows and Mac that makes creating static websites fast and hassle-free, even for beginners”, 好像是不过不错的 CMS 工具，先 mark，maybe 会用到</p>
</li>
<li><p><a href="https://github.com/niieani/bash-oo-framework" target="_blank" rel="external">bash-oo-framework</a> : “Bash Infinity is a modern boilerplate/framework/standard library for bash “, 一个基于 bash 的 lib 库, 但个人感觉方案有点重，最好有些轻量级的方案就好了~</p>
</li>
<li><p><a href="https://visca.com/regexdict/" target="_blank" rel="external">Regex Dictionary by Lou Hevly</a> : “The Regex Dictionary is a searchable online dictionary, based on The American Heritage Dictionary of the English Language, 4th edition, that returns matches based on strings”</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.linuxeden.com/a/34651&quot; target=&quot;_b
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>Noise Protocol简介</title>
    <link href="http://shevacjs.com/2018/08/20/introduction_of_the_noise_protocol_framework/"/>
    <id>http://shevacjs.com/2018/08/20/introduction_of_the_noise_protocol_framework/</id>
    <published>2018-08-20T12:20:45.000Z</published>
    <updated>2018-08-21T12:30:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近在研究 VPN 相关的技术，会做个简单的总结，稍微系统地去介绍安全协议及其系统</p>
</blockquote>
<h2 id="0x00-何为Noise-Protocol"><a href="#0x00-何为Noise-Protocol" class="headerlink" title="0x00 何为Noise Protocol"></a>0x00 何为Noise Protocol</h2><p>从<a href="http://noiseprotocol.org/index.html" target="_blank" rel="external">官网</a>的概述，其定义为:</p>
<blockquote>
<p>Noise is a framework for building crypto protocols. Noise protocols support mutual and optional authentication, identity hiding, forward secrecy, zero round-trip encryption, and other advanced features.</p>
</blockquote>
<p>太过含糊，仅仅强调其功能特性; 不过从作者在<a href="https://fahrplan.events.ccc.de/congress/2017/Fahrplan/events/9222.html" target="_blank" rel="external">Schedule 34th Chaos Communication Congress</a>的介绍，更具象一些，说明如下:</p>
<blockquote>
<p>Noise is a framework that helps in creating secure channel protocols</p>
</blockquote>
<p>所谓的<code>secure channel</code>，就是安全通道，比如<code>TLS</code>, <code>IPsec</code>, <code>SSH</code>都是; 也就是<code>noise protocol</code>就是用于快速方便去构建安全信道的一个框架。</p>
<h2 id="0x01-WHY"><a href="#0x01-WHY" class="headerlink" title="0x01 WHY"></a>0x01 WHY</h2><p>一个自然而然的问题是，为什么需要这样的框架? 我个人的理解包括:</p>
<ul>
<li><p>从安全的角度来看，虽然我们拥有很多基础的密码原语支持，比如公钥体系，签名体系，对称加密，HASH 等, 但是在业务落地的时候这些东西如何组合也是个问题和风险点。如果组织不合理，非常有可能造成进一步的安全漏洞。基于此，形式化和清晰化的去描述和定义一个”安全协议”, 可以从更系统的层面去分析其安全问题，更全面的评估其可靠性，也避免了一些『自定义』方式带来的安全漏洞。 这个方面其实有点像我们开放我们的『加密算法』，可以让第三方去审计/评估，但是不影响加密算法的可用性。<code>noise protocol</code>同样也是，其明确定义了不同模式的交互方式和协议，我们可以更清晰的审计其健壮性</p>
</li>
<li><p>从应用角度而言, two-parties的安全信道构建一直是有强烈诉求的, 但是不同的业务场景对于安全的要求也不尽相同，比如是否需要验证身份等, 所以去构建一个『框架』，让用户可以根据自己的业务场景方便构建自己安全信道的构建方式，是能满足更广大用户</p>
</li>
</ul>
<h2 id="0x02-Noise-的抽象和规范"><a href="#0x02-Noise-的抽象和规范" class="headerlink" title="0x02 Noise 的抽象和规范"></a>0x02 Noise 的抽象和规范</h2><p>介绍完了 Noise 的简单背景之后，我们来分析 Noise 是如何去解决这个问题的。</p>
<h3 id="2-1-抽象"><a href="#2-1-抽象" class="headerlink" title="2.1 抽象"></a>2.1 抽象</h3><blockquote>
<p>如下分析来自[1]的 PPT</p>
</blockquote>
<p>一个安全信道的构建，可以划分为如下几个阶段 :</p>
<ol>
<li><p>握手(Handshake)阶段，这阶段主要用于协议的协商和AKE(Authenticated Key Exchange) 相关事宜的完成，即包括:</p>
<ul>
<li>Negotiation : 协议协商等</li>
<li>AKE : 身份验证&amp;密钥交换</li>
</ul>
</li>
<li><p>数据传输(Transport phase)阶段，根据握手阶段生成的对称密钥，加密传输相关数据</p>
</li>
</ol>
<p>如下图所示 :</p>
<p><img src="/images/secure_channel.jpeg" alt="Secure Channel"></p>
<p>但是从实践应用的角度，为了保障安全性(比如考虑前置安全性), 我们会根据情况，重新协商密钥(AKE),  所以整个交互过程，会变成如下模式:</p>
<blockquote>
<p> [01] <em> Negotiation  + N </em> (AKE + n * transport )</p>
</blockquote>
<p>意味着:</p>
<ol>
<li>一般就需要一次协商阶段/或者不需要</li>
<li>会有多次(AKE + trans)阶段，来保障传输的安全性</li>
</ol>
<p>而<code>Noise protocol</code>就是更关注后者的实现, 如下:</p>
<p><img src="/images/secure_channel_noise.jpeg" alt="secure_channel_of_noise"></p>
<p>如此一来，一个包含<code>Noise Protocol</code>的应用，其安全信道的组织方式大概如下:</p>
<p><img src="/images/noise_framework_overview.jpeg" alt="noise_framework_overview"></p>
<p>这个也是<a href="https://www.wireguard.com/" target="_blank" rel="external">Wireguard</a>的组织方式，后续的文章会再详细介绍</p>
<h3 id="2-2-规范"><a href="#2-2-规范" class="headerlink" title="2.2 规范"></a>2.2 规范</h3><p>有了上面的抽象之后，在具体实现上面, Noise 也做了相关的规范和约定；主要包括两个方面，其一是<code>模式</code>的约定，这里面主要说明了根据不同的业务场景(比如是否需要身份验证等)，如何进行握手协议; 其二是<code>密码算法</code>的约定，主要约定了交互时候具体选择的密码协议等</p>
<h4 id="2-2-1-模式约定"><a href="#2-2-1-模式约定" class="headerlink" title="2.2.1 模式约定"></a>2.2.1 模式约定</h4><blockquote>
<p>重点关注基础(fundamental),交互式(Interactive)的沟通模式</p>
</blockquote>
<p>在一个交互式的场景下，比如Alice和Bob，我们假设他们需要完成握手协议，以便后续的数据传输。一个问题是，Alice 和 Bob 有多少种握手沟通方式? 这里, 我们其用两个字母表示，分别表示发送者(Alice)和 Bob(响应者)对于对方<code>static key</code>的诉求情况 :</p>
<p>对于Alice(请求初始化者)有如下四个情况 :</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>spec说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N</strong></td>
<td>No static key for initiator</td>
<td>无需发送者的静态key(对发送者不进行身份验证)</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>Static key for initiator Known to responder</td>
<td>已知(通过其他旁路方式)发送者的静态key, 可以进行身份验证</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Static key for initiator Xmitted (“transmitted”) to responder</td>
<td>通过握手传输交互发送者的静态key</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>Static key for initiator Immediately transmitted to responder, despite reduced or absent identity hiding</td>
<td>通过握手传输，且离开发送静态 key, 这可能使其身份更容易暴露</td>
</tr>
</tbody>
</table>
<p>对于Bob(请求响应者)有如下三个情况:</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>spec说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N</strong></td>
<td>No static key for responder</td>
<td>无需响应者的静态key</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>Static key for responder Known to initiator</td>
<td>已知响应者的静态key</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>Static key for responder Xmitted (“transmitted”) to initiator</td>
<td>通过握手传输交互静态key</td>
</tr>
</tbody>
</table>
<p>基于如上的自由组合，一共会有12种不同的模式; 再加上如下的规则 :</p>
<blockquote>
<p>The fundamental handshake patterns perform DH operations for authentication (“es” and “se”) as early as possible</p>
</blockquote>
<p>给定任意<code>XY</code>, 原则上面，我们都能推导其交互过程，比如<code>XX</code>，其具体如下:</p>
<table>
<thead>
<tr>
<th>A status</th>
<th></th>
<th>B status</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>s(x),e(x),rs(x),re(x)</td>
<td></td>
<td>s(x),e(x),rs(x),re(x)</td>
<td>初始状态</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td>–&gt; e</td>
<td>s(x),e(x),rs(x),re(x)</td>
<td>生成e, 发送</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td></td>
<td>s(y),e(y),rs(x),re(y)</td>
<td>B 知道e,s,re，起可以发送的 DH 有ee, es</td>
</tr>
<tr>
<td>s(x),e(y),rs(x),re(x)</td>
<td>&lt;–e,ee,s,es</td>
<td>s(y),e(y),rs(x),re(y)</td>
</tr>
<tr>
<td>s(y),e(y),rs(y),re(y)</td>
<td></td>
<td>s(y),e(y),rs(x),re(y)</td>
<td>发送 A.s, 其可以DH 有se,ss</td>
</tr>
<tr>
<td>s(y),e(y),rs(y),re(y)</td>
<td>–&gt; s,se</td>
<td>s(y),e(y),rs(y),re(y) </td>
</tr>
</tbody>
</table>
<h4 id="2-2-2-基础算法约定"><a href="#2-2-2-基础算法约定" class="headerlink" title="2.2.2 基础算法约定"></a>2.2.2 基础算法约定</h4><p>我们知道，密码学虽然定义了其有限的基本的『能力原语』，但是实现上面却各不相同，纷繁杂乱；一个 hash 方法，就有大几十种选择，不同的实现可能存在着或多或少的安全风险。为此，Noise框架直接规范了其依赖的函数的具体算法，对于这些规范内的函数，其安全性和可控性是经过严格审计的，具体如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>可选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>密钥交互</td>
<td>DH25519</td>
<td>DHLEN = 32</td>
</tr>
<tr>
<td>密钥交互</td>
<td>DH448</td>
<td>DHLEN = 56</td>
</tr>
<tr>
<td>加密函数</td>
<td>ChaChaPoly</td>
<td>16 byte authentication data</td>
</tr>
<tr>
<td>加密函数</td>
<td>AESGCM</td>
<td>16 byte authentication data</td>
</tr>
<tr>
<td>哈希函数</td>
<td>SHA256</td>
<td>HASHLEN = 32, BLOCKLEN = 64 </td>
</tr>
<tr>
<td>哈希函数</td>
<td>SHA512</td>
<td>HASHLEN = 64, BLOCKLEN = 128</td>
</tr>
<tr>
<td>哈希函数</td>
<td>BLAKE2s</td>
<td>HASHLEN = 32, BLOCKLEN = 64</td>
</tr>
<tr>
<td>哈希函数</td>
<td>BLAKE2b</td>
<td>HASHLEN = 64, BLOCKLEN = 128</td>
</tr>
</tbody>
</table>
<p>如上，我们就可以约定<code>Noise Protocol Name</code>, 也可以通过其名字可以知道其协议过程，比如从<code>Noise_NX_25519_AESGCM_SHA256</code>, 可以得到:</p>
<ul>
<li>NX = Pattern name</li>
<li>25519 = DH name</li>
<li>AESGCM = Cipher name</li>
<li>SHA256 = Hash name</li>
</ul>
<p>同时根据具体选择的算法，我们还可以估算一个Noise Protocol 交互时候其数据包的大小, 比如<code>Noise_XX_25519_ChaChaPoly_SHA256</code>模式，其不同的数据包大小如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">XX:</div><div class="line">  -&gt; e                  <span class="comment">## 1</span></div><div class="line">  &lt;- e, ee, s, es       <span class="comment">## 2</span></div><div class="line">  -&gt; s, se              <span class="comment">## 3</span></div><div class="line"></div><div class="line"><span class="comment"># 说明:</span></div><div class="line"><span class="comment">## 1. DH_25519的公钥为32字节,明文, 总长度为32</span></div><div class="line"><span class="comment">## 2. e为32字节, s为48字节(AEAD模式会增加16字节)，payload(为空)加密后再增加16字节, 一共96字节</span></div><div class="line"><span class="comment">## 3. s加密后为48字节，加上payload为空的加密串,一共64字节</span></div></pre></td></tr></table></figure>
<h2 id="0x03-Noise-Protocol-实践分析"><a href="#0x03-Noise-Protocol-实践分析" class="headerlink" title="0x03 Noise Protocol 实践分析"></a>0x03 Noise Protocol 实践分析</h2><p>为了助于我们对noise protocol加密协议有进一步的理解,对于给定的一个<code>Noise Protocol Name</code>, 我们要分析其包体格式, 比如上面的<code>Noise_XX_25519_ChaChaPoly_SHA256</code>, 其交互流程如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">XX:</div><div class="line">  -&gt; e</div><div class="line">  &lt;- e, ee, s, es</div><div class="line">  -&gt; s, se</div></pre></td></tr></table></figure>
<p>那么在每个阶段，其具体发送的内容是什么呢？</p>
<p>其实在实现的时候, 发送方都维护了一个类似于状态机的内容，而<code>e</code>,<code>s</code>,<code>ee</code>之类的，则类似于<code>action</code>, 用于更新相关状态的内容；所以包的格式其实可以理解为就是对于<code>action</code>的一系列响应的结果；下面具体说明下:</p>
<h4 id="首先是基础函数方面-有如下几个能力"><a href="#首先是基础函数方面-有如下几个能力" class="headerlink" title="首先是基础函数方面, 有如下几个能力 :"></a>首先是基础函数方面, 有如下几个能力 :</h4><ul>
<li>$DH(ee|es|se|ss)$ : 用于计算一个共享密钥, 例子用到的是<code>DH25519</code></li>
<li>$hash(data)$ : 用于计算一个哈希值, 我们这边用的是<code>SHA256</code></li>
<li>$encrypt(k,h,data)$ : AEAD 模式的加密函数</li>
<li>$HKDF(ck,data)$ : KDF 函数，用于生成新的key chain</li>
</ul>
<h4 id="其次是状态机方面，对于-Alice-Bob，其本地都维护了如下的信息"><a href="#其次是状态机方面，对于-Alice-Bob，其本地都维护了如下的信息" class="headerlink" title="其次是状态机方面，对于 Alice/Bob，其本地都维护了如下的信息:"></a>其次是状态机方面，对于 Alice/Bob，其本地都维护了如下的信息:</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s,e</td>
<td>本地的临时/静态 DH组合对</td>
</tr>
<tr>
<td>rs,re</td>
<td>对方的临时/静态的 DH 组合对</td>
</tr>
<tr>
<td>h</td>
<td>当前的 hash 值，初始为空</td>
</tr>
<tr>
<td>ck</td>
<td>chain key, 初始为空，用于通过 KDF 生成新key</td>
</tr>
<tr>
<td>k, n</td>
<td>加密k, 加密时候会通过(k,n,hash) 和 AEAD 模式进行对称加密</td>
</tr>
<tr>
<td>msg</td>
<td>当前要发送的消息内容</td>
</tr>
<tr>
<td>payload</td>
<td>当前要携带的额外数据</td>
</tr>
</tbody>
</table>
<h4 id="最后是-action-方面-对于不同的-action，其定义如下"><a href="#最后是-action-方面-对于不同的-action，其定义如下" class="headerlink" title="最后是 action 方面, 对于不同的 action，其定义如下:"></a>最后是 action 方面, 对于不同的 action，其定义如下:</h4><ul>
<li><p>action e :</p>
<ul>
<li>$msg += e$</li>
<li>$h = hash(h||e)$</li>
</ul>
</li>
<li><p>action s :</p>
<ul>
<li>$s = k.empty() ? s : encrypt(s,k,h)$</li>
<li>$msg+=s$</li>
<li>$h = hash(h||s)$</li>
</ul>
</li>
<li><p>action ee/es/ss/se :</p>
<ul>
<li>$v = DH(ee|es|se|ss)$</li>
<li>$ck,k = HKDF(ck,v)$</li>
<li>$n = 0$</li>
</ul>
</li>
<li><p>action token end(全部处理完 token) :</p>
<ul>
<li>$payload = encrypt(payload,k,h) (if k!=0 )$</li>
</ul>
</li>
</ul>
<p>最后发送<code>msg+payload</code></p>
<p>有了如上的说明，我们再详细看看<code>Noise_XX_25519_ChaChaPoly_SHA256</code>的交互情况 :</p>
<ol>
<li><code>--&gt;e</code> : 按照上面的分析, 会发送明文的<code>e</code>, 同时由于其不生成k, 因为也不会额外计算payload, 其发送包体只有<code>32字节</code></li>
</ol>
<ol>
<li><code>&lt;--e,ee,s,es</code> : 其有4个 token，拆分分析, 如下表格:</li>
</ol>
<table>
<thead>
<tr>
<th>action</th>
<th>msg</th>
<th>h</th>
<th>k</th>
<th>ck</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>e</td>
<td>h1=hash(e)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>ee</td>
<td>e</td>
<td>h1</td>
<td>k1</td>
<td>ck1,k1 = HKDF(ck,ee)</td>
</tr>
<tr>
<td>s</td>
<td>e,enc(s)</td>
<td>h2=hash(h1+enc(s))</td>
<td>k1</td>
<td>ck1</td>
</tr>
<tr>
<td>es</td>
<td>e,enc(s)</td>
<td>h2</td>
<td>k2</td>
<td>ck2,k2=HKDF(ck1,es)</td>
</tr>
<tr>
<td>end</td>
<td>e,enc(s),enc(null)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>具体格式如下:</p>
<p><img src="/images/noise_xx_demo.jpeg" alt="noise_xx_demo"></p>
<p>最后一个命令同理，不再赘述；</p>
<p>基于上面的分析，详细大家可以直接计算<code>msg</code>的包体大小，也就是上一节里面展示的; </p>
<p>如下是<code>Wireshark</code>抓包的示意图:</p>
<p><img src="/images/noise_wireshark_demo.png" alt="noise_wireshark_demo"></p>
<p>具体实现代码方面，可以参考<a href="https://github.com/plizonczyk/noiseprotocol" target="_blank" rel="external">noiseprotocol:Noise Protocol Framework - Python 3 implementation
</a></p>
<p>可以参看其<code>README</code>里面关于server/client的编写，实现一个快速简单的原型;</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><p>[1] <a href="https://fahrplan.events.ccc.de/congress/2017/Fahrplan/events/9222.html" target="_blank" rel="external">Lecture: The Noise Protocol Framework</a> @ Schedule 34th Chaos Communication Congress</p>
</li>
<li><p>[2] <a href="http://noiseprotocol.org/noise.html" target="_blank" rel="external">The Noise Protocol Framework</a> : White Paper</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在研究 VPN 相关的技术，会做个简单的总结，稍微系统地去介绍安全协议及其系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x00-何为Noise-Protocol&quot;&gt;&lt;a href=&quot;#0x00-何为Noise-Protocol&quot; 
    
    </summary>
    
    
      <category term="cryptography, noise, vpn" scheme="http://shevacjs.com/tags/cryptography-noise-vpn/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180805</title>
    <link href="http://shevacjs.com/2018/08/06/20180805/"/>
    <id>http://shevacjs.com/2018/08/06/20180805/</id>
    <published>2018-08-06T09:19:45.000Z</published>
    <updated>2018-08-06T09:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/P_np_np-complete_np-hard.svg.png" alt="wiki:p_np_npc_problem"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://www.idontplaydarts.com/2016/04/detecting-curl-pipe-bash-server-side/" target="_blank" rel="external">Detecting the use of “curl | bash” server side</a> :  直接执行<code>curl | bash</code>的命令是存在比较大的安全风险的，因为可能执行一些未经确认的恶意代码;  那有没有办法可以去构造这种攻击吗？也就是对于普通的浏览器访问或者命令行下面直接的 curl 输出，我们返回正常的内容，但是如果是执行了<code>curl | bash</code>我们就返回还有恶意代码的内容呢？作者的回答是肯定的，其主要的思路是在返回内部的时候，初步先通过 chunk 机制返回带有<code>sleep 5</code>之类的能够检测时间/bash 的监测代码，在通过在服务端对于响应时间进行判断，就能知道我们输出的内容是否运行在 bash 环境下面（会不会感觉其实和检测一个代码是否跑在一个 JS 环境下面一样？）；当然实现上面还有不少细节，比如说对于发送/接受/pipe 的 buffer 等控制和填充~</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/" target="_blank" rel="external">Modern SAT solvers: fast, neat and underused (part 1 of N) — The Coding Nest</a> : 本文的<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" target="_blank" rel="external">SAT</a>是指<code>Boolean satisfiability problem</code>, 其实也就是个<code>NP完全问题</code>(NP-complete)。虽然是NP 问题，但是也有不少的 Lib 库存在，用于去解决这方面的问题，比如说文章提到的<a href="http://minisat.se/" target="_blank" rel="external">Minisat</a>,<a href="http://dimacs.rutgers.edu/" target="_blank" rel="external">DIMACS</a>等; 从计算复杂性的理论，我们知道<code>NPC</code> 的问题是可以相互规约的，利用这个规则和现有的 Lib，我们可以认为，对于现实中存在的真正的 NP 问题，只要建立好正确对应的数学模型，将其规约到一个 NPC 问题，就能用这些基础库解决此类问题了。本文作者举了一个具体<code>数独问题</code>的例子，并演绎如何将其规约到基础的 NPC 问题，最终求解这类问题。对于，我们可以对计算复杂性的理论有进一步的了解和认识，也可以将其应用到其他的问题解决领域。先 mark 下，周末手动测试这些代码。如下的几个相关的参考资料，有助于了解整体文章:</p>
<ul>
<li><a href="http://www.matrix67.com/blog/archives/105" target="_blank" rel="external">什么是P问题、NP问题和NPC问题</a> </li>
<li><a href="http://zhishifenzi.blog.caixin.com/archives/167252" target="_blank" rel="external">最新证明面临质疑：P/NP问题为什么这么难？</a></li>
<li><a href="https://en.wikipedia.org/wiki/NP_(complexity" target="_blank" rel="external">Wikipedia: NP (complexity)</a>)</li>
</ul>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/b80Efqsh85vqaWvuB8lUcg" target="_blank" rel="external">Kafka 2.0重磅发布，新特性独家解读</a> : Kafka顺应了现在这个时代对于数据的规模化和流式化处理的需求，本身是发展也是非常迅猛；Maybe 可以其作为自己第二个侧重投入的重点工具链</p>
</li>
<li><p><a href="https://blog.cloudflare.com/how-we-scaled-nginx-and-saved-the-world-54-years-every-day/" target="_blank" rel="external">How we scaled nginx and saved the world 54 years every day</a> : 本文介绍了CloudFlare在 Nginx 部署和运维上面的一些先进经验，不少都是 Nginx 的性能深入优化点，比如<code>SO_REUSEPORT</code>, <code>read thread pool</code>, 算是真正有在规模化应用这些特性的大团队，经验等值得参考和采纳</p>
</li>
<li><p><a href="http://dockone.io/article/8106" target="_blank" rel="external">小米DevOps团队针对容器的Nginx优化</a> : 主要谈到容器化的时候，通过<code>worker_processes auto</code>的指令，并不能很好的控制 nginx 的进程数，基于此，可以通过旁路的脚本或者程序的升级来支持读取争取分配给他的CPU 线程数。其实，个人感觉，CPU 的限制是软限制，通过控制进程数并不合理，但是其深入分析问题的思路和精神值得佩服~ </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周主要关注P2P下载相关的技术</p>
</blockquote>
<ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5" target="_blank" rel="external">磁力链接: 维基百科</a> :  对于磁力链接的概括性介绍, 本质上其是对一个种子文件的<code>URN</code></p>
</li>
<li><p><a href="http://blog.kakarott.net/archives/10017" target="_blank" rel="external">P2P技术科普（一）——-P2P基本原理</a> : 对 P2P 网络的发展以及技术演变有概括性，精要的说明，可以关注了解</p>
</li>
<li><p><a href="http://www.aneasystone.com/archives/2015/05/how-does-magnet-link-work.html" target="_blank" rel="external">磁力链接是如何实现下载的</a> : 具体介绍磁力链接的执行机制, 推荐<a href="http://magnet2torrent.com/" target="_blank" rel="external">Magnet &gt;&gt; Torrent</a>, 其可以帮忙我们将磁力链接转成 torrent 文件</p>
</li>
<li><p><a href="http://www.bittorrent.org/beps/bep_0005.html" target="_blank" rel="external">BitTorrent: DHT</a> : 介绍BitTorrent的 DHT 网络的设计思路和理念，可以加上对 P2P 网络的理解</p>
</li>
<li><p><a href="https://my.oschina.net/kanlianhui/blog/167491" target="_blank" rel="external">P2P中DHT网络原理</a> : 另外一个科普文章，可以了解</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://www.intel.cn/content/www/cn/zh/events/restoring-great-wall/preserve-great-wall-techarticle.html" target="_blank" rel="external">英特尔修复长城计划 (技术角度)</a> : 有点半软文性质的文章，主要想说明的一点是，AI 赋能的确在影响我们很多时刻解决问题的思路和理念，而这些方面又依赖于每个人的视野和判断力。</p>
</li>
<li><p><a href="https://github.com/arnoldrobbins/mcilroy-regex" target="_blank" rel="external">arnoldrobbins/mcilroy-regex: Doug McIlroy’s C++ regular expression matching library</a> : 一个 C++的正则库，先 mark，历史好像很是悠久</p>
</li>
<li><p><a href="https://www.quickcode.co/engineer-blogs" target="_blank" rel="external">Engineering Blogs</a> : “A Collection of engineering blogs from top tech companies in the world”</p>
</li>
<li><p><a href="https://ricardodsanchez.com/2018/08/03/favorite-visual-studio-code-extensions-of-2018/2018/" target="_blank" rel="external">Favorite Visual Studio Code Extensions of 2018 | Ricardo D Sanchez | Page 2018</a> : 不少插件可以关注，包括<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="external">REST Client</a>, <a href="https://marketplace.visualstudio.com/items?itemName=sdras.night-owl" target="_blank" rel="external">Night Owl</a> 等</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/P_np_np-complete_np-hard.svg.png&quot; alt=&quot;wiki:p_np_npc_problem&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180722</title>
    <link href="http://shevacjs.com/2018/07/30/20180722/"/>
    <id>http://shevacjs.com/2018/07/30/20180722/</id>
    <published>2018-07-30T03:40:45.000Z</published>
    <updated>2018-07-30T03:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488140&amp;idx=1&amp;sn=a4397201d781386f854242d0ff5d2be8" target="_blank" rel="external">Facebook使用机器学习手段来自动优化其系统性能</a> : 没有完全理解文章的内容，现在的理解是，通过声明式的方式描述程序的逻辑，同时基于此，通过输入日志和反馈，调整程序的策略，进而优化整体的性能; 总感觉有点理想化~</li>
</ul>
<ul>
<li><p><a href="https://www.oschina.net/news/98255/facebook-open-source-oomd" target="_blank" rel="external">Facebook 开源 oomd，一种处理内存溢出的新方法</a> : <code>OOMD</code>也是一个<code>OOM</code>的处理工具，但是和传统的<code>OOM</code>工具不一样，其更会侧重优化和清理用户空间的内存，这样会保障整个内核和系统的相对稳健</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNzU3NzQ0MA==&amp;mid=2652089442&amp;idx=1&amp;sn=69bae21c50c779b8c0b995bd0c654e57&amp;chksm=809b066db7ec8f7b275b8a6f1ef792aace8a920c6c87dfe30fa401add813caa84929e4f420e0#rd" target="_blank" rel="external">大话计算机: 趣味了解浮点数</a> :  关于计算机浮点数机制的介绍，这本书的内容看目录还是非常不多的，先收藏mark</p>
</li>
<li><p><a href="https://emerentius.github.io/sudoku_web/" target="_blank" rel="external">Rust Sudoku Solver</a> : 作者用rust编写了一个Sudoku的解法器, 对于sudo的解决算法还是可以深入研究分析的, 先mark下，可以参考<a href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms" target="_blank" rel="external">Sudoku solving algorithms</a>, <a href="https://attractivechaos.wordpress.com/2011/06/19/an-incomplete-review-of-sudoku-solver-implementations/" target="_blank" rel="external">An Incomplete Review of Sudoku Solver Implementations</a></p>
</li>
<li><p><a href="http://tonsky.me/blog/dsl/" target="_blank" rel="external">Designing good DSL @ tonsky.me</a> : 设计新的<code>DSL</code>是我们解决一些复杂问题或者场景的一个有效方法，作者提出了真正要设计<code>DSL</code>的时候需要的一些注意点，包括<code>Make it verbose(不用用正则的奇怪的不容易理解的语法)</code>, <code>Don’t invent second syntax</code>等，不少意见值得采纳深思</p>
</li>
<li><p><a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端图片格式调研 | Garan no dou</a> : 对于图片格式，以及其编解码速度的问题有一个非常系统的分析和对比，感觉可以关注的图片格式包括<code>APNG</code>,<code>BPG</code>, 但是直观上面感觉这两年发展不算快(2015年的文章)</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="http://www.techug.com/post/meitun-deep-learning.html" target="_blank" rel="external">美团是如何基于深度学习实现图像的智能审核</a> : 两个值得关注的，一个是其审核的流程, 为”负例图片-&gt;正例图片-&gt;人审”, 这样可以保障业务迭代或者新增图片类型时，系统的健壮性；其次是其对于<code>水印检测</code>, <code>明星脸识别</code>, <code>色情图片检测</code>的策略优化，这个方面也有不少可借鉴的地方</p>
</li>
<li><p><a href="https://code.fb.com/data-infrastructure/xars-a-more-efficient-open-source-system-for-self-contained-executables/" target="_blank" rel="external">XARs: An efficient system for self-contained executables – Facebook Code</a> : </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://zkp.science/" target="_blank" rel="external">What is a zero-knowledge proof? | Zero-Knowledge Proofs</a> : Mark, 关于<code>零和知识</code>的集中资料，先mark，找个周末再完整消化下</p>
</li>
<li><p><a href="https://github.com/hq6/GdbShellPipe" target="_blank" rel="external">GdbShellPipe: Enable piping of internal command output to external commands</a> : 一个 GDB的扩展，允许在 GDB 里面执行 shell 的命令, 比如说<code>shell-pipe disas | grep mov</code>可以检索出<code>disas</code>里面含有<code>mov</code>命令的语句</p>
</li>
<li><p><a href="https://stenci.la/" target="_blank" rel="external">Stencila</a>: “An open source office suite for reproducible research”, mark</p>
</li>
<li><p><a href="https://www.univocity.com/pages/html_parser_tutorial" target="_blank" rel="external">HTML parser : uniVocity data integration</a> : 一个开源的Java HTML解析器, 具有声明式语法, 自动内容下载的特性, mark关注了解下</p>
</li>
<li><p><a href="http://www.darkside.com.au/snow/" target="_blank" rel="external">The SNOW Home Page</a> : <code>SNOW</code>是一个通过增加在一些行末尾添加空格内容，以支持信息隐藏的一个手段, 甚至可以通过引入加密算法进行加密，使得即便此规则被泄露，依旧能进行信息隐藏和保护，其最后还有一个在线的<a href="http://fog.misty.com/perry/ccs/snow/snow/snow.html" target="_blank" rel="external">WEB DEMO</a>, 有兴趣可以试用下</p>
</li>
<li><p><a href="https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/" target="_blank" rel="external">An Illustrated Proof of the CAP Theorem</a> : 关于<code>CAP</code>原理的一个比较好的可视化演示和证明，可以关注下</p>
</li>
<li><p><a href="https://john-millikin.com/software/anansi" target="_blank" rel="external">Anansi: a NoWeb-inspired literate programming preprocessor</a> : Anansi是所谓的<code>文学编程</code>模式的预处理起，所谓<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E5%AD%A6%E7%BC%96%E7%A8%8B" target="_blank" rel="external">文学编程</a>是相比于传统结构化编程的模式, 其可以让程序员在描述/书写文档的过程中完成对应的编码和文档说明(个人感觉这个模式效率其实是蛮低的)</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488196&amp;idx=1&amp;sn=c5b243b9dc7bd7b3d44aab83aba820a7" target="_blank" rel="external">作为面试官，我是怎么快速判断程序员能力的？</a> : 对于如何做一个成功的面试的一些建议，还是非常接地气的；从我个人角度来看，『面试』这个事情，其实还是在于面试官对待面试的态度和准备，只有充分准备才能起到真正面试和完成合理判断</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180708</title>
    <link href="http://shevacjs.com/2018/07/30/20180708/"/>
    <id>http://shevacjs.com/2018/07/30/20180708/</id>
    <published>2018-07-30T03:35:45.000Z</published>
    <updated>2018-07-30T03:41:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://arvid.io/2018/05/05/pdbs-on-linux/" target="_blank" rel="external">PDBs on Linux</a> : PDB是windows下面的符号文件，其可以和bin文件拆分，某些时候会便于调试；默认情况下, linux的ELF的文件其调试信息的耦合在bin里面的，作者给出了自己的办法，具体为(可以收藏):</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ objcopy --only-keep-debug a.out a.out.pdb <span class="comment"># extract symbols</span></div><div class="line">$ strip a.out <span class="comment"># strip away any debug information</span></div><div class="line">$ objcopy --add-gnu-debuglink=a.out.pdb a.out <span class="comment"># attach the symbols to the executable</span></div></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://arvid.io/2018/06/30/on-cxx-random-number-generator-quality/" target="_blank" rel="external">On C++ Random Number Generator Quality</a> : 文章评估了C++lib下面随机数生成器的质量, 总结而已就是使用<a href="https://arvid.io/2018/06/30/on-cxx-random-number-generator-quality/" target="_blank" rel="external">PractRand</a>的方法评估, 可以持续关注; 另外推进作者的几篇不错的blog，包括<a href="https://arvid.io/2018/05/27/intel-microarchitectures-instruction-sets/" target="_blank" rel="external">Intel &amp; AMD Micro-Architecture Extended Instruction Sets</a>, <a href="https://arvid.io/2018/07/02/better-cxx-prng/" target="_blank" rel="external">Better C++ Pseudo Random Number Generator</a></p>
</li>
<li><p><a href="https://nullprogram.com/blog/2018/06/23/" target="_blank" rel="external">Intercepting and Emulating Linux System Calls with Ptrace « null program</a> : 深入ptrace的应用，其可以作为一个仿真器, 比如调用自定义的system call, 或者我们可以让其调用我们预定义的ABI</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491177&amp;idx=1&amp;sn=756699190c00c5bc11113819bb57dec3" target="_blank" rel="external">谨防5个陷阱！数据科学家新手快速上道秘诀</a> : 最近<code>AI前线</code>给了不少实践落地的一些建议，这篇文章也是，有不少干货可以学习，具体包括:<ul>
<li>练习数据管理技能</li>
<li>研究不同模型的优缺点</li>
<li>尽可能简化模型</li>
<li>检查你结论中的因果关系和相关性</li>
<li>优化最有用的参数</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247488099&amp;idx=1&amp;sn=4b7ab3e5fd87d036e1deab2b1c0c9ecf" target="_blank" rel="external">Istio以及Service Mesh的未来</a> : 文章介绍<code>Istio</code>的简单机制，包括几个核心的组件:<code>Envoy</code>, <code>Pilot</code>,<code>Mixer</code>等，以及总结出来的其带来<code>灵活性</code>, <code>安全性</code>, <code>可观测性</code>等优点</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s/473mATiM1xnLUFKMD2FnnQ" target="_blank" rel="external">区块链的信任从何而来？</a> :  总而言之，就是用技术的手段，构建了一个大家认为『无法轻易作伪』的分布式存储系统，基于次可以构建更多的应用和业务</p>
</li>
<li><p><a href="https://www.theverge.com/2018/7/9/17549668/app-wikipedia-location-facts" target="_blank" rel="external">This app reads Wikipedia to teach you about the cities you’re driving through</a> : 作者开发了一个App，其可以通过地理位置信息，自动抓取Wikipedia上面的文章，推荐给用户(感觉是一个不错的产品玩法)</p>
</li>
<li><p><a href="https://github.com/rhysd/vim.wasm" target="_blank" rel="external">rhysd/vim.wasm: Vim editor ported to WebAssembly</a> : 将vim迁移到浏览器, 由于vim本身有不少UI交互上面的操作，因此直接编译源码到WASM并不可行，作者在blog里面也介绍了其思路, 通过disable适当的功能和构建合适的运行环境，值得学习</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491444&amp;idx=1&amp;sn=47aa445f49de52316beaec40a776dbc7" target="_blank" rel="external">Hadoop老矣，为什么腾讯还要花精力在其开源发布上</a> : 可以理解为是对现在大数据生态现状的概述</p>
</li>
<li><p><a href="https://blog.acolyer.org/2018/07/05/enclavedb-a-secure-database-using-sgx/" target="_blank" rel="external">EnclaveDB: a secure database using SGX | the morning paper</a> : </p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arvid.io/2018/05/05/pdbs-on-linux/&quot; tar
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>nginx 1.15.2 版本说明</title>
    <link href="http://shevacjs.com/2018/07/26/nginx_1_15_2/"/>
    <id>http://shevacjs.com/2018/07/26/nginx_1_15_2/</id>
    <published>2018-07-26T08:15:29.000Z</published>
    <updated>2018-07-26T08:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-Feature-List"><a href="#0x00-Feature-List" class="headerlink" title="0x00 Feature List"></a>0x00 Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: the $ssl_preread_protocol variable in the ngx_stream_ssl_preread_module.</p>
</li>
<li><p>Feature: now when using the “reset_timedout_connection” directive nginx will reset connections being closed with the 444 code.</p>
</li>
</ul>
<p>这里我们重点关注第二个特性(第一个特性，后续我们专门写篇介绍Nginx和SSL应用的文章再具体分析)</p>
<h2 id="0x01-Reset-Timeoutd-Connection"><a href="#0x01-Reset-Timeoutd-Connection" class="headerlink" title="0x01 Reset Timeoutd Connection"></a>0x01 Reset Timeoutd Connection</h2><p>第二个机制可以直译说明如下:</p>
<blockquote>
<p>如果开启<code>reset_timedout_connection</code>配置后，Ngnix接收<code>HTTP 444</code>状态码后，会重置对应的连接</p>
</blockquote>
<p>可以简单拆解为如下三个问题讨论:</p>
<ul>
<li>HTTP 444状态码的作用和目的</li>
<li>指令<code>reset_timedout_connection</code>的机制和作用</li>
<li>整体这个feature的作用</li>
</ul>
<h3 id="1-1-HTTP-444状态码"><a href="#1-1-HTTP-444状态码" class="headerlink" title="1.1 HTTP 444状态码"></a>1.1 HTTP 444状态码</h3><p>其实<code>444</code>是Nginx内部的状态码,从<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#return" target="_blank" rel="external">nginx return</a>的指令，看到说明如下:</p>
<blockquote>
<p>…The non-standard code 444 closes a connection without sending a response header …</p>
</blockquote>
<p>同时<a href="https://httpstatuses.com/444" target="_blank" rel="external">Http Status</a>网站也有详细说明, 如下: </p>
<blockquote>
<p>A non-standard status code used to instruct nginx to close the connection without sending a response to the client, most commonly used to deny malicious or malformed requests.</p>
</blockquote>
<p>这样就比较明确, HTTP 444是Nginx内部的状态码, 其主要是作用是告诉 nginx可以直接关闭对应的链接，无需发送响应头部。这可以有效处理恶意或者畸形的流量。</p>
<h3 id="1-2-reset-timedout-connection指令"><a href="#1-2-reset-timedout-connection指令" class="headerlink" title="1.2 reset_timedout_connection指令"></a>1.2 reset_timedout_connection指令</h3><p>该指令是由<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#reset_timedout_connection" target="_blank" rel="external">ngx_http_core_module</a>提供的，如下是官方的说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* Syntax:   reset_timedout_connection on | off;</div><div class="line">* Default:	reset_timedout_connection off;</div><div class="line">* Context:	http, server, location</div><div class="line"></div><div class="line">Enables or disables resetting timed out connections. The reset is performed as follows. Before closing a socket, the SO_LINGER option is set on it with a timeout value of 0. When the socket is closed, TCP RST is sent to the client, and all memory occupied by this socket is released. This helps avoid keeping an already closed socket with filled buffers in a FIN_WAIT1 state for a long time.</div></pre></td></tr></table></figure>
<p>简而言之, 当开启<code>reset_timedout_connection</code>后，Nginx 会通过设置<code>SO_LINGER</code>的选项快速关闭超时的连接, 其作用是保障系统和 Nginx 能够快速释放无用的连接的资源。 具体实现上面，就是通过控制<code>SO_LINGER</code>选项。</p>
<p>关于<a href="https://notes.shichao.io/unp/ch7/#so_linger-socket-option" target="_blank" rel="external">SO_LINGER</a>其作用，可以简述为是控制<code>close</code>的行为, 参考<a href="http://blog.51cto.com/xwandrew/2046615" target="_blank" rel="external">Linux Socket SO_LINGER选项
</a>(个人感觉解释的比较清晰明了)的说明，可以简述如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SO_LINGER选项有如下结构：</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></div><div class="line">     <span class="keyword">int</span> l_onoff; <span class="comment">/* 0 = off, nozero = on */</span></div><div class="line">     <span class="keyword">int</span> l_linger; <span class="comment">/* linger time */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当设置 l_onoff为1，l_linger为0，则连接立即终止，TCP将丢弃残留在发送缓冲区中的数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；在远端的recv()调用将以WSAECONNRESET出错。</p>
<p>这个也是Nginx的默认行为如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: ngx_http_request.c, 快速关闭请求</span></div><div class="line"><span class="keyword">if</span> (clcf-&gt;reset_timedout_connection) &#123;</div><div class="line">    linger.l_onoff = <span class="number">1</span>;</div><div class="line">    linger.l_linger = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (setsockopt(r-&gt;connection-&gt;fd, SOL_SOCKET, SO_LINGER,</div><div class="line">                    (<span class="keyword">const</span> <span class="keyword">void</span> *) &amp;linger, <span class="keyword">sizeof</span>(struct linger)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        ngx_log_error(NGX_LOG_ALERT, <span class="built_in">log</span>, ngx_socket_errno,</div><div class="line">                        <span class="string">"setsockopt(SO_LINGER) failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-3-整体-Feature-作用"><a href="#1-3-整体-Feature-作用" class="headerlink" title="1.3 整体 Feature 作用"></a>1.3 整体 Feature 作用</h3><p>如上，整体的作用其实就是让 Nginx <a href="http://mailman.nginx.org/pipermail/nginx-devel/2018-July/011271.html" target="_blank" rel="external">能够快速释放相关的资源</a>, 如下是前后的流程对比</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//before</span></div><div class="line">A  +---------&gt;  B +--------&gt;  C</div><div class="line"></div><div class="line">                  <span class="number">1.</span> <span class="keyword">return</span> <span class="number">444</span></div><div class="line">                &lt;-----------+</div><div class="line"></div><div class="line">     <span class="number">2.</span>normal close</div><div class="line">   &lt;------------+</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//now</span></div><div class="line">A  +---------&gt;  B +--------&gt;  C</div><div class="line"></div><div class="line"></div><div class="line">  <span class="number">2.</span> reset socket  <span class="number">1.</span> <span class="keyword">return</span> <span class="number">444</span></div><div class="line"> &lt;-----------+  &lt;-----------+</div></pre></td></tr></table></figure>
<h2 id="0x02-Nginx-模块的执行顺序"><a href="#0x02-Nginx-模块的执行顺序" class="headerlink" title="0x02 Nginx 模块的执行顺序"></a>0x02 Nginx 模块的执行顺序</h2><p>算是这次的补充说明, 是好久之前追查的一个问题，才发现之前对 Nginx 模块的执行顺序一直理解有误，这边记录说明下。</p>
<p>我们知道nginx的一个状态机驱动的模型, 那么在同一个阶段（状态）下面, 模块的执行顺序如何呢? 具体结论如下:</p>
<p>在非 filter 模块情况下, <code>在configure的时候, 越晚添加的模块就会越先执行(挂载在同一阶段的模块哈)</code>, 几个注意点如下:</p>
<ol>
<li><p>上面描述的是在<code>configure</code>阶段越晚添加的越先执行, 指的是 Nginx 默认的configure，由于一些产品线的nginx 都会包一层自己的编译处理逻辑，这个时候就需要关注其是如何新增模块的(也就是新增模块和真正 configure)的关系</p>
</li>
<li><p>Nginx扩展的自己<code>config</code>也会影响或者控制模块的执行顺序，默认的config如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP_AUX_FILTER_MODULES=<span class="string">"<span class="variable">$HTTP_AUX_FILTER_MODULES</span> ngx_http_baidu_problem_tracing_module"</span></div></pre></td></tr></table></figure>
<p>但是如果改写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HTTP_AUX_FILTER_MODULES=&quot;ngx_http_baidu_problem_tracing_module $HTTP_AUX_FILTER_MODULES &quot;</div></pre></td></tr></table></figure>
<p>原因具体下面说明;</p>
<p>现在我们来看一个模块/扩展是如何接入 Nginx 的状态机的;</p>
<p>1. configure阶段, 这个过程，Nginx 的脚本通过我们的编译控制，收集相关的信息，最终会生成一个 Shell 变量，这个变量包含了我们要编译进去的所有模块名称，如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="variable">$HTTP</span> = YES ]; <span class="keyword">then</span></div><div class="line">    modules=<span class="string">"<span class="variable">$modules</span> <span class="variable">$HTTP_MODULES</span> <span class="variable">$HTTP_FILTER_MODULES</span> \</span></div><div class="line">             <span class="variable">$HTTP_HEADERS_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_AUX_FILTER_MODULES</span> \</div><div class="line">             <span class="variable">$HTTP_COPY_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_RANGE_BODY_FILTER_MODULE</span> \</div><div class="line">             <span class="variable">$HTTP_NOT_MODIFIED_FILTER_MODULE</span>"</div><div class="line"></div><div class="line">    NGX_ADDON_DEPS=<span class="string">"<span class="variable">$NGX_ADDON_DEPS</span> \$(HTTP_DEPS)"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<p>这个里面需要说明的一点是module是直接引用了<code>$HTTP_AUX_FILTER_MODULES</code>之类的变量，而这些变量是每个扩展的<code>config</code>文件自己控制的，也就是说你把变量名字写在前后，直接影响你在<code>modules</code>里面的顺序</p>
<ol>
<li>代码生成阶段，通过如上的环境变量, Nginx会生成类似于如下的文件, </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_module_t</span> *ngx_modules[] = &#123;</div><div class="line">    &amp;ngx_core_module,</div><div class="line">    &amp;ngx_errlog_module,</div><div class="line">    &amp;ngx_conf_module,</div><div class="line">    &amp;ngx_events_module,</div><div class="line">    &amp;ngx_event_core_module,</div><div class="line">    &amp;ngx_epoll_module,</div><div class="line">    &amp;ngx_openssl_module,</div><div class="line">    &amp;ngx_regex_module,</div><div class="line">    &amp;ngx_http_module,</div><div class="line">    &amp;ngx_http_core_module,</div><div class="line">    &amp;ngx_http_log_module,</div><div class="line">    &amp;ngx_http_upstream_module,</div><div class="line">    &amp;ngx_http_static_module,</div><div class="line">    &amp;ngx_http_autoindex_module,</div><div class="line">    &amp;ngx_http_index_module,</div><div class="line">    <span class="comment">/* 这里说明 access 是 auth basic 在 access 阶段先执行的 */</span></div><div class="line">    &amp;ngx_http_auth_basic_module,</div><div class="line">    &amp;ngx_http_access_module,</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>启动初始化阶段, 其在<code>http/ngx_http.c</code>会有大概如下的伪代码:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file: http/ngx_http.c</span></div><div class="line">        n += cmcf-&gt;phases[i].handlers.nelts;</div><div class="line"></div><div class="line"><span class="comment">// 从后面开始，追加到对于ph里面; 也就是越早在ngx modules里面被引用的，在会放在ph的越前面</span></div><div class="line">        <span class="keyword">for</span> (j = cmcf-&gt;phases[i].handlers.nelts - <span class="number">1</span>; j &gt;=<span class="number">0</span>; j--) &#123;</div><div class="line">            ph-&gt;checker = checker;</div><div class="line">            ph-&gt;handler = h[j];</div><div class="line">            ph-&gt;next = n;</div><div class="line">            ph++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>执行阶段如下:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_http_core_run_phases</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_int_t</span>                   rc;</div><div class="line">    <span class="keyword">ngx_http_phase_handler_t</span>   *ph;</div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    ph = cmcf-&gt;phase_engine.handlers;</div><div class="line"></div><div class="line">    <span class="comment">// 顺序执行</span></div><div class="line">    <span class="keyword">while</span> (ph[r-&gt;phase_handler].checker) &#123;</div><div class="line"></div><div class="line">        rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rc == NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，可以明确: </p>
<blockquote>
<p>在非filter 模块情况下, 在configure的时候, 越晚添加的模块就会越先执行(挂载在同一阶段的模块哈)</p>
</blockquote>
<h2 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h2><ul>
<li><p><a href="https://forum.nginx.org/read.php?2,246978,246999" target="_blank" rel="external">Re: How to control the order of execution modules in nginx</a></p>
</li>
<li><p><a href="http://blog.aka-cool.net/blog/2014/03/06/nginx-module-execute-order-in-same-phrase/" target="_blank" rel="external">挂载在同一阶段的Nginx模块的执行顺序 - Aka.Why</a> : 重点参考该作者的分析</p>
</li>
<li><p><a href="https://item.jd.com/29369702559.html" target="_blank" rel="external">深入理解Nginx：模块开发与架构解析-第2版</a> : 里面有重点介绍 nginx的<code>configure</code>的执行过程</p>
</li>
<li><p><a href="https://www.kancloud.cn/kancloud/master-nginx-develop/51904" target="_blank" rel="external">模块编译顺序 · Nginx开发从入门到精通 · 看云</a> : 大部分内容都是 OK 的,但是关于<code>HTTP MODULE</code>的论述有些问题，可以选择性了解下</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-Feature-List&quot;&gt;&lt;a href=&quot;#0x00-Feature-List&quot; class=&quot;headerlink&quot; title=&quot;0x00 Feature List&quot;&gt;&lt;/a&gt;0x00 Feature List&lt;/h2&gt;&lt;p&gt;主要包含如下两点: 
    
    </summary>
    
    
      <category term="nginx" scheme="http://shevacjs.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx 1.15.1 版本说明</title>
    <link href="http://shevacjs.com/2018/07/17/nginx_1_15_1/"/>
    <id>http://shevacjs.com/2018/07/17/nginx_1_15_1/</id>
    <published>2018-07-17T08:50:29.000Z</published>
    <updated>2018-07-23T06:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Feature-List"><a href="#Feature-List" class="headerlink" title="Feature List"></a>Feature List</h2><p>主要包含如下两点: </p>
<ul>
<li><p>Feature: the “random” directive inside the “upstream” block.</p>
</li>
<li><p>Feature: improved performance when using the “hash” and “ip_hash” directives with the “zone” directive.</p>
</li>
</ul>
<p>一个是引入了<code>random</code>的upstream机制，还有一个是优化了<code>zone</code>区的<code>hash</code>性能; 下面我们详细拆解其功能</p>
<h2 id="Upstream-Zone机制"><a href="#Upstream-Zone机制" class="headerlink" title="Upstream Zone机制"></a>Upstream Zone机制</h2><p>Nginx在<code>1.9.0</code>版本引入了<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#zone" target="_blank" rel="external">zone</a>的机制, 官方手册说明如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* Syntax:    zone name [size];</div><div class="line">* Default:    —</div><div class="line">* Context:    upstream</div><div class="line">&gt; This directive appeared in version 1.9.0.</div><div class="line"></div><div class="line">Defines the name and size of the shared memory zone that keeps the group’s configuration and run-time state that are shared between worker processes.</div></pre></td></tr></table></figure>
<p>也就是其核心能力是使得upstream的相关配置以及状态，支持在进程间共享。这方面的优势显而易见，依照<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/#zone" target="_blank" rel="external">NGINX Load Balancing - HTTP Load Balancer
</a>说明，我们可以总结为:</p>
<ul>
<li><p>其可以方便的支持健康检查,动态upstream配置等，而无需担心多进程数据同步的问题</p>
</li>
<li><p>状态数据，比如<code>max_fail</code>等信息，可以被多个进程共享，这样是的业务避免无效的请求和重试, 否则每个进程都得去触发<code>max_fail</code>之类的阈值</p>
</li>
</ul>
<p>关于upstream zone另外一个可以关注的点是其<code>实现机制</code>。直观来看的话，从单进程到多进程共享的数据结构，可能对源码会有较大的改动，尤其是有不少现存的upstream module,  不过nginx引入了一个相对巧妙的机制, 可以通过<code>ngx_http_upstream_zone_module.c</code>了解，其核心思路是: </p>
<ol>
<li>将进程内的数据拷贝到共享内存里面</li>
<li>将所有的指针指向共享内存空间</li>
</ol>
<p>这样<code>几乎</code>(主要有时候还需要解决多进程并发读写的问题)可以透明的将数据迁移到共享内存里面; 大致代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_upstream_init_zone</span><span class="params">(<span class="keyword">ngx_shm_zone_t</span> *shm_zone, <span class="keyword">void</span> *data)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span>                          len;</div><div class="line">    <span class="keyword">ngx_uint_t</span>                      i;</div><div class="line">    <span class="keyword">ngx_slab_pool_t</span>                *shpool;</div><div class="line">    <span class="keyword">ngx_http_upstream_srv_conf_t</span>   *uscf, **uscfp;</div><div class="line">    <span class="keyword">ngx_http_upstream_main_conf_t</span>  *umcf;</div><div class="line"></div><div class="line">    <span class="comment">/* 省去部分代码，指向共享内存区域 */</span></div><div class="line">    shpool = (<span class="keyword">ngx_slab_pool_t</span> *) shm_zone-&gt;shm.addr;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* copy peers to shared memory */</span></div><div class="line"></div><div class="line">    umcf = shm_zone-&gt;data;</div><div class="line">    uscfp = umcf-&gt;upstreams.elts;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; umcf-&gt;upstreams.nelts; i++) &#123;</div><div class="line">        uscf = uscfp[i];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (uscf-&gt;shm_zone != shm_zone) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 讲每个upstream conf 拷贝到共享内存区域 */</span></div><div class="line">        <span class="keyword">if</span> (ngx_http_upstream_zone_copy_peers(shpool, uscf) != NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以回到这次的feature, 对所谓的『ip_hash/hash』的性能优化，其实就是对zone里面读写锁的精细化控制。</p>
<h2 id="Random-Upstream"><a href="#Random-Upstream" class="headerlink" title="Random Upstream"></a>Random Upstream</h2><p>另外一个比较大的特性是引入<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#random" target="_blank" rel="external">random upstream</a>的支持, 其官方手册说明如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* Syntax:	random [two [method]];</div><div class="line">* Default:	—</div><div class="line">* Context:	upstream</div><div class="line"></div><div class="line">The optional two parameter instructs nginx to randomly select two servers and then choose a server using the specified method. The default method is least_conn which passes a request to a server with the least number of active connections.</div></pre></td></tr></table></figure>
<p>这里我们主要关注<code>random two least_conn</code>的情况; 什么意思呢?</p>
<p>用随机算法的时候，我们最担心的就是随机不均衡的问题, 所以对于我们upstream的random算法，其也要考虑这个方面的情况, 而<code>two least_conn</code>就是处理这个问题的有效手段，下面具体分析。</p>
<p>首先回到一个纯粹的数学问题，N个请求让N个服务器处理，则处理请求最多的服务器其会处理多少请求呢？</p>
<p>我们知道正常情况下，平均一个服务器会处理一个请求，但是事实上这个是低概率事件, 从<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" target="_blank" rel="external">Balanced Allocations</a>的分析，其原话是:</p>
<blockquote>
<p>the fullest box has, with high probability, ln $n$ / ln ln $n(1 + o(1))$ ball in it</p>
</blockquote>
<p>也就是其实最大负载的机器其处理的请求数会远超于均值, 而如果用<code>Two Random Choices</code>(随机选两个，其次选择负载低的策略), 其概率大概为 $ln \ ln\ n$</p>
<p>如下是去概率函数分布图: </p>
<p><img src="/images/two-choice-info.svg" alt="two-random-choice"></p>
<p>总而言之, 双次选择会使得我们的负载均衡的表现更为优异。</p>
<p>如上公式的数学推导其实是比较复杂的(至少我没有看懂), 所以这里在简单分享自己对”N个请求让N个服务器处理，则处理请求最多的服务器其会处理多少请求呢?”这个问题的程序员解法;(Maybe有错误哈)</p>
<p>首先定义概率密度函数:</p>
<ul>
<li>$f(k)$ : 表示N个球放N个盒子,处理请求最多的盒子其处理请求数量为k的概率</li>
<li>则上面的问题，其实求的就是该分布的期望, 可以有:</li>
</ul>
<p>$$E = \sum_{k=1}^{n}{f(k)*k}$$</p>
<p>其次，我们分析如何求解$f(k)$, 这里面我们通过传统概率算法计数法来计算对应的概率, 具体如下:</p>
<ul>
<li>N个球放入N个盒子，不考虑球的差异性，其有 $\binom{2*n-1}{n}$ 可能性</li>
<li><p>再考虑如果最多盒子对应的球的个数为k的放法, 我们定义为$c(n_1,n_2,k)$, 表明$n_1$个球放入$n_2$盒子，最多的盒子里面有$k$个球的方法数,则显然有:</p>
<ul>
<li>$c(n,n,1)$ = 1</li>
<li>$c(n,n,n)$ = n</li>
</ul>
</li>
</ul>
<p>而对于$c(n,n,k)$我们则使用递归法统计， 我们可以估算其最多有$i$个盒子里面有$k$个球，基于次分析:</p>
<p>$$c(n_1,n_2,k) =  \sum_{i=1}^{n} (cc(i) <em> (\sum_{j=1}^{k-1}c(n_1-i</em>k,n_2-i, j)))$$</p>
<p>其中$cc(i)$ 表明$i$个盒子有$k$个球，选取的办法有$\binom{n_2}{i}$<br>而公示后半部分的意思是剩余的盒子里面，最多为1,2,…,k-1个球的放法</p>
<p>按照如上的公示，可以得到代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s</span><span class="params">(ball,box,k)</span> :</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ball &gt; box <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> box &gt; ball <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        total = math.factorial(box) / math.factorial(ball) / math.factorial(box - ball)</div><div class="line">        <span class="keyword">return</span> total</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ball == box <span class="keyword">and</span> k == <span class="number">1</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> :</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    </div><div class="line">    total = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,ball+<span class="number">1</span>) :</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> i * k &gt; ball :</div><div class="line">            <span class="keyword">break</span></div><div class="line">            </div><div class="line">        <span class="keyword">if</span> i &gt; box :</div><div class="line">            <span class="keyword">break</span></div><div class="line">        </div><div class="line">        tmp1 = math.factorial(box) / math.factorial(i) / math.factorial(box - i)</div><div class="line">        tmp2 = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k) :</div><div class="line">            tmp2 += s(ball- i*k, box-i, k-j)</div><div class="line">        total += tmp1 * tmp2</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> total</div></pre></td></tr></table></figure>
<p>依照如上公示，我们可以得到一些期望值如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ball_exp(<span class="number">10</span>) = <span class="number">3.7</span></div><div class="line">ball_exp(<span class="number">20</span>) = <span class="number">4.7</span></div><div class="line">ball_exp(<span class="number">40</span>) = <span class="number">5.6</span></div></pre></td></tr></table></figure></p>
<p>和上面的数据推导数据不完全一致，但是还是符合相应的函数曲线的</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://fly.io/articles/simple-wins-power-of-2-load-balancing/" target="_blank" rel="external">When Simple Wins: The Power of Two Random Choices</a> : 介绍<code>Two-Random-Choices</code>在<code>fly.io</code>的应用</p>
</li>
<li><p><a href="http://liblb.com/p2c.html#experiment" target="_blank" rel="external">An Empirical Study of Load Balancing Algorithms</a> : 对<code>Two Random Choices</code>的深入介绍和说明</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Feature-List&quot;&gt;&lt;a href=&quot;#Feature-List&quot; class=&quot;headerlink&quot; title=&quot;Feature List&quot;&gt;&lt;/a&gt;Feature List&lt;/h2&gt;&lt;p&gt;主要包含如下两点: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fea
    
    </summary>
    
    
      <category term="nginx" scheme="http://shevacjs.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180624</title>
    <link href="http://shevacjs.com/2018/07/02/20180624/"/>
    <id>http://shevacjs.com/2018/07/02/20180624/</id>
    <published>2018-07-02T04:49:45.000Z</published>
    <updated>2018-07-02T04:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hongkong.jpg" alt="香港"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://news.ycombinator.com/item?id=17363871" target="_blank" rel="external">Jsonnet – A data templating language | Hacker News</a> : Jsonnet是一个Json的模板语言，可以简单快速的构建基于Json的数据结构；PS: 其应用场景应该是作为中间工具，让业务用比较低的成本编写Json(支持计算/变量等)，然后转换成最终的Json，降低业务json的维护和改造成本, 但是感觉其学习成本也不低</p>
</li>
<li><p><a href="https://www.bleepingcomputer.com/news/security/changes-in-webassembly-could-render-meltdown-and-spectre-browser-patches-useless/" target="_blank" rel="external">Changes in WebAssembly Could Render Meltdown and Spectre Browser Patches Useless</a> : WebAssembly提供了一个能让程序更高效运行在浏览器的机制，但是也可能存在一些副作用，比如一旦引入类似于<code>multi-thread</code>的机制，就可能引入一些安全问题和风险, 比如之前CPU的Meltdown和Spectre漏洞</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491111&amp;idx=1&amp;sn=4dae1d28412e4a09e8cc56e3d35284cf" target="_blank" rel="external">独家揭秘：腾讯千亿级参数分布式ML系统无量背后的秘密</a> : 信息量很大，先mark，本周消化下</p>
</li>
<li><p><a href="https://blog.acolyer.org/2018/06/26/deep-code-search/" target="_blank" rel="external">Deep code search | the morning paper</a> : 挺有意思的一个系统，通过深度学习的方法来了解代码的大概功能，基于此，可以解决一些语义检索的问题，比如说”read an object from xml”, 可能有一天会取代<code>stack overflow</code></p>
</li>
<li><p><a href="https://khanna.cc/blog/structuring-deep-learning-projects/" target="_blank" rel="external">Structuring Deep Learning Projects</a> : 本文介绍一个架构化的深度学习项目的开展方式，具体包括: </p>
<ol>
<li>Pick a cost function.</li>
<li>Pick an initial network architecture.</li>
<li>Fit the training set well on the cost function.</li>
<li>Fit the validation set well on the cost function.</li>
<li>Verify performance on a test set.</li>
<li><p>Verify performance in the real world.</p>
<p>其实这也是普适的机器学习方法</p>
</li>
</ol>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>About Perf Tool</p>
</blockquote>
<ul>
<li><p>选择工具: <a href="http://www.brendangregg.com/blog/2015-07-08/choosing-a-linux-tracer.html" target="_blank" rel="external">Choosing a Linux Tracer (2015)</a>  作者分享了自己如何选择trace的参考依据，结论是建议大部分情况可以优先考虑perf tool(系统默认支持，不过和系统版本相关性较大)</p>
</li>
<li><p>入门使用 :</p>
<ul>
<li><a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="external">Perf: Tutorial</a> : 入门了解</li>
<li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="external">Brendangregg: perf Examples</a> : 系统介绍</li>
</ul>
</li>
<li><p>机制原理 : </p>
<ul>
<li><a href="https://jvns.ca/blog/2016/03/12/how-does-perf-work-and-some-questions/" target="_blank" rel="external">How does perf work? (in which we read the Linux kernel source)</a></li>
<li><a href="https://news.ycombinator.com/item?id=11277172" target="_blank" rel="external">Hacker News Comment On How does perf work</a></li>
</ul>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491140&amp;idx=1&amp;sn=8849bce1ea612049a07f6406c244a771" target="_blank" rel="external">最强指南：处理35种不良数据的正确方式</a> : 一些处理数据的tips建议，可以关注的点包括<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E7%A6%8F%E7%89%B9%E5%AE%9A%E5%BE%8B" target="_blank" rel="external">本福特定律</a>,<a href="https://www.quora.com/What-is-p-hacking" target="_blank" rel="external">结果被p-hack</a></p>
</li>
<li><p><a href="https://github.com/oddisland/Draft" target="_blank" rel="external">Draft:Online markdown editor</a> : 感觉是一个还不错的markdown在线编辑器</p>
</li>
<li><p><a href="https://pomax.github.io/bezierinfo/zh-CN/" target="_blank" rel="external">A Primer on Bézier Curves</a> : 进行mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247491127&amp;idx=1&amp;sn=9897b560cb0350e8ece0f61b3dc461c4" target="_blank" rel="external">这是我看过解释TensorFlow最透彻的文章！</a> : 继续mark</p>
</li>
<li><p><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">Valloric/YouCompleteMe: A code-completion engine for Vim</a> : A code-completion engine for Vim, 一个比较系统的代码补全工具的合集, 还可以参看<a href="https://ops.tips/gists/navigating-the-linux-kernel-source-with-youcompleteme/" target="_blank" rel="external">Navigating the Linux Kernel source tree with YouCompleteMe | OpsTips</a>这个的介绍说明</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hongkong.jpg&quot; alt=&quot;香港&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a h
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180617</title>
    <link href="http://shevacjs.com/2018/06/24/20180617/"/>
    <id>http://shevacjs.com/2018/06/24/20180617/</id>
    <published>2018-06-24T05:36:45.000Z</published>
    <updated>2018-06-24T05:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;mid=2247489433&amp;idx=1&amp;sn=094e94e19baa62f7015dc1afd5c67576" target="_blank" rel="external">写好shell脚本的13个技巧</a> : 很多建议都非常中肯，有点琐碎，去能真正提供好用户体验, 具体如下(个人感觉最后有一个shell的lib自动提供如下的能力) :<ol>
<li>提供–help标记</li>
<li>检查所有命令的可用性</li>
<li>独立于当前工作目录</li>
<li>如何读取输入：环境变量 vs. 标记</li>
<li>打印对系统执行的所有操作</li>
<li>如果有必要，提供–silent选项</li>
<li>重新开启显示</li>
<li>用动画的方式显示进度</li>
<li>用颜色编码输出</li>
<li>出现错误立即退出脚本</li>
<li>自己执行清理工作</li>
<li>在退出时使用不同的错误码</li>
<li>在结束时打印一个新行</li>
</ol>
</li>
</ul>
<ul>
<li><p><a href="https://about.gitlab.com/2018/06/15/introducing-gitlab-s-integrated-development-environment/" target="_blank" rel="external">Meet the GitLab Web IDE</a> : 介绍Gitlab的web IDE背后设计的思路和发展历程，整体感觉集Web IDE集成在gitlab可以对开发流程提供的想象空间很大</p>
</li>
<li><p><a href="https://carbon.now.sh/" target="_blank" rel="external">Carbon</a> : “Create and share beautiful images of your source code”, 其可以生成渲染出好看的代码截图(不知道有什么用~)</p>
</li>
</ul>
<ul>
<li><a href="https://code.facebook.com/posts/1461914677288302/open-sourcing-sonar-a-new-extensible-debugging-tool/" target="_blank" rel="external">Open-sourcing Sonar, a new extensible debugging tool | Engineering Blog | Facebook Code</a> : Facebook发布的用于调试和追踪App行为的工具, 不过app事先嵌入相关的SDK，感觉有一定的成本</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://memcached.org/blog/nvm-caching/" target="_blank" rel="external">Caching beyond RAM: the case for NVMe</a> : 本文提供了一个memcached的新的解决方案，通过<code>exstore</code>机制，将部分缓存的<code>value</code>数据存储在独立的存储引擎上面(比如SSD或者本文的NVMe存储介质)，数据表明，其性价比和性能还是非常可观的, 其中的<a href="https://github.com/memcached/memcached/wiki/Extstore" target="_blank" rel="external">Extstore</a>值得关注</p>
</li>
<li><p><a href="https://blog.twitter.com/engineering/en_us/topics/insights/2018/twittertensorflow.html" target="_blank" rel="external">Twitter meets TensorFlow</a> : mark, 介绍twitter的tensorflow的接入历程</p>
</li>
<li><p><a href="https://code.facebook.com/posts/605721433136474/accelerate-large-scale-applications-with-bolt/" target="_blank" rel="external">Accelerate large-scale applications with BOLT | Engineering Blog | Facebook Code</a> : 现在多数软件系统的体积都会很大，这可能会导致其不能被CPU cache命中，进而会导致诸如<a href="https://software.intel.com/en-us/vtune-amplifier-help-instruction-starvation" target="_blank" rel="external">Instruction Starvation</a>的问题,  所以<code>Binary Optimization and Layout Tool</code>就有一定的发展空间；本文介绍了Facebook的BOLT的解决方案, 其通过链接优化，profile采集进而进行二进制优化，来提升整体程序的性能，支持多种CPU架构和编译器，可以感觉Facebook在基础技术的优化做的还是非常精细的</p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247490909&amp;idx=1&amp;sn=cb8b69c0433c40b8d5e2ef0b9d2b58e2" target="_blank" rel="external">创业半年估值四亿！离开百度后他打造了中国版AutoML</a> : AutoML以后会是趋势，至少应该会有系统化或者成套的解决方案让机器学习工程师从调参等事情中解放出来</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247487968&amp;idx=1&amp;sn=2ff7b511f6727c7816ab02fc0e1c0361" target="_blank" rel="external">聊聊架构</a> :  不是特别喜欢行文风格，但是总结起来就是<code>如果你在使用 MySQL 或 MariaDB，不要用“utf8”编码，改用“utf8mb4”</code></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247490919&amp;idx=1&amp;sn=7df7d148c1d3907654980d39500c94bd" target="_blank" rel="external">重磅！Netflix开源大数据发现服务框架Metacat</a> : 个人之前有设想过需要去构建的大数据服务系统，其”旨在让发现、处理和管理数据变得更为方便”</p>
</li>
<li><p><a href="http://jamie-wong.com/post/reverse-engineering-instruments-file-format/" target="_blank" rel="external">Reverse Engineering Instruments’ File Format</a> : 内容比较多，先mark</p>
</li>
<li><p>[<a href="http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/" target="_blank" rel="external">Let’s code a TCP/IP stack, 1: Ethernet &amp; ARP</a>] : mark</p>
</li>
<li><p><a href="http://www.pcg-random.org/" target="_blank" rel="external">PCG, A Family of Better Random Number Generators | PCG, A Better Random Number Generator</a> : Mark, 有个具体说明的video，有空的时候可以看下</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180610</title>
    <link href="http://shevacjs.com/2018/06/24/20180610/"/>
    <id>http://shevacjs.com/2018/06/24/20180610/</id>
    <published>2018-06-24T05:34:45.000Z</published>
    <updated>2018-06-24T05:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://www.oschina.net/news/96686/side-channel-attacking-browsers" target="_blank" rel="external">令人惊叹的 CSS 漏洞攻击，Firefox 和 Chrome 中枪</a> :  文章介绍了一个比较精巧的用户隐私窃取方式, 可以关注其英文原文<a href="https://www.bleepingcomputer.com/news/security/css-is-so-overpowered-it-can-deanonymize-facebook-users/" target="_blank" rel="external">CSS Is So Overpowered It Can Deanonymize Facebook Users</a></p>
</li>
<li><p><a href="https://jasonhpriestley.com/lr" target="_blank" rel="external">LR Parsing: More Elegant Than You Think</a> : 对LR算法的更通俗，简单易懂的一个介绍</p>
</li>
<li><p><a href="http://dockone.io:82/article/5280" target="_blank" rel="external">gVisor：Google开源的新型沙箱容器运行时环境</a> : 谷歌发布了一款新型的沙箱容器运行时 gVisor，号称能够为容器提供更安全的隔离，同时比 VM 更轻量，其核心是希望补齐直接docker之类技术引入的安全性问题。沙箱的解决方案有多个，本文侧重介绍gVisor的实现机制，<a href="https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;mid=2247489400&amp;idx=1&amp;sn=4f099bdfb41e046f430acb135d0817eb" target="_blank" rel="external">此文</a>有进一步的说明, 感觉虚拟化技术最近几年发展和变化速度非常迅猛</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://techcrunch.com/2018/06/01/how-instagram-feed-works/" target="_blank" rel="external">How Instagram’s algorithm works | TechCrunch</a> : 本文介绍Instagram的新的排序算法，其相比于传统的基于回复时间排序的算法，对于文章的曝光率有了明显的提升，具体策略算法方面，只是介绍了一些核心的思路，细节之处没有做过多介绍，但是仍旧值得关注。 </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247487946&amp;idx=1&amp;sn=69a96352c28d95db1620537e9ac65587" target="_blank" rel="external">重新理解微服务</a> : 感觉相对来说比较干货的文章，具体介绍了业务服务化改造后可能面临的问题，以及其解决方案，重点介绍了”服务粒度”, “服务组合”, “数据一致性”, “支撑系统” 等一些基础设施以及能力在落地时候的关键点</p>
</li>
<li><p><a href="https://medium.com/netflix-techblog/the-end-of-video-coding-40cf10e711a2" target="_blank" rel="external">The End of Video Coding? – Netflix TechBlog – Medium</a> : 一个反问的标题，其实对视频的编码技术的优化需求从来没这么迫切，随着视频时代到来，如果在有效带宽上面提供更好的用户体验一直是各厂商的需求，作者踢了几点思路，感觉可以参考：</p>
<ul>
<li>Let’s innovate beyond block-based hybrid encoding</li>
<li>The community needs better ways to measure video quality</li>
<li>Encouraging new ideas means discussing with new people(这个忽略)</li>
</ul>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://github.com/thosakwe/t2b" target="_blank" rel="external">thosakwe/t2b: A wicked-powerful text macro language for building binary files.</a> : 挺有意思的一个工具，通过描述性语言(DSL)快速生成一个二进制文件, 纯C实现~</p>
</li>
<li><p><a href="http://codebay.cn/post/9253.html" target="_blank" rel="external">Firefox 和 Tor 浏览器正进行整合，最终实现二合一 –</a> : 持续关注，后续希望无论在Chrome还是Firefox都有比较好的隐私浏览体验和保护</p>
</li>
<li><p><a href="https://weibo.com/5815864126/GjcIowhtU" target="_blank" rel="external">火币研究院最新发布的全球区块链产业全</a> : 对于区块链的近一年爆发式发展的一个概述，可以当做课外读物</p>
</li>
<li><p><a href="https://devpen.io/editor" target="_blank" rel="external">Devpen | Markdown Editor with GitHub Style</a> : 很简单精炼的Github样式支持的Markdowen编辑器</p>
</li>
<li><p>[<a href="https://jmperezperez.com/fostering-web-performance-culture/" target="_blank" rel="external">Fostering a Web Performance Culture - José M. Pérez</a>] : 很长的文章，介绍了作者对于如何构建一个对性能持续关注投入的团队，作者也提了自己的一些建议，包括:</p>
<ul>
<li>Your dev environment is not your user’s environment(Realistic environment)</li>
<li>It’s better to learn the fundamentals than the library (Fundamentals over libraries)</li>
<li>Get the time to experiment and validate (Experiment on your project)</li>
<li>Educate your Colleagues </li>
<li>Share and celebrate success (and failure) stories (Share &amp; Celebrate)</li>
<li>Make performance part of your workflow(Integrate in workflow)</li>
</ul>
</li>
<li><p><a href="https://medium.com/@CanHasCommunism/understanding-compilers-for-humans-ba970e045877" target="_blank" rel="external">Understanding Compilers</a> : 干货很少，但是可以学习如何用简单的语言去描述一个负责的编译过程，包括”the major concepts in compilers like tokenization, grammars, parsing, and code generation”</p>
</li>
<li><p><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="external">JVM Internals</a> : 关于JVM实现机制的介绍，内容没有细看，不过排版和图片非常赞，另外作者的blog的干货也是非常多，mark关注下</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247487964&amp;idx=1&amp;sn=dc8ed665b9fd684cc6f99cae09feb4ab" target="_blank" rel="external">如何防止密码被硬编码到代码中？Yelp开源了自己的解决方案</a> :  一个很简单的文章，Yelp开源了自己代码密码检测的工具，如果检测代码里面是否有密码呢？思路很简单，就是通过计算内容的<a href="http://blog.dkbza.org/2007/05/scanning-data-for-entropy-anomalies.html" target="_blank" rel="external"> Shannon entropy formula</a>, 如果信息熵越大，那就说明其是密码的概率就越高，关于其进一步介绍可以参看<a href="http://www.bearcave.com/misl/misl_tech/wavelets/compression/shannon.html" target="_blank" rel="external">Shannon Entropy
</a></p>
</li>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404250830327963644" target="_blank" rel="external">10 款程序员必备的免费开源安全工具，助你成为极客</a> : mark，关注</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/96686/side-chan
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180520</title>
    <link href="http://shevacjs.com/2018/05/22/20180520/"/>
    <id>http://shevacjs.com/2018/05/22/20180520/</id>
    <published>2018-05-22T03:15:45.000Z</published>
    <updated>2018-05-22T03:14:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://ripe76.ripe.net/presentations/10-2018-05-15-bbr.pdf" target="_blank" rel="external">2018-05-16-bbr</a> : 对TCP的BBR的拥塞机制的系统介绍和说明</p>
</li>
<li><p><a href="https://github.com/Troland/how-javascript-works/blob/master/webassembly.md" target="_blank" rel="external">How JavaScript works: A comparison with WebAssembly + why in certain cases it’s better to use it over JavaScript</a> : 比较精炼的介绍了Web Assembly相比于Javascript的优势，以及其实现机制，一些配图都挺赞的, 而且blog里面的<code>How Javascript works</code>也挺赞的，可以关注 </p>
</li>
<li><p><a href="http://www.maizure.org/projects/printf/index.html" target="_blank" rel="external">Tearing apart printf() – MaiZure’s Projects</a> : 一个简单的<code>printf</code>的调用其底层实现机制具体的怎么样的呢? 作者通过strace/gdb等一系列工具，详细说明了<code>printf</code>实现机制，包括静态/动态链接是，其在C标准库, 系统调用方面的情况, 是很好的了解系统编译，链接机制的教材</p>
</li>
<li><p><a href="http://www.pixelbeat.org/programming/stdio_buffering/" target="_blank" rel="external">stdio buffering</a> : 文章介绍，在Shell环境下，由于输入/输出，pipe都会有一定的内存buffer, 可能会导致一些程序有非预期行为(输出不及时等)，其通过图例直观的展示了buffer的影响，同时概述的介绍一些linux后续可以考虑采纳的方案，比如通过引入<code>BUF_1</code>的环境变量, 引入<code>stdbuf</code>等命令</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://developers.google.com/machine-learning/rules-of-ml/" target="_blank" rel="external">机器学习规则 (Rules of Machine Learning)</a> :  Google Developer网站推荐的机器学习落地实践的方法，个人觉得非常有参考价值</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://www.themtank.org/a-year-in-computer-vision" target="_blank" rel="external">A Year in Computer Vision</a> : 对于计算机视觉过去一年的进展的概述，值得学习review</p>
</li>
<li><p><a href="http://www.webhek.com/post/utmurchin-tracking-module-with-google-analytics.html" target="_blank" rel="external">使用UTM(Urchin Tracking Module)统计流量来源 – WEB骇客</a> : Google Analysis的提供的基于querystring的站点统计和分析的解决方案</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=17107149" target="_blank" rel="external">A Formal Security Analysis of the Signal Messaging Protocol (2017)</a> : 对支持E2E的加密软件/算法<code>Signal</code>协议的深入剖析, hacker news上面相关的评论和总结还不错</p>
</li>
<li><p><a href="http://pgbovine.net/cpython-internals.htm" target="_blank" rel="external">CPython internals: A ten-hour codewalk through the Python interpreter source code</a> : 通过视频录制/讲解的方式让你对Cpython的整体机制有进一步的了解, mark</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://ripe76.ripe.net/presentations/10-201
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180413</title>
    <link href="http://shevacjs.com/2018/05/22/20180513/"/>
    <id>http://shevacjs.com/2018/05/22/20180513/</id>
    <published>2018-05-22T03:13:45.000Z</published>
    <updated>2018-05-22T03:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://blogs.msdn.microsoft.com/commandline/2018/05/08/extended-eol-in-notepad/" target="_blank" rel="external">Introducing extended line endings support in Notepad</a> : “Starting with the current Windows 10 Insider build, Notepad will support Unix/Linux line endings (LF), Macintosh line endings (CR), and Windows Line endings (CRLF) as usual”</p>
</li>
<li><p><a href="https://software.rajivprab.com/2018/04/29/myths-programmers-believe-about-cpu-caches/" target="_blank" rel="external">Myths Programmers Believe about CPU Caches – Software the Hard way</a> : 本文具体介绍了CPU内部的cache和main memory数据一致性的问题和解决方案，其本质设计里面和分布式系统的数据一致性思路雷同，核心思路是基于<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="external">MESI protocol</a>在硬件层面的实现</p>
</li>
<li><p><a href="https://techcrunch.com/2018/05/07/microsofts-new-intellicode-is-a-smarter-intellisense/" target="_blank" rel="external">Microsoft’s new IntelliCode is a smarter IntelliSense</a> : VS Studio通过AI提供更智能的代码提示, 希望后续微软能够披露里面的技术实现机制和细节，便于迁移更多的产品和应用, 这个和Google IO展示的<a href="https://www.businessinsider.sg/google-gmail-gets-smart-compose-automatic-reply-suggestion-service-2018-5/" target="_blank" rel="external">Google wants Gmail to help reply to your emails for you with this new AI tech, Business Insider</a> 思路有点类似，可见后续越来越多的人工智能会应用用这些看起来琐碎，却是重复的一些工作上面</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><a href="https://cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext" target="_blank" rel="external">Lessons from Building Static Analysis Tools at Google</a> : 文章比较长，先mark关注下</li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247490326&amp;idx=1&amp;sn=21126be3c5ea7d112dfacf21c9f87128&amp;chksm=fbe9a2d9cc9e2bcfd7c6284be84898d911f7f1e6e04807f3562debc913cd89f32dd1037b72fb#rd" target="_blank" rel="external">给你打电话的可能不是人！谷歌Duplex颠覆智能助手</a> : Google IO是这周科技界的热门事件，本文介绍了其<code>Google Assistant</code>的特性以及其背后的技术支持情况</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://blog.scottlogic.com/2018/04/26/webassembly-by-hand.html" target="_blank" rel="external">Writing WebAssembly By Hand</a> : </p>
</li>
<li><p><a href="https://weibo.com/ttarticle/p/show?id=2309404212049503760281#_0" target="_blank" rel="external">周鸿祎：写区块链最好的一篇文章</a> : mark了解下</p>
</li>
<li><p><a href="http://codebay.cn/post/8960.html" target="_blank" rel="external">最适合练手30个的机器学习开源项目，赶紧收藏</a> : mark下，后续可以试试里面的一些项目 </p>
</li>
<li><p><a href="http://www.techug.com/post/how-cpu-make-out.html" target="_blank" rel="external">CPU是如何制造出来的（附高清全程图解</a> : </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/lCQxGFPvzLPyXm0ttGtIkA" target="_blank" rel="external">理解共识算法真谛，让你不再被忽悠</a> : 介绍的清晰明了，可以对共识算法有个初步的认识和理解</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html" target="_blank" rel="external">根域名的知识 - 阮一峰的网络日志</a> : 科普短文</p>
</li>
<li><p><a href="http://norvig.com/21-days.html" target="_blank" rel="external">Teach Yourself Programming in Ten Years</a> : 对于学习成长的具体方法说的很具体很契合实际，包括”Learn at least a half dozen programming languages. Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go)”，对于Lisp之类的语言后续还是需要再投入学习</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/commandline
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180505</title>
    <link href="http://shevacjs.com/2018/05/07/20180506/"/>
    <id>http://shevacjs.com/2018/05/07/20180506/</id>
    <published>2018-05-07T04:53:45.000Z</published>
    <updated>2018-05-07T04:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/yanqing01.jpg" alt="延庆"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://zinovyev.net/blog/ssh-client-configuration-tricks" target="_blank" rel="external">SSH client configuration tricks</a> : 关于SSH的使用技巧, 可以对特定机器设定alias, 并且绑定相关配置, 对于常见的VPS可以做这类的优化</p>
</li>
<li><p><a href="https://opensource.com/article/18/4/cpu-utilization-wrong" target="_blank" rel="external">CPU utilization is wrong, says Netflix’s Brendan Gregg</a> : 关于CPU优化的深入讨论, 其实强调的核心理念是，现在CPU和内存的速度越差越大，所以有时候会我们发现CPU idle很低的时候，有可能其并不是在忙着执行指令，而是在等待Memory IO，尤其是高速缓存失效的时候</p>
</li>
<li><p><a href="https://onlinebinarytools.com/" target="_blank" rel="external">online binary tools</a> : 一些online bianry的工具集合, 有兴趣可以关注下。不过个人更喜欢用类似于<a href="https://zeppelin.apache.org/" target="_blank" rel="external">Zeppelin</a>通过此类的平台，来构建自己的工具集</p>
</li>
<li><p><a href="http://blog.pengqiuyuan.com/ji-chu-jie-shao-ji-suo-yin-yuan-li-fen-xi/" target="_blank" rel="external">Elasticsearch－基础介绍及索引原理分析</a> : 对ES的索引和存储架构有比较详细的说明，可以快速了解下</p>
</li>
<li><p><a href="https://github.com/google/randen" target="_blank" rel="external">google/randen: Fast backtracking-resistant random generator</a> : “What if we could default to attack-resistant random generators without excessive CPU cost? We introduce ‘Randen’, a new generator with security guarantees; it outperforms MT19937 and pcg64_c32 in real-world benchmarks. This is made possible by AES hardware acceleration and a large Feistel permutation.”， Google提出的新的随机数生成器，不过对其要解决的问题和解决的方案并不是很了解，先mark</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://groups.csail.mit.edu/mac/users/gjs/6.945/readings/robust-systems.pdf" target="_blank" rel="external">robust-systems.pdf</a> : mark</p>
</li>
<li><p><a href="https://www.oschina.net/news/95719/google-chrome-will-show-warnings-for-non-logged-ssl-certificates" target="_blank" rel="external">谷歌访问非登记SSL证书的HTTPS网站将全屏警告</a> : “自今天开始，访问尚未在公共证书透明度（CT）日志中登记 SSL 证书的 HTTPS 网站，Chrome 浏览器将会显示全屏警告。这样做使 Chrome 浏览器成为首个部署支持 Certificate Transparency Log 策略的浏览器”, 如果有关注之前介绍的TLS的文章，可以认为<a href="https://www.certificate-transparency.org/" target="_blank" rel="external">Certificate Transparency</a>是解决CT恶意或者无意颁发错误证书的一个有效办法</p>
</li>
<li><p><a href="https://www.ebayinc.com/stories/blogs/tech/elasticsearch-performance-tuning-practice-at-ebay/" target="_blank" rel="external">Elasticsearch Performance Tuning Practice at eBay</a> :  本文是eBay分享的关于ES使用优化的一系列建议，包括<code>优化索引设计</code>, <code>优化检索query</code>，<code>性能评估</code>等多个阶段多个方面的具体实践建议, 也有中文版<a href="http://www.infoq.com/cn/articles/elasticsearch-performance-tuning-practice-at-ebay" target="_blank" rel="external">eBay的Elasticsearch性能调优实践</a></p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>这两周主要关注WebAssembly，在整理相关的文章~</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://dendibakh.github.io/blog/2018/04/22/What-optimizations-you-can-expect-from-CPU" target="_blank" rel="external">What optimizations you can expect from CPU?</a> : Mark</p>
</li>
<li><p><a href="http://www.techug.com/post/27-incredibly-useful-things-you-didnt-know-chrome-could-do.html" target="_blank" rel="external">超好用的27个谷歌Chrome浏览器使用技巧</a> : 一些Chrome使用的技巧，可以推荐的包括: <code>Cmd+Shift+T</code>恢复最近关闭的标签, <code>Chrome作为你的文件浏览</code>等</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247489971&amp;idx=1&amp;sn=f9b023413f17576c0e859e1f12c3c5fb&amp;chksm=fbe9a07ccc9e296a24891063cb92c4ecbdee984985f9c9afcc1691748d7ea4c483bd96dc5540#rd" target="_blank" rel="external">苹果、谷歌等大厂的AI面试题被我们搞到手了，你敢来挑战吗？</a> : 有空锻炼下自己也挺好的~</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ZY0S6V3gOMJ9MNomHJCGQw" target="_blank" rel="external">没有真实，区块链不可篡改有毛用</a> : 比较赞同的一个文章，区块链的核心价值是需要记录真是的信息，然后不被篡改；但是前者才是真正的难题，也很难想明白现在的不可篡改的存储机制对现有的业务流程有深层次改善的地方</p>
</li>
<li><p><a href="http://www.techug.com/post/machine-learning-study-list.html" target="_blank" rel="external">牛人的Machine Learning 机器学习笔记目录</a> : ML的学习比较, mark</p>
</li>
<li><p><a href="https://asylo.dev/" target="_blank" rel="external">Asylo</a> : Google发布的可信计算的框架，支持在云端部署含有私密数据的应用；直观而言，这个方面的需求在技术方面实现难度还比较大，先mark，下来深入学习</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/yanqing01.jpg&quot; alt=&quot;延庆&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a 
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180429</title>
    <link href="http://shevacjs.com/2018/05/07/20180429/"/>
    <id>http://shevacjs.com/2018/05/07/20180429/</id>
    <published>2018-05-07T04:50:45.000Z</published>
    <updated>2018-05-07T04:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://blogs.msdn.microsoft.com/vcblog/2018/04/24/announcing-a-single-c-library-manager-for-linux-macos-and-windows-vcpkg/" target="_blank" rel="external">Announcing a single C++ library manager for Linux, macOS and Windows: Vcpkg</a> : VC提供的跨平台的C++的lib库，还是第一次见到C++库的解决方案，可以关注</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488782&amp;idx=1&amp;sn=9a450b5e97410a0f58fb61900fd82055" target="_blank" rel="external">Google Fuchsia微内核Zircon先睹为快</a> : Ziron是Google推出的面向IoT操作系统Fuchsia的内核，是一个微内核系统，文章主要介绍了此内核的体系，其语义和传统的Unix操作系统也有诸多不一样的地方，详细可以看原<a href="https://fuchsia.googlesource.com/docs/+/master/the-book/" target="_blank" rel="external">英文文档</a></p>
</li>
<li><p><a href="http://norvig.com/spell-correct.html" target="_blank" rel="external">How to Write a Spelling Corrector</a> : </p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://blog.qt.io/blog/2018/04/23/beta-qt-webassembly-technology-preview/" target="_blank" rel="external">Beta for Qt for WebAssembly Technology Preview - Qt Blog</a> : Qt发布了支持编译成WebAssembly的beta版本。如此，以后写UI组件等，并不一定需要Js，C++也行；不过效果上面令人存疑</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2018/04/weekly-issue-1.html" target="_blank" rel="external">每周分享第 1 期 - 阮一峰的网络日志</a> : 感觉干货不少，可以订阅关注下</p>
</li>
<li><p><a href="http://blog.zulip.org/2018/04/18/zulip-1-8-released/" target="_blank" rel="external">Zulip 1.8: Open source team chat</a> : 类似于<code>Slack</code>的开源方案，mark关注下~</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/vcblog/2018
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180422</title>
    <link href="http://shevacjs.com/2018/04/23/20180422/"/>
    <id>http://shevacjs.com/2018/04/23/20180422/</id>
    <published>2018-04-23T03:03:45.000Z</published>
    <updated>2018-04-23T03:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/football_stadium.jpg" alt="中超现场"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://news.ycombinator.com/item?id=16862925" target="_blank" rel="external">Facebook Container for Firefox</a> : Firefox发布了一个支持自动隔离facebook的扩展, 其实现在的feed机制也一直在窃取各种个人信息，mark后续研究下，在国内互联网，这类的数据是如何传播传递的，同时又如何可以避免~</p>
</li>
<li><p><a href="http://www.graalvm.org/" target="_blank" rel="external">GraalVM</a> : “GraalVM is a universal virtual machine for running applications written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Kotlin, and LLVM-based languages such as C and C++”, Oracle出品的，意在构建一个统一的VM，看其文档，应该包括对整个编译链的支持(比如支持定制化构建自己的语言)，先mark关注</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16888605" target="_blank" rel="external">FFmpeg 4.0 released</a> : 最新版的FFmpeg好像有不少新的功能</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16889181" target="_blank" rel="external">Mermaid: Markdown-like generation of diagrams and flowcharts from text</a> : 有点类似于<code>Dot</code>语言的规则模式，不过其在生成图片的配色方面更好看一些，不过整体图片的布局还是需要进一步的优化,其也被gitlab所<a href="https://docs.gitlab.com/ee/user/markdown.html#mermaid" target="_blank" rel="external">支持</a></p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://blog.benjojo.co.uk/post/scan-ping-the-internet-hilbert-curve" target="_blank" rel="external">Mapping the whole internet with Hilbert curves</a> : 作者通过对全部IPV4的扫描, 并以可视化的方式(Hilbert曲线)展示全球IP的活跃情况</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/mYuEt2jFRcO1rbWEe9qL-g" target="_blank" rel="external">谷歌前员工因建言YouTube被炒鱿鱼，开源揭秘其算法</a> : 推荐算法越来越多影响着我们的生活, 但是其对人的影响却很难量化去描述, 本文讲述了Google前员工对于透明推荐算法运动的推进。个人认为，让用户可以透明的了解自己的推荐策略和算法，或者可以让用户自己去定制这方面的算法，Maybe也是一个不错的产品选择。</p>
</li>
<li><p><a href="https://eng.uber.com/rethinking-gps/" target="_blank" rel="external">Rethinking GPS: Engineering Next-Gen Location at Uber</a> : </p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://medium.com/@anildash/the-missing-building-blocks-of-the-web-3fa490ae5cbc" target="_blank" rel="external">The Missing Building Blocks of the Web</a> :  现在互联网的一切好像都是理所当然的，比如中心化的服务交付，基于js/css等技术组合的web页面, 作者的这个系列从不忘初心开始, 讨论早期互联网技术的设计偏好，以及研究其在发展历程中间的演变，最后分析以后互联网技术发展的方向，同时可以关注的文章还有<a href="https://www.oreilly.com/ideas/its-time-to-rebuild-the-web" target="_blank" rel="external">It’s time to rebuild the web</a>和<a href="http://anildash.com/2012/12/13/the_web_we_lost/" target="_blank" rel="external">The Web We Lost</a></p>
</li>
<li><p><a href="https://betanalpha.github.io/assets/case_studies/probability_theory.html" target="_blank" rel="external">Probability Theory (For Scientists and Engineers)</a> : mark</p>
</li>
<li><p><a href="https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d" target="_blank" rel="external">Unwinding Uber’s Most Efficient Service</a> : mark</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NDA4NjU2MA==&amp;mid=2247489926&amp;idx=1&amp;sn=e26ee3315236e646a5e6e78bcebfe705" target="_blank" rel="external">机器学习宗师迈克尔·乔丹：AI革命尚未发生</a> : 作者认为，技术变更的本质是『在保证安全的前提下，为人们带来新的资源和能力』，所以我们系统更系统宏观的考虑现实世界的问题，AI(或者文中所说的IA)，会是我们构建更理想目标世界(<code>II</code>(Intelligent Infrastruction))的一个强有力的工具手段，但是不会是全部，而且也很难奢望通过AI等就能自动学习构建更理想的社会。另一方面，从II的视角去考虑问题，可能会更快的触达本质。以自动驾驶为例，我们现在的从IA(AI)的角度，核心的注意力在于让汽车去拥有人的判断力；但是从II的角度，去构建一个更高效的交通体系，其会自动化控制所有汽车，通过大规模的物联网，机器学习算法去做调度控制，可能是一个更好的选择(这段纯属自己臆想)。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/35925589" target="_blank" rel="external">InnoDB 存储引擎原理解析</a> : 关于Innodb的介绍，不过是纯PPT版本，有些内容只看图片并不直观</p>
</li>
<li><p><a href="https://weibo.com/1560906700/GcZescpzI" target="_blank" rel="external">关于Pornhub的一些产品细节和道德节操</a> : 挺有意思的一个说明, Maybe只有压力没那么大的一些产品，对于用户体验和产品细节才会如此用心</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/football_stadium.jpg&quot; alt=&quot;中超现场&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>PAC文件</title>
    <link href="http://shevacjs.com/2018/04/21/about_pac/"/>
    <id>http://shevacjs.com/2018/04/21/about_pac/</id>
    <published>2018-04-21T11:18:29.000Z</published>
    <updated>2018-04-21T11:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Proxy_auto-config" target="_blank" rel="external">PAC文件</a>(Proxy Auto-Config)可以约定浏览器如何去访问一个特定的网站。其应该是最为常见的代理技术之一，以其方便，简洁，灵活性被大部分主流系统(无论是安卓还是IOS)和浏览器所支持。正好最近处理了一个PAC的问题，所以这里具体介绍PAC相关的技术，包括PAC的文件编写和PAC的代理技术。</p>
<h2 id="PAC文件编写"><a href="#PAC文件编写" class="headerlink" title="PAC文件编写"></a>PAC文件编写</h2><p>如上，PAC是一个用来约定浏览器如何访问网站的配置描述。其组织方式如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//code demo from: https://en.wikipedia.org/wiki/Proxy_auto-config</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">	<span class="comment">// our local URLs from the domains below example.com don't need a proxy:</span></div><div class="line">	<span class="keyword">if</span> (shExpMatch(host, <span class="string">"*.example.com"</span>))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"DIRECT"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// URLs within this network are accessed through</span></div><div class="line">	<span class="comment">// port 8080 on fastproxy.example.com:</span></div><div class="line">	<span class="keyword">if</span> (isInNet(host, <span class="string">"10.0.0.0"</span>, <span class="string">"255.255.248.0"</span>))</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"PROXY fastproxy.example.com:8080"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// All other requests go through port 8080 of proxy.example.com.</span></div><div class="line">	<span class="comment">// should that fail to respond, go directly to the WWW:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">"PROXY proxy.example.com:8080; DIRECT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其核心是暴露一个<code>FindProxyForURL</code>的接口，每次有请求时候触发这个函数的回调，用于判断具体走哪种方式。 具体编写应用时，有如下几点可以注意: </p>
<ul>
<li><p>url/host信息 : 如果请求是<code>https</code>协议，则回调的url里面并不会包含完整路径信息, 也就是说如果原始的url是<code>https://xyz.com/abc</code>回调给<code>FindProxyForURL</code>的参数也只是<code>https://xyz.com</code>, 这就意味着对于https协议，我们做不了url粒度的代理控制。具体可以参考<a href="https://github.com/FelisCatus/SwitchyOmega/issues/845" target="_blank" rel="external">Full URLs for HTTPS are no longer provided to PAC scripts</a></p>
</li>
<li><p>调试问题: PAC的调试和普通js的调试有点不一样，其是浏览器自动触发请求的，所以方法也有些区别。在Chrome环境下，可以去<code>chrome://net-internals/#proxy</code>用于重新加载代理脚本, 同时在<code>chrome://net-internals/#events</code>去追踪日志，详细可以参考<a href="http://artica-proxy.com/how-to-debug-proxy-pac-with-google-chrome/" target="_blank" rel="external">How to debug proxy.pac with Google Chrome</a></p>
</li>
<li><p>代理问题 : 无论是怎么样的代理策略，最终我们函数需要返回的是一个代理服务器, 现在主流的浏览器主要支持如下三种访问方式:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>DIRECT</td>
<td>直接访问</td>
</tr>
<tr>
<td>PROXY name:port</td>
<td>通过走特定地址的http代理访问</td>
</tr>
<tr>
<td>SOCKS name:port</td>
<td>通过走特定地址的socks代理访问</td>
</tr>
</tbody>
</table>
<p>具体实现的时候也可以通过不同协议的组合或者冗余，来提供更高质量的代理服务。</p>
<p>这里我们重点关注<code>PROXY name:port</code>的方式，其提供的是一个HTTP代理访问的能力支持, 我们现在主流有http/https两个访问协议，其又具体如何去实现代理的呢？</p>
<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>如上，我们希望通过一个http/https服务来提供对<code>http/https</code>访问的代理。如果是仅仅代理<code>HTTP</code>访问, 其实算比较简单。由于是纯文本，也无需任何鉴权之类的逻辑(TLS)，只有正常转发请求即可，普通的Nginx就能实现该功能，可以参考<a href="http://shevacjs.com/2015/04/25/nginx_https_proxy/">nginx与https:正向代理支持</a>(原文有些地方有错误之处)。但是如何基于http/https的服务做<code>https</code>的代理呢? 因为对服务器的验证等不可能是代理服务器自己实现的，故而需要代理服务器，根本上面支持<code>TLS</code>或者更底层的服务代理。</p>
<p>这里需要用到<a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="external">HTTP tunnel</a>技术, 其主要包括两个步骤:</p>
<ol>
<li>协商阶段: 这个时候Client发送一个<code>CONNECT</code>指令，连接代理服务器，同时告诉代理服务器具体要访问的地址, 具体如下: </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">## Client发送CONNECT指令</div><div class="line">CONNECT example.host.com:22 HTTP/1.1</div><div class="line">Proxy-Authorization: Basic encoded-credentials</div><div class="line"></div><div class="line">## 服务器返回OK，这这次协商完成，允许代理</div><div class="line">HTTP/1.1 200 OK</div></pre></td></tr></table></figure>
<p>如上其实是一个正常标准的HTTP交互流程</p>
<ol>
<li>代理阶段 : 一旦协商OK，代理服务器这个时候有点类似于要转变成<code>TCP代理</code>，只做透明的client和server之间的数据转发</li>
</ol>
<p>可以通过一个<code>wireshark</code>的请求包，来进一步了解给过程: </p>
<p><img src="/images/http_tunnel_demo.png" alt="HTTP tunnel"></p>
<h2 id="HTTP代理实现"><a href="#HTTP代理实现" class="headerlink" title="HTTP代理实现"></a>HTTP代理实现</h2><p>从HTTP代理的协议我们可以知道，如果一个服务器要实现HTTP tunnel代理既要支持HTTP的CONNECT指令，也得支持<code>TLS</code>或者<code>TCP</code>的代理。这个要求对于之前的nginx是很难实现的，所以大部分的解决方案都是基于<code>squid</code>，当然我们知道通过<a href="https://github.com/chobits/ngx_http_proxy_connect_module" target="_blank" rel="external">ngx_http_proxy_connect_module</a>也能实现，但是需要打上patch包，维护成本相对较高。</p>
<p>那有没有可能用更便捷的方式，让Nginx实现HTTP tunnel代理呢？答案是肯定的！</p>
<p>我们知道Nginx已经通过<code>ngx_stream_core_module</code>, <code>ngx_stream_proxy_module</code>等模块这次了TCP/UDP的代理，加上<a href="https://github.com/openresty/stream-lua-nginx-module" target="_blank" rel="external">openresty/stream-lua-nginx-module</a>的支持，我们可以很方便的去实现上面的代理协议。整体思路如下:</p>
<ol>
<li>应用nginx的stream能力，做TCP的透明代理</li>
<li>对于初次建立链接的请求，做一些包体的分析，如果是CONNECT方式，则以HTTP方式返回数据，构建协商协议</li>
<li>协商之后，则以TCP代理方式提供服务即可</li>
</ol>
<p>整体代码配置如下:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="section">stream</span> &#123;</div><div class="line">	<span class="attribute">log_format</span> basic <span class="string">'<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>] '</span></div><div class="line">					 <span class="string">'<span class="variable">$protocol</span> <span class="variable">$status</span> <span class="variable">$bytes_sent</span> <span class="variable">$bytes_received</span> '</span></div><div class="line">					 <span class="string">'<span class="variable">$session_time</span>'</span>;</div><div class="line"></div><div class="line">    <span class="comment">## 需要声明一个变量，注意该指令在stream-lua-nginx-module-0.0.4版本以上才有</span></div><div class="line">    <span class="attribute">lua_add_variable</span> <span class="variable">$py_upstream</span>;</div><div class="line"></div><div class="line">    <span class="section">server</span> &#123;</div><div class="line">        <span class="attribute">listen</span> <span class="number">7070</span>;</div><div class="line"></div><div class="line">		<span class="attribute">access_log</span> logs/stream.log basic;</div><div class="line"></div><div class="line">        <span class="comment">## 指定dns解析代理服务器</span></div><div class="line">        <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;</div><div class="line"></div><div class="line">        <span class="comment">## preread_by_lua是在每次连接建立(TCP)或者数据包(UDP)过来被触发调用</span></div><div class="line">        <span class="comment">## 代码无太多容错性，仅用于描述功能</span></div><div class="line">        <span class="section">preread_by_lua_block</span> &#123;</div><div class="line">            <span class="attribute">local</span> sock = assert(ngx.req.socket(<span class="literal">true</span>))</div><div class="line">            <span class="comment">## 获取数据</span></div><div class="line">            local data = sock:receive()</div><div class="line">            local len = string.len(data)</div><div class="line">            local connect = string.sub(data,<span class="number">1</span>, <span class="number">7</span>)</div><div class="line"></div><div class="line">            <span class="comment">## ngx.log(ngx.ERR, "data is: ", data)</span></div><div class="line">            <span class="comment">## 判断前缀是不是"CONNECT"</span></div><div class="line">            if connect ~= <span class="string">"CONNECT"</span> then</div><div class="line">                ngx.log(ngx.ERR, <span class="string">"prefix scheme is connect, is: "</span>, connect)</div><div class="line">                ngx.exit()</div><div class="line">            end</div><div class="line"></div><div class="line">            <span class="comment">## 获取要发送的域名端口信息</span></div><div class="line">            local end_start,end_pos = string.find(data,<span class="string">" "</span>, <span class="number">9</span>)</div><div class="line">            local hostname = string.sub(data,<span class="number">9</span>, end_start - <span class="number">1</span>)</div><div class="line">            ngx.log(ngx.ERR, <span class="string">"hostname is: "</span>, hostname)</div><div class="line"></div><div class="line">            <span class="comment">## 回填到py_upstream变量，以便proxy_pass调用</span></div><div class="line">            ngx.var.py_upstream = hostname</div><div class="line"></div><div class="line">            <span class="comment">## 以正常HTTP方式返回，完成协商</span></div><div class="line">            ngx.say(<span class="string">"HTTP/1.1 200 OK\r\n"</span>)</div><div class="line">            ngx.flush()</div><div class="line">            ngx.eof()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">## 正向代理</span></div><div class="line">        proxy_pass <span class="variable">$py_upstream</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，就能完成一个<code>http tunnel</code>协议的功能。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="http://jdebp.eu./FGA/web-browser-auto-proxy-configuration.html" target="_blank" rel="external">Automatic proxy HTTP server configuration in web browsers</a> : 对PAC协议，实现，规则有详细的描述</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/HTTP_tunnel" target="_blank" rel="external">HTTP tunnel</a> : 具体介绍<code>HTTP tunnel</code>的机制, 也就是http proxy代理https请求的常规方法</p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT" target="_blank" rel="external">MDN HTTP: CONNECT</a> : HTTP CONNECT方法</p>
</li>
<li><p><a href="https://github.com/chobits/ngx_http_proxy_connect_module" target="_blank" rel="external">A forward proxy module for CONNECT request handling</a> : 一个Nginx patch/扩展, 可以支持HTTP tunnel的<code>CONNECT</code>请求， 支持<code>Forward Proxy</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_auto-config&quot; target=&quot;_bla
    
    </summary>
    
    
      <category term="nginx, proxy" scheme="http://shevacjs.com/tags/nginx-proxy/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180415</title>
    <link href="http://shevacjs.com/2018/04/18/20180415/"/>
    <id>http://shevacjs.com/2018/04/18/20180415/</id>
    <published>2018-04-18T04:26:45.000Z</published>
    <updated>2018-04-18T04:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/yanqing.jpg" alt="延庆一景"></p>
<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><p><a href="https://ultralig.ht/" target="_blank" rel="external">Lightweight, Pure-GPU HTML Renderer</a> : 一个纯GPU执行的HTML渲染器，对于游戏类的业务场景会有比较好的支持</p>
</li>
<li><p><a href="http://0x80.pl/notesen/2018-04-11-simd-is-sorted.html" target="_blank" rel="external">Is sorted using SIMD instructions</a> : 判断一个数组是否有序的最简单算法，就是遍历数组，依次比较; 但是如果处理器本身支持<code>SIMD</code>之类，会有怎么样的优化算法呢?文章具体说明了如何将上面操作<code>vectorization</code>，以提升判断的速度，结果表明在<code>AVX2</code>的指令集下面性能有<code>100%</code>以上的提升, 对SIMD指令感兴趣的话，可以参看<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" target="_blank" rel="external">Intrinsics Guide</a>这个指令手册</p>
</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://blog.cloudflare.com/neon-is-the-new-black/" target="_blank" rel="external">NEON is the new black: fast JPEG optimization on ARM server</a> : CloudFlare的技术博客，介绍其对<code>libjpg</code>在ARM平台的优化，主要是讲将在Intel下面优化的SIMD指令在ARM系统上面重写, 总结值得思考: “It is evident that the Qualcomm Centriq is a powerful processor, that definitely provides a good bang for a buck. However, years of Intel leadership in the server and desktop space mean that a lot of software is better optimized for Intel processors.”</p>
</li>
<li><p><a href="https://snr.stanford.edu/salsify/" target="_blank" rel="external">Salsify</a> : Salsify是斯坦福大学的一个项目，其核心思路是通过对视频编码速率和网络速率的协同控制，来提升<code>real time video</code>的性能和体验，直接感觉意义一般，但是其性能数据体现”reduced delay (at the 95th percentile) by 4.6×, while also improving SSIM by about 60% (2.1 dB)”，先mark，后续有空关注</p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周关注GPU编程</p>
</blockquote>
<ul>
<li><p><a href="http://courses.cms.caltech.edu/cs179/" target="_blank" rel="external">课程: GPU Programming CS179</a> : 比较综合的介绍GPU的概念基础，以及和CUDA的实践, 可以关注<a href="https://news.ycombinator.com/item?id=11902172" target="_blank" rel="external">Hacer News</a>上面对其评价</p>
</li>
<li><p><a href="https://cn.udacity.com/course/intro-to-parallel-programming--cs344" target="_blank" rel="external">课程: 并行编程入门 by Nvidia</a> : 中文版的课程</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="https://weibo.com/1705822647/GbThVDxKJ?type=comment" target="_blank" rel="external">关于百度区块链应用的思考</a> : 用区块链进行图片和内容版权保护的问题，作者的存疑和我个人的思考分析一致，mark下关注网友的讨论</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16827817" target="_blank" rel="external">Quantum mechanics used for better random numbers</a> : 量子计算机可以产生真正的随机数，但是评论上面认为，其实现在的不少硬件，比如说<code>Johnson–Nyquist</code>已经具备这类能力了</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16817234" target="_blank" rel="external">Quantum Algorithm Implementations for Beginners</a> : </p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/yanqing.jpg&quot; alt=&quot;延庆一景&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a 
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>weekly of 20180408</title>
    <link href="http://shevacjs.com/2018/04/17/20180408/"/>
    <id>http://shevacjs.com/2018/04/17/20180408/</id>
    <published>2018-04-17T14:21:45.000Z</published>
    <updated>2018-04-17T14:21:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具技巧"><a href="#工具技巧" class="headerlink" title="工具技巧"></a>工具技巧</h3><ul>
<li><a href="https://blog.cryptographyengineering.com/2018/04/07/hash-based-signatures-an-illustrated-primer/" target="_blank" rel="external">Hash-based Signatures: An illustrated Primer</a> : 文章和作者的blog多深度推荐</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&amp;mid=2247487203&amp;idx=1&amp;sn=a1510a4d29a7bdb9cc60d58c13161db9" target="_blank" rel="external">当数据库遇见FPGA：X-DB异构计算如何实现百万级TPS？</a> : 阿里数据库方向的又一个创新，核心问题是, 在基于LSM存储引擎构建的数据库，需要耗费大量的计算量在做<code>SSTable</code>的merge, 这类的<code>compaction</code>计算量大且计算模式相对一致，基于此，其构建了一个传统CPU架构+<code>FPGA</code>的协同计算模式, 对于写密集型的业务场景有着较大效率提升。</p>
</li>
<li><p><a href="https://blog.codingnow.com/2018/04/lua_54_nil_in_table.html" target="_blank" rel="external">Lua 5.4 的改进及 Lua 的版本演进</a> : 先Mark，没有深看，但是非常佩服云风对技术的持续投入和研究~</p>
</li>
</ul>
<h3 id="专题topic"><a href="#专题topic" class="headerlink" title="专题topic"></a>专题topic</h3><blockquote>
<p>本周关注simd</p>
</blockquote>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="external">Wikipedia: SIMD</a> : 对SIMD的概念性介绍, 其是一类并行技术的概称”单指令流多数据流”。在具体应用方面，CPU多以<code>SSE(Intel)</code>或者<code>3D Now!(AMD)</code>等提供支持，而GPU则是本身就拥有类似的能力。</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=8533350" target="_blank" rel="external">Introducing SIMD.js</a> : Mozilla发布的<code>SIMD</code>支持的Js Library, 主要是基于CPU的<code>SSE</code>或者<code>NEON</code>提供<code>SIMD</code>能力，希望在<code>games, video and audio manipulation, scientific simulations</code>提升其相关能力。</p>
</li>
<li><p><a href="http://sci.tuomastonteri.fi/programming/sse" target="_blank" rel="external">A practical guide to SSE SIMD with C++</a> : 关于SSE SIMD的实践教程，感觉有点冗长，另外也可以参看<a href="http://www.cs.uu.nl/docs/vakken/magr/2017-2018/files/SIMD%20Tutorial.pdf" target="_blank" rel="external">Practical SIMD Programming(pdf)</a></p>
</li>
</ul>
<blockquote>
<p>关于<a href="https://en.wikipedia.org/wiki/Tor_(anonymity_network" target="_blank" rel="external">TOR</a>)的一些文章</p>
</blockquote>
<ul>
<li><p><a href="https://jordan-wright.com/blog/2015/02/28/how-tor-works-part-one/" target="_blank" rel="external">How Tor Works(Part1/2/3)</a> : 从较为宏观的角度介绍Tor的执行机制和核心设计理念，是理解TOR的比较好的入门文档, 另外作者本身的blog主要关注安全因素相关，有不少文章值得细看</p>
</li>
<li><p><a href="https://www.digitaltrends.com/computing/a-beginners-guide-to-tor-how-to-navigate-through-the-underground-internet/" target="_blank" rel="external">A beginner’s guide to Tor: How to navigate through the underground Internet</a> : 也是一个入门的文章</p>
</li>
<li><p><a href="http://www.cs.umd.edu/class/fall2017/cmsc818O/papers/understanding-tor.pdf" target="_blank" rel="external">Shining Light in Dark Places: Understanding the Tor Network(pdf)</a> : </p>
</li>
<li><p><a href="https://www.freehaven.net/anonbib/cache/draft-tor-design-2004.pdf" target="_blank" rel="external">Tor: The Second-Generation Onion Router(pdf)</a> : 类似于Tor的白皮书，系统性介绍如何设计相关系统，可以深入了解</p>
</li>
<li><p><a href="https://www.torproject.org/docs/onion-services.html.en" target="_blank" rel="external">Tor: Onion Service Protocol</a> : 我们知道Tor不仅能提供匿名访问，也通用支持匿名提供<code>online service</code>; 其核心机制是依赖<a href="https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt" target="_blank" rel="external">rendezvous specification</a>，也就是依赖”约会协商”出一个中转<code>Relay</code>, 再基于此节点双方进行通信</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p><a href="http://redbeardlab.tech/rediSQL/" target="_blank" rel="external">RedisSQL</a> : RediSQL is a Redis module that embeds a fully functional SQLite database. 也就是说，基于<code>SQLit</code>做存储引擎，通过<code>Redis Module</code>做接口扩展，对于<code>partition</code>和<code>replication</code>的问题，应该不大好解决，但文章也没有特多涉及，需要细究。</p>
</li>
<li><p><a href="https://weibo.com/2126427211/GavUQjfLa?type=comment#_rnd1523244261713" target="_blank" rel="external">Deep learning的发展历程</a> : 比较系统，概括性的介绍了，深度学习的发展历程</p>
</li>
<li><p><a href="https://weibo.com/1907380525/Gbg8LzxEI?type=comment#_rnd1523274106579" target="_blank" rel="external">What are the ten most cited sources on Wikipedia? Let’s ask the data</a> : 关于Wikipeida资料引用的有趣分析, 文末付<a href="https://medium.com/freely-sharing-the-sum-of-all-knowledge/what-are-the-ten-most-cited-sources-on-wikipedia-lets-ask-the-data-34071478785a" target="_blank" rel="external">英文链接</a></p>
</li>
<li><p><a href="https://github.com/hongfanqie/discussion/issues/1" target="_blank" rel="external">技术文章翻译规范</a> : mark</p>
</li>
<li><p><a href="https://news.ycombinator.com/item?id=16806976" target="_blank" rel="external">AV1 beats x264 and libvpx-vp9 in practical use case</a> : “Our testing shows AV1 surpasses its stated goal of 30% better compression than VP9, and achieves gains of 50.3%, 46.2% and 34.0%, compared to x264 main profile, x264 high profile and libvpx-vp9, respectively.However, AV1 saw increases in encoding computational complexity compared with x264 main, x264 high and libvpx-vp9 for ABR mode. Encoding run time was 9226.4x, 8139.2x and 667.1x greater, respectively…”</p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/teamblog/docs-extension" target="_blank" rel="external">Announcing the Docs Markdown Extension for Visual Studio Code</a> : 基于<a href="https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html?tabs=tabid-2%2Ctabid-b" target="_blank" rel="external">DFX</a>语法的VS CODE扩展，个人感觉其语法赋予了不少新奇的能力，可以关注</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具技巧&quot;&gt;&lt;a href=&quot;#工具技巧&quot; class=&quot;headerlink&quot; title=&quot;工具技巧&quot;&gt;&lt;/a&gt;工具技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.cryptographyengineering.com/2018/0
    
    </summary>
    
    
      <category term="weekly" scheme="http://shevacjs.com/tags/weekly/"/>
    
  </entry>
  
</feed>
