<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Crypto101读书笔记 - shevacjs home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近要把去年的读书笔记补齐~  电子书Crypto 101是我个人感觉最好的关于密码学的入门笔记; 深入浅出的介绍了整个密码学体系的各类算法，此文为此书的读书笔记 分层体系 第一层: 最底层是基础算法原语的实现, 比如: md5, AES, RSA, SHA256等  第二层: 选定参数后，划分为符合密码学标准分类的算法, 几个基本能力:  块加密算法 流加密算法 密钥交换算法 公钥加密算法">
<meta name="keywords" content="cryptography">
<meta property="og:type" content="article">
<meta property="og:title" content="Crypto101读书笔记">
<meta property="og:url" content="http://shevacjs.com/2018/03/28/note_about_crypto101/index.html">
<meta property="og:site_name" content="shevacjs home">
<meta property="og:description" content="最近要把去年的读书笔记补齐~  电子书Crypto 101是我个人感觉最好的关于密码学的入门笔记; 深入浅出的介绍了整个密码学体系的各类算法，此文为此书的读书笔记 分层体系 第一层: 最底层是基础算法原语的实现, 比如: md5, AES, RSA, SHA256等  第二层: 选定参数后，划分为符合密码学标准分类的算法, 几个基本能力:  块加密算法 流加密算法 密钥交换算法 公钥加密算法">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://shevacjs.com/images/cryptography.jpg">
<meta property="og:image" content="http://shevacjs.com/images/ECB_encryption.svg.png">
<meta property="og:image" content="http://shevacjs.com/images/ECB_decryption.svg.png">
<meta property="og:image" content="http://shevacjs.com/images/CBC_encryption.svg.png">
<meta property="og:image" content="http://shevacjs.com/images/CBC_decryption.svg.png">
<meta property="og:image" content="http://shevacjs.com/images/Diffie-Hellman-demo.svg.png">
<meta property="og:updated_time" content="2018-03-28T08:13:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Crypto101读书笔记">
<meta name="twitter:description" content="最近要把去年的读书笔记补齐~  电子书Crypto 101是我个人感觉最好的关于密码学的入门笔记; 深入浅出的介绍了整个密码学体系的各类算法，此文为此书的读书笔记 分层体系 第一层: 最底层是基础算法原语的实现, 比如: md5, AES, RSA, SHA256等  第二层: 选定参数后，划分为符合密码学标准分类的算法, 几个基本能力:  块加密算法 流加密算法 密钥交换算法 公钥加密算法">
<meta name="twitter:image" content="http://shevacjs.com/images/cryptography.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Shevacjs</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shevacjs.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-note_about_crypto101" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Crypto101读书笔记
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2018/03/28/note_about_crypto101/" class="article-date">
  <time datetime="2018-03-28T07:58:45.000Z" itemprop="datePublished">2018-03-28</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/images/cryptography.jpg" alt="cryptography"></p>
<blockquote>
<p>最近要把去年的读书笔记补齐~</p>
</blockquote>
<p>电子书<a href="https://www.crypto101.io/" target="_blank" rel="external">Crypto 101</a>是我个人感觉最好的关于密码学的入门笔记; 深入浅出的介绍了整个密码学体系的各类算法，此文为此书的读书笔记</p>
<h2 id="分层体系"><a href="#分层体系" class="headerlink" title="分层体系"></a>分层体系</h2><ul>
<li><p>第一层: 最底层是基础算法原语的实现, 比如: md5, AES, RSA, SHA256等</p>
</li>
<li><p>第二层: 选定参数后，划分为符合密码学标准分类的算法, 几个基本能力:</p>
<ul>
<li>块加密算法</li>
<li>流加密算法</li>
<li>密钥交换算法</li>
<li>公钥加密算法</li>
<li>MAC算法</li>
<li>签名算法</li>
</ul>
</li>
<li><p>第三层: 基于标准分类算法进一步组合而成的半成品，比如说对称传输组件例如<code>aes-128-cbc + hmac-sha256</code>, 认证密钥协商算法<code>rsassa-OAEP + ecdh-secp256r1</code></p>
</li>
<li><p>第四层: 用各种组件拼装而成的各种成品密码学协议/软件, 比如TLS协议等</p>
</li>
</ul>
<p>这里先介绍第一/二层的常见技术和方法，以后再深入分析第四层的业务应用。</p>
<h2 id="标准密码学概述"><a href="#标准密码学概述" class="headerlink" title="标准密码学概述"></a>标准密码学概述</h2><h3 id="Block-ciphers"><a href="#Block-ciphers" class="headerlink" title="Block ciphers"></a>Block ciphers</h3><ul>
<li>定义:</li>
</ul>
<p>A block cipher is an algorithm that allows us to encrypt blocks of a fixed length.  It provides an encryption function E that turns plaintext blocks P into ciphertext blocks C, using a secret key k:</p>
<p>$$ C = E(k, P) \ \ encrpytion $$<br>$$ P = D(k, C) \ \ decryption $$</p>
<p>一般情况下, 明文和密文的长度是一样的，这个是由密钥控制的；</p>
<p>常见放的对称加密算法有: <code>AES</code>(Advanced Encryption Standard) 和 相对比较老的 <code>DES</code>和<code>3DES</code></p>
<p>可以预见块加密算法有两个比较大的问题，具体包括:</p>
<p>1) 块加密算法只能加密固定长度的信息，这个并不能很好应用于现实世界，所以我们需要引入<code>Stream ciphers</code></p>
<p>2) 密钥非常重要，但我们仍会面临着如何在一个不安全的通道上面交互密钥；这个在<code>key exchange protocol</code>里面会介绍其解决方案</p>
<h3 id="Stream-Ciphers"><a href="#Stream-Ciphers" class="headerlink" title="Stream Ciphers"></a>Stream Ciphers</h3><p>还是先看定义，英文如下:</p>
<p>“A stream cipher is a symmetric-key encryption algorithm that encrypts a stream of bits. Ideally, that stream could be as long as we’d like;”</p>
<p>如何实现, 初步的想法就是基于<code>Block Ciphers</code>去实现，将超长的文本切分为固定长度的子串，再分别加密。如何将<code>block ciphers</code>变成<code>stream ciphers</code>是需要精细考量的。比如最简单的ECB模式(Electronic Code Book Mode),  其过程大概如下:</p>
<p><img src="/images/ECB_encryption.svg.png" alt="ECB加密过程"></p>
<p><img src="/images/ECB_decryption.svg.png" alt="ECB解密过程"></p>
<p>但是这个模块是的弱点非常明显, 比如攻击者可以方便地做流量重放，而且密文和原始明文的顺序也是一一对应，容易被攻击。</p>
<p>我们可以考虑其他的几个方式，包括:</p>
<ul>
<li>CBC :  “plaintext blocks are XORed with the previous ciphertext block before being encrypted by the block cipher.”, 同时对于第一个block，我们通过引入初始向量解决(initialization vector, <code>IV</code>) ，其中<code>IV</code>我们要求满足不可预测的要求，所以一般用CBC模式加密的时候还需要双方达成<code>IV</code>的一致这个步骤(后续详解)</li>
</ul>
<p>如下是CBC的加解密过程示意图:</p>
<p><img src="/images/CBC_encryption.svg.png" alt="CBC加密过程"><br><img src="/images/CBC_decryption.svg.png" alt="CBC加密过程"></p>
<p>CBC模式对于初始向量有较大依赖，一旦<code>IV</code>被攻击者预测等，整个加密的安全性也难以得到保障</p>
<p>一些数学形式化的说明如下，可以简单参考</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Formulas</th>
<th>Ciphertext</th>
</tr>
</thead>
<tbody>
<tr>
<td>ECB</td>
<td>$Y_i = F(Plaintext_i, Key)$</td>
<td>$Y_i$</td>
</tr>
<tr>
<td>CBC</td>
<td>$Y_i = Plaintext_i XOR \ Ciphertext_{i-1}$</td>
<td>$F(Y,key); Ciphertext_0 = IV$</td>
</tr>
<tr>
<td>PCBC</td>
<td>$Y_i = Plaintext_i XOR \ (Ciphertext_{i-1} XOR \ Plaintext_{i-1})$</td>
<td>$F(Y,key); Ciphertext_0 = IV$</td>
</tr>
</tbody>
</table>
<p>虽然通过<code>CBC</code>等模式，我们可以实现对字节流的加密，但是如何达成密钥的一致性依旧是个问题，所以我们可以看下<code>Key Exchange Protocol</code></p>
<p>(如上的内容和表格都来自于<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="external">Wikipedia:Block cipher mode of operation</a>)</p>
<h3 id="Key-exchange"><a href="#Key-exchange" class="headerlink" title="Key exchange"></a>Key exchange</h3><p>目标大概如下: “Key exchange protocols attempt to solve a problem that, at first glance, seems impossible. Alice and Bob, who’ve never met before, have to agree on a secret value.  the channel they use to communicate is insecure: we’re assuming that everything they send across the channel is being eavesdropped on.”</p>
<p>该协议又称<code>Diffie-Hellman</code>算法, 一般有两个实现方式，包括<code>discrete logarithms</code>和<code>elliptic curves</code>，前者相对来说比较好理解，下面详细说明:</p>
<p>离散对数问题基于如下的假设，对于等式:</p>
<p>$$ g^x \equiv y (mod \ p) $$</p>
<p>已知$g,p$, 给定$x$计算$y$很容易，反之则很难; 则我们可以推理如下: </p>
<p>对于消息交换者Alice, Bob 和 窃听者Eve, 他们在传输消息时候有($r_a$和$r_b$是A，B产生的随机数), 则他们初步可以发送如下两个消息:</p>
<p>$$ m_a \equiv g^{(r_a)}(mod\ p)$$ </p>
<p>$$ m_b \equiv g^{(r_b)}(mod\ p)$$ </p>
<p>依照约定，可以产生密钥$s$</p>
<p>$$ s = (g^{(r_a)})^{r_b} (mod\ p)$$</p>
<p>这两个消息，三个人都能看见；但是对Alice而言，他收到了$m_b$我们有:</p>
<p>$$ s = m_b^{r_a} (mod\ p)$$ </p>
<p>对Bob同理；</p>
<p>$$ s = m_a^{r_b} (mod\ p)$$</p>
<p>但是对于只有$m_a,m_b,g,p$的Eve来说是不能计算出$s$的, 即便$m_a, m_b$相乘:</p>
<p>$$ t = m_a * m_b (mod\ p) = g^{r_a + r_b} (mod\ p)$$</p>
<p>如下是从<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">Wikipedia: 迪菲-赫尔曼密钥交换</a>摘录的示意图: </p>
<p><img src="/images/Diffie-Hellman-demo.svg.png" alt="DH示意图"></p>
<p>这个算法很优雅，但是存在很大的问题，就是中间人攻击。 所以我们需要一些新的基础能力，比如说去验证Alice和Bob的真假, 去保障我们消息的完整性。这个后续再讨论如何去保障。</p>
<h3 id="Public-Key-encryption"><a href="#Public-Key-encryption" class="headerlink" title="Public-Key encryption"></a>Public-Key encryption</h3><p>定义: “People can encrypt information intended for you by using your public key.  the information is then impossible to decipher without your private key.”</p>
<p>这里咬文嚼字一翻，公钥加密算法并不等同与『公钥算法』，后者的应用场景会更多，包括:</p>
<ul>
<li>密钥交换</li>
<li>加密信息</li>
<li>数字签名</li>
</ul>
<p>常见的公钥算法包括: </p>
<ul>
<li>RSA encryption algorithm (PKCS#1)</li>
<li>Various elliptic curve techniques</li>
<li>Diffie–Hellman key exchange protocol</li>
<li>ElGamal</li>
</ul>
<p>现在主流的是RSA和基于椭圆曲线的加密算法。</p>
<p>公钥算法是一个非常大的进步，而且直接感觉，好像所有的密码学问题都可以通过公钥算法解决。但是从现实角度而言,但是仅仅依靠此还不能构建健壮的安全体系，具体的问题包括:</p>
<ul>
<li>作用范围 : 公钥加密算法只能加密一小块的数据</li>
<li>性能问题，这个可以通过混合加密体系解决(公钥+对称加密)</li>
<li>合法性验证问题: 虽然我们可以加密解密任何消息，但是我们并不知道此消息是否来自真的发送者</li>
</ul>
<p>对与最后一个问题，我们需要一个机制去验证消息的合法性(完整性和不可否认性)；常见的做法是在发送消息的时候，增加一些额外信息，这次信息只能是正确的发送者才能构造的；同加密算法一样，验证消息机制同样有对称和非对称体系。如果发送方和接收方用同一个key进行验证，我们一般称为<code>MAC</code>(message authentication codes)；如果用不同的key进行验证，我们则称为<code>signature</code>(数字签名)</p>
<p>在介绍着两者之前，我们先简单介绍他们的基础支持体系 – hash function</p>
<h3 id="Hash-functions"><a href="#Hash-functions" class="headerlink" title="Hash functions"></a>Hash functions</h3><p>Hash函数一般而言是对一段文本的摘要(<code>digest</code>), 用于加密验证的hash function一般有更高的要求, 不再赘述，常见的有如下几个算法: </p>
<ul>
<li>MD5 : 不建议了</li>
<li>SHA-1 : 不建议范畴了</li>
<li>SHA-2 : 现在通用的</li>
<li>SHA-3(Keccak) : 未来的标准</li>
</ul>
<p>可以区别和注意的是<code>SHA2</code>和<code>SHA3</code>,后者的设计理念和前者完全不一致，在硬件上面的性能也更为高效。可以参看<a href="https://en.wikipedia.org/wiki/SHA-3" target="_blank" rel="external">Wikipedia:SHA-3
</a> 对比不同hash function的特性，表格太大，就不直接摘录了。</p>
<h3 id="Message-authentication-code"><a href="#Message-authentication-code" class="headerlink" title="Message authentication code"></a>Message authentication code</h3><p>定义: A Message authentication code (MAC) is a small bit of information that can be used to check the authenticity and the integrity of a message.  else codes are often called ”tags”</p>
<p>也就是说在双方共享$K_m$的情况下，需要达成一种协议，包括接收方能够快速的验证$P$的完整性。本质而言，就是需要一个$F$, 支持如下的模式:</p>
<p>$$ t = F(P, K_m)$$</p>
<p>对于如何将MAC和加密消息组合，有三种不同的方式，包括:</p>
<ul>
<li>Authenticate and encrypt : 分别进行消息验证和加密，类似于 $C = E(K_C, P), t = MAC(K_m, P)$, 同时发送$C$和$t$, SSH采用该方式</li>
<li>Authenticate, then encrypt : 对消息进行验证，其次和明文组合一起后加密发送，如下方式 $t=MAC(K_m,P), C=E(K_C,P||t)$, 只要发送$C$ 就可以了, TLS采用的方式</li>
<li>Encrypt, then authenticate : 先加密, 对加密串算MAC，后一起发送，类似$C=E(K_C,P), t=MAC(K_M,C)$, IPSec采用的方式</li>
</ul>
<p>普遍认为第三种方式是最好的，因为在解密之前就可以验证消息的合法性；</p>
<p>对于<code>MAC</code>的具体实现方式，本质而言，就是需要一个$F$, 给定密钥</p>
<ul>
<li>简单的方式: $t=H(k||m)$, H可以选择一个hash function,  这类组合方式有较大的安全风险(不展开)</li>
<li>HMAC(Hash-based Message Authentication Code<br>) : 其是通过特殊计算的消息验证码，有着更好的安全保障。可以参看其<a href="https://tools.ietf.org/html/rfc2104" target="_blank" rel="external">RFC文档</a></li>
<li>One-times MAC</li>
</ul>
<p>从上面可以看到, 我们现在对于<code>加密</code>和<code>消息验证</code>是当做两个独立的操作，但是在现实生活中，我们很少会独立应用这两个场景，所以现在也提出了AEAD(Authenticated Encryption with Associated Data), 其能支持”验证加密”(authenticated encryption), 将AE的能力以直观的方式提供给业务方。</p>
<h3 id="Signature-algorithms"><a href="#Signature-algorithms" class="headerlink" title="Signature algorithms"></a>Signature algorithms</h3><p>简单定义如下: </p>
<p>A signature algorithm is the public-key equivalent of a message authentication code. It consists of three parts:</p>
<ol>
<li>a key generation algorithm, which can be shared with other public-key algorithms</li>
<li>a signature generation algorithm </li>
<li>a signature verification algorithm</li>
</ol>
<p>很自然而然的我们可以想到<code>RSA</code>可以用于数字签名</p>
<p>下面我们简单分析另外一个数字签名算法<code>DSA</code>, 其分为两个缓解，一个是参数选择，另外一个是生成公钥私钥; 具体如下:</p>
<blockquote>
<p>TODO, 补充</p>
</blockquote>
<h4 id="DSA-Parameter-generation"><a href="#DSA-Parameter-generation" class="headerlink" title="DSA Parameter generation"></a>DSA Parameter generation</h4><h4 id="Key-generation"><a href="#Key-generation" class="headerlink" title="Key generation"></a>Key generation</h4><p>如下是常见的签名算法(<a href="https://en.wikipedia.org/wiki/Digital_signature" target="_blank" rel="external">Wikipedia: Digital signature
</a>)</p>
<ul>
<li>RSA-based signature schemes, such as RSA-PSS</li>
<li>DSA and its elliptic curve variant ECDSA</li>
<li>Edwards-curve Digital Signature Algorithm and its Ed25519 variant.</li>
</ul>
<h2 id="通信过程概述"><a href="#通信过程概述" class="headerlink" title="通信过程概述"></a>通信过程概述</h2><p>通过如上的分析，我们可以认为拥有如下几个能力:</p>
<ul>
<li>对称加密能力 : 给定一个key，将内容进行加密的能力</li>
<li>消息散列 : 通过一个key，可以验证消息的完整性和认证</li>
<li>非对称加密能力: 可以通过公钥密钥进行加解密</li>
<li>数字签名 : 通过非对称密钥验证消息完整性和认证</li>
</ul>
<p>基于此，可以构建上层更复杂丰富的业务场景，比如说<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a>; 这个里面的细节比较多，我们在以后的文章详细介绍TLS的协议流程。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/">cryptography</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/03/27/20180318/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">weekly of 20180318&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>






<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>


</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 shevacjs&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'shevacjs-com';
  
  var disqus_url = 'http://shevacjs.com/2018/03/28/note_about_crypto101/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>